/*
 * Generated by gen_defines.py
 *
 * DTS input file:
 *   /home/aknight/zephyrproject/build/zephyr/zephyr.dts.pre
 *
 * Directories with bindings:
 *   $ZEPHYR_BASE/dts/bindings
 *
 * Node dependency ordering (ordinal and path):
 *   0   /
 *   1   /aliases
 *   2   /can_loopback0
 *   3   /chosen
 *   4   /counter
 *   5   /ec-host-cmd-periph
 *   6   /eeprom
 *   7   /espi@300
 *   8   /i2c@100
 *   9   /rng
 *   10  /sdl_dc
 *   11  /spi@200
 *   12  /uart
 *   13  /uart_1
 *   14  /udc0
 *   15  /cpus
 *   16  /cpus/cpu@0
 *   17  /flash-controller@0
 *   18  /flash-controller@0/flash@0
 *   19  /flash-controller@0/flash@0/partitions
 *   20  /flash-controller@0/flash@0/partitions/partition@0
 *   21  /flash-controller@0/flash@0/partitions/partition@c000
 *   22  /flash-controller@0/flash@0/partitions/partition@75000
 *   23  /flash-controller@0/flash@0/partitions/partition@de000
 *   24  /flash-controller@0/flash@0/partitions/partition@fc000
 *   25  /gpio@800
 *   26  /leds
 *   27  /leds/led_0
 *
 * Definitions derived from these nodes in dependency order are next,
 * followed by /chosen nodes.
 */

/*
 * Devicetree node: /
 *
 * Node identifier: DT_N
 */

/* Node's full path: */
#define DT_N_PATH "/"

/* Node's name with unit-address: */
#define DT_N_FULL_NAME "/"
#define DT_N_FOREACH_CHILD(fn) fn(DT_N_S_chosen) fn(DT_N_S_aliases) fn(DT_N_S_leds) fn(DT_N_S_cpus) fn(DT_N_S_flash_controller_0) fn(DT_N_S_eeprom) fn(DT_N_S_i2c_100) fn(DT_N_S_spi_200) fn(DT_N_S_espi_300) fn(DT_N_S_uart) fn(DT_N_S_uart_1) fn(DT_N_S_rng) fn(DT_N_S_counter) fn(DT_N_S_ec_host_cmd_periph) fn(DT_N_S_gpio_800) fn(DT_N_S_udc0) fn(DT_N_S_sdl_dc) fn(DT_N_S_can_loopback0)
#define DT_N_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_chosen, __VA_ARGS__) fn(DT_N_S_aliases, __VA_ARGS__) fn(DT_N_S_leds, __VA_ARGS__) fn(DT_N_S_cpus, __VA_ARGS__) fn(DT_N_S_flash_controller_0, __VA_ARGS__) fn(DT_N_S_eeprom, __VA_ARGS__) fn(DT_N_S_i2c_100, __VA_ARGS__) fn(DT_N_S_spi_200, __VA_ARGS__) fn(DT_N_S_espi_300, __VA_ARGS__) fn(DT_N_S_uart, __VA_ARGS__) fn(DT_N_S_uart_1, __VA_ARGS__) fn(DT_N_S_rng, __VA_ARGS__) fn(DT_N_S_counter, __VA_ARGS__) fn(DT_N_S_ec_host_cmd_periph, __VA_ARGS__) fn(DT_N_S_gpio_800, __VA_ARGS__) fn(DT_N_S_udc0, __VA_ARGS__) fn(DT_N_S_sdl_dc, __VA_ARGS__) fn(DT_N_S_can_loopback0, __VA_ARGS__)
#define DT_N_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_chosen) fn(DT_N_S_aliases) fn(DT_N_S_leds) fn(DT_N_S_cpus) fn(DT_N_S_flash_controller_0) fn(DT_N_S_eeprom) fn(DT_N_S_i2c_100) fn(DT_N_S_spi_200) fn(DT_N_S_espi_300) fn(DT_N_S_uart) fn(DT_N_S_uart_1) fn(DT_N_S_rng) fn(DT_N_S_counter) fn(DT_N_S_ec_host_cmd_periph) fn(DT_N_S_gpio_800) fn(DT_N_S_udc0) fn(DT_N_S_sdl_dc) 
#define DT_N_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_chosen, __VA_ARGS__) fn(DT_N_S_aliases, __VA_ARGS__) fn(DT_N_S_leds, __VA_ARGS__) fn(DT_N_S_cpus, __VA_ARGS__) fn(DT_N_S_flash_controller_0, __VA_ARGS__) fn(DT_N_S_eeprom, __VA_ARGS__) fn(DT_N_S_i2c_100, __VA_ARGS__) fn(DT_N_S_spi_200, __VA_ARGS__) fn(DT_N_S_espi_300, __VA_ARGS__) fn(DT_N_S_uart, __VA_ARGS__) fn(DT_N_S_uart_1, __VA_ARGS__) fn(DT_N_S_rng, __VA_ARGS__) fn(DT_N_S_counter, __VA_ARGS__) fn(DT_N_S_ec_host_cmd_periph, __VA_ARGS__) fn(DT_N_S_gpio_800, __VA_ARGS__) fn(DT_N_S_udc0, __VA_ARGS__) fn(DT_N_S_sdl_dc, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_ORD 0

/* Ordinals for what this node depends on directly: */
#define DT_N_REQUIRES_ORDS /* nothing */

/* Ordinals for what depends directly on this node: */
#define DT_N_SUPPORTS_ORDS \
	1, /* /aliases */ \
	2, /* /can_loopback0 */ \
	3, /* /chosen */ \
	4, /* /counter */ \
	5, /* /ec-host-cmd-periph */ \
	6, /* /eeprom */ \
	7, /* /espi@300 */ \
	8, /* /i2c@100 */ \
	9, /* /rng */ \
	10, /* /sdl_dc */ \
	11, /* /spi@200 */ \
	12, /* /uart */ \
	13, /* /uart_1 */ \
	14, /* /udc0 */ \
	15, /* /cpus */ \
	17, /* /flash-controller@0 */ \
	25, /* /gpio@800 */ \
	26, /* /leds */

/* Existence and alternate IDs: */
#define DT_N_EXISTS 1
#define DT_N_INST_0_zephyr_posix DT_N

/* Macros for properties that are special in the specification: */
#define DT_N_REG_NUM 0
#define DT_N_RANGES_NUM 0
#define DT_N_FOREACH_RANGE(fn) 
#define DT_N_IRQ_NUM 0
#define DT_N_COMPAT_MATCHES_zephyr_posix 1
#define DT_N_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_P_compatible {"zephyr,posix"}
#define DT_N_P_compatible_IDX_0 "zephyr,posix"
#define DT_N_P_compatible_IDX_0_EXISTS 1
#define DT_N_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N, compatible, 0)
#define DT_N_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N, compatible, 0, __VA_ARGS__)
#define DT_N_P_compatible_LEN 1
#define DT_N_P_compatible_EXISTS 1

/*
 * Devicetree node: /aliases
 *
 * Node identifier: DT_N_S_aliases
 */

/* Node's full path: */
#define DT_N_S_aliases_PATH "/aliases"

/* Node's name with unit-address: */
#define DT_N_S_aliases_FULL_NAME "aliases"

/* Node parent (/) identifier: */
#define DT_N_S_aliases_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_aliases_CHILD_IDX 1
#define DT_N_S_aliases_FOREACH_CHILD(fn) 
#define DT_N_S_aliases_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_aliases_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_aliases_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_aliases_ORD 1

/* Ordinals for what this node depends on directly: */
#define DT_N_S_aliases_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_aliases_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_aliases_EXISTS 1

/* Macros for properties that are special in the specification: */
#define DT_N_S_aliases_REG_NUM 0
#define DT_N_S_aliases_RANGES_NUM 0
#define DT_N_S_aliases_FOREACH_RANGE(fn) 
#define DT_N_S_aliases_IRQ_NUM 0
#define DT_N_S_aliases_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_aliases_PINCTRL_NUM 0

/* (No generic property macros) */

/*
 * Devicetree node: /can_loopback0
 *
 * Node identifier: DT_N_S_can_loopback0
 *
 * Binding (compatible = zephyr,can-loopback):
 *   $ZEPHYR_BASE/dts/bindings/can/zephyr,can-loopback.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_can_loopback0_PATH "/can_loopback0"

/* Node's name with unit-address: */
#define DT_N_S_can_loopback0_FULL_NAME "can_loopback0"

/* Node parent (/) identifier: */
#define DT_N_S_can_loopback0_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_can_loopback0_CHILD_IDX 17
#define DT_N_S_can_loopback0_FOREACH_CHILD(fn) 
#define DT_N_S_can_loopback0_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_can_loopback0_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_can_loopback0_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_can_loopback0_ORD 2

/* Ordinals for what this node depends on directly: */
#define DT_N_S_can_loopback0_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_can_loopback0_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_can_loopback0_EXISTS 1
#define DT_N_INST_0_zephyr_can_loopback DT_N_S_can_loopback0
#define DT_N_NODELABEL_can_loopback0    DT_N_S_can_loopback0

/* Macros for properties that are special in the specification: */
#define DT_N_S_can_loopback0_REG_NUM 0
#define DT_N_S_can_loopback0_RANGES_NUM 0
#define DT_N_S_can_loopback0_FOREACH_RANGE(fn) 
#define DT_N_S_can_loopback0_IRQ_NUM 0
#define DT_N_S_can_loopback0_COMPAT_MATCHES_zephyr_can_loopback 1
#define DT_N_S_can_loopback0_STATUS_disabled 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_can_loopback0_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_can_loopback0_P_bus_speed 125000
#define DT_N_S_can_loopback0_P_bus_speed_EXISTS 1
#define DT_N_S_can_loopback0_P_sjw 1
#define DT_N_S_can_loopback0_P_sjw_EXISTS 1
#define DT_N_S_can_loopback0_P_sample_point 875
#define DT_N_S_can_loopback0_P_sample_point_EXISTS 1
#define DT_N_S_can_loopback0_P_status "disabled"
#define DT_N_S_can_loopback0_P_status_STRING_TOKEN disabled
#define DT_N_S_can_loopback0_P_status_STRING_UPPER_TOKEN DISABLED
#define DT_N_S_can_loopback0_P_status_ENUM_IDX 2
#define DT_N_S_can_loopback0_P_status_ENUM_TOKEN disabled
#define DT_N_S_can_loopback0_P_status_ENUM_UPPER_TOKEN DISABLED
#define DT_N_S_can_loopback0_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_can_loopback0, status, 0) \
	fn(DT_N_S_can_loopback0, status, 1) \
	fn(DT_N_S_can_loopback0, status, 2) \
	fn(DT_N_S_can_loopback0, status, 3) \
	fn(DT_N_S_can_loopback0, status, 4) \
	fn(DT_N_S_can_loopback0, status, 5) \
	fn(DT_N_S_can_loopback0, status, 6) \
	fn(DT_N_S_can_loopback0, status, 7)
#define DT_N_S_can_loopback0_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_can_loopback0, status, 0, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, status, 1, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, status, 2, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, status, 3, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, status, 4, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, status, 5, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, status, 6, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, status, 7, __VA_ARGS__)
#define DT_N_S_can_loopback0_P_status_EXISTS 1
#define DT_N_S_can_loopback0_P_compatible {"zephyr,can-loopback"}
#define DT_N_S_can_loopback0_P_compatible_IDX_0 "zephyr,can-loopback"
#define DT_N_S_can_loopback0_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_can_loopback0_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_can_loopback0, compatible, 0)
#define DT_N_S_can_loopback0_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_can_loopback0, compatible, 0, __VA_ARGS__)
#define DT_N_S_can_loopback0_P_compatible_LEN 1
#define DT_N_S_can_loopback0_P_compatible_EXISTS 1
#define DT_N_S_can_loopback0_P_label "CAN_LOOPBACK_0"
#define DT_N_S_can_loopback0_P_label_STRING_TOKEN CAN_LOOPBACK_0
#define DT_N_S_can_loopback0_P_label_STRING_UPPER_TOKEN CAN_LOOPBACK_0
#define DT_N_S_can_loopback0_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_can_loopback0, label, 0) \
	fn(DT_N_S_can_loopback0, label, 1) \
	fn(DT_N_S_can_loopback0, label, 2) \
	fn(DT_N_S_can_loopback0, label, 3) \
	fn(DT_N_S_can_loopback0, label, 4) \
	fn(DT_N_S_can_loopback0, label, 5) \
	fn(DT_N_S_can_loopback0, label, 6) \
	fn(DT_N_S_can_loopback0, label, 7) \
	fn(DT_N_S_can_loopback0, label, 8) \
	fn(DT_N_S_can_loopback0, label, 9) \
	fn(DT_N_S_can_loopback0, label, 10) \
	fn(DT_N_S_can_loopback0, label, 11) \
	fn(DT_N_S_can_loopback0, label, 12) \
	fn(DT_N_S_can_loopback0, label, 13)
#define DT_N_S_can_loopback0_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_can_loopback0, label, 0, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 1, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 2, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 3, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 4, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 5, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 6, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 7, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 8, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 9, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 10, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 11, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 12, __VA_ARGS__) \
	fn(DT_N_S_can_loopback0, label, 13, __VA_ARGS__)
#define DT_N_S_can_loopback0_P_label_EXISTS 1
#define DT_N_S_can_loopback0_P_wakeup_source 0
#define DT_N_S_can_loopback0_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /chosen
 *
 * Node identifier: DT_N_S_chosen
 */

/* Node's full path: */
#define DT_N_S_chosen_PATH "/chosen"

/* Node's name with unit-address: */
#define DT_N_S_chosen_FULL_NAME "chosen"

/* Node parent (/) identifier: */
#define DT_N_S_chosen_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_chosen_CHILD_IDX 0
#define DT_N_S_chosen_FOREACH_CHILD(fn) 
#define DT_N_S_chosen_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_chosen_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_chosen_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_chosen_ORD 3

/* Ordinals for what this node depends on directly: */
#define DT_N_S_chosen_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_chosen_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_chosen_EXISTS 1

/* Macros for properties that are special in the specification: */
#define DT_N_S_chosen_REG_NUM 0
#define DT_N_S_chosen_RANGES_NUM 0
#define DT_N_S_chosen_FOREACH_RANGE(fn) 
#define DT_N_S_chosen_IRQ_NUM 0
#define DT_N_S_chosen_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_chosen_PINCTRL_NUM 0

/* (No generic property macros) */

/*
 * Devicetree node: /counter
 *
 * Node identifier: DT_N_S_counter
 */

/* Node's full path: */
#define DT_N_S_counter_PATH "/counter"

/* Node's name with unit-address: */
#define DT_N_S_counter_FULL_NAME "counter"

/* Node parent (/) identifier: */
#define DT_N_S_counter_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_counter_CHILD_IDX 12
#define DT_N_S_counter_FOREACH_CHILD(fn) 
#define DT_N_S_counter_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_counter_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_counter_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_counter_ORD 4

/* Ordinals for what this node depends on directly: */
#define DT_N_S_counter_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_counter_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_counter_EXISTS 1
#define DT_N_INST_0_zephyr_native_posix_counter DT_N_S_counter
#define DT_N_NODELABEL_counter0                 DT_N_S_counter

/* Macros for properties that are special in the specification: */
#define DT_N_S_counter_REG_NUM 0
#define DT_N_S_counter_RANGES_NUM 0
#define DT_N_S_counter_FOREACH_RANGE(fn) 
#define DT_N_S_counter_IRQ_NUM 0
#define DT_N_S_counter_COMPAT_MATCHES_zephyr_native_posix_counter 1
#define DT_N_S_counter_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_counter_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_counter_P_status "okay"
#define DT_N_S_counter_P_status_STRING_TOKEN okay
#define DT_N_S_counter_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_counter_P_status_ENUM_IDX 1
#define DT_N_S_counter_P_status_ENUM_TOKEN okay
#define DT_N_S_counter_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_counter_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_counter, status, 0) \
	fn(DT_N_S_counter, status, 1) \
	fn(DT_N_S_counter, status, 2) \
	fn(DT_N_S_counter, status, 3)
#define DT_N_S_counter_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_counter, status, 0, __VA_ARGS__) \
	fn(DT_N_S_counter, status, 1, __VA_ARGS__) \
	fn(DT_N_S_counter, status, 2, __VA_ARGS__) \
	fn(DT_N_S_counter, status, 3, __VA_ARGS__)
#define DT_N_S_counter_P_status_EXISTS 1
#define DT_N_S_counter_P_compatible {"zephyr,native-posix-counter"}
#define DT_N_S_counter_P_compatible_IDX_0 "zephyr,native-posix-counter"
#define DT_N_S_counter_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_counter_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_counter, compatible, 0)
#define DT_N_S_counter_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_counter, compatible, 0, __VA_ARGS__)
#define DT_N_S_counter_P_compatible_LEN 1
#define DT_N_S_counter_P_compatible_EXISTS 1
#define DT_N_S_counter_P_label "COUNTER_0"
#define DT_N_S_counter_P_label_STRING_TOKEN COUNTER_0
#define DT_N_S_counter_P_label_STRING_UPPER_TOKEN COUNTER_0
#define DT_N_S_counter_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_counter, label, 0) \
	fn(DT_N_S_counter, label, 1) \
	fn(DT_N_S_counter, label, 2) \
	fn(DT_N_S_counter, label, 3) \
	fn(DT_N_S_counter, label, 4) \
	fn(DT_N_S_counter, label, 5) \
	fn(DT_N_S_counter, label, 6) \
	fn(DT_N_S_counter, label, 7) \
	fn(DT_N_S_counter, label, 8)
#define DT_N_S_counter_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_counter, label, 0, __VA_ARGS__) \
	fn(DT_N_S_counter, label, 1, __VA_ARGS__) \
	fn(DT_N_S_counter, label, 2, __VA_ARGS__) \
	fn(DT_N_S_counter, label, 3, __VA_ARGS__) \
	fn(DT_N_S_counter, label, 4, __VA_ARGS__) \
	fn(DT_N_S_counter, label, 5, __VA_ARGS__) \
	fn(DT_N_S_counter, label, 6, __VA_ARGS__) \
	fn(DT_N_S_counter, label, 7, __VA_ARGS__) \
	fn(DT_N_S_counter, label, 8, __VA_ARGS__)
#define DT_N_S_counter_P_label_EXISTS 1

/*
 * Devicetree node: /ec-host-cmd-periph
 *
 * Node identifier: DT_N_S_ec_host_cmd_periph
 *
 * Binding (compatible = zephyr,sim-ec-host-cmd-periph):
 *   $ZEPHYR_BASE/dts/bindings/ec_host_cmd_perhip/zephyr,sim-ec-host-cmd-periph.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_ec_host_cmd_periph_PATH "/ec-host-cmd-periph"

/* Node's name with unit-address: */
#define DT_N_S_ec_host_cmd_periph_FULL_NAME "ec-host-cmd-periph"

/* Node parent (/) identifier: */
#define DT_N_S_ec_host_cmd_periph_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_ec_host_cmd_periph_CHILD_IDX 13
#define DT_N_S_ec_host_cmd_periph_FOREACH_CHILD(fn) 
#define DT_N_S_ec_host_cmd_periph_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_ec_host_cmd_periph_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_ec_host_cmd_periph_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_ec_host_cmd_periph_ORD 5

/* Ordinals for what this node depends on directly: */
#define DT_N_S_ec_host_cmd_periph_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_ec_host_cmd_periph_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_ec_host_cmd_periph_EXISTS 1
#define DT_N_INST_0_zephyr_sim_ec_host_cmd_periph DT_N_S_ec_host_cmd_periph
#define DT_N_NODELABEL_hcp                        DT_N_S_ec_host_cmd_periph

/* Macros for properties that are special in the specification: */
#define DT_N_S_ec_host_cmd_periph_REG_NUM 0
#define DT_N_S_ec_host_cmd_periph_RANGES_NUM 0
#define DT_N_S_ec_host_cmd_periph_FOREACH_RANGE(fn) 
#define DT_N_S_ec_host_cmd_periph_IRQ_NUM 0
#define DT_N_S_ec_host_cmd_periph_COMPAT_MATCHES_zephyr_sim_ec_host_cmd_periph 1
#define DT_N_S_ec_host_cmd_periph_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_ec_host_cmd_periph_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_ec_host_cmd_periph_P_label "EC_HOST_CMD_SIM"
#define DT_N_S_ec_host_cmd_periph_P_label_STRING_TOKEN EC_HOST_CMD_SIM
#define DT_N_S_ec_host_cmd_periph_P_label_STRING_UPPER_TOKEN EC_HOST_CMD_SIM
#define DT_N_S_ec_host_cmd_periph_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_ec_host_cmd_periph, label, 0) \
	fn(DT_N_S_ec_host_cmd_periph, label, 1) \
	fn(DT_N_S_ec_host_cmd_periph, label, 2) \
	fn(DT_N_S_ec_host_cmd_periph, label, 3) \
	fn(DT_N_S_ec_host_cmd_periph, label, 4) \
	fn(DT_N_S_ec_host_cmd_periph, label, 5) \
	fn(DT_N_S_ec_host_cmd_periph, label, 6) \
	fn(DT_N_S_ec_host_cmd_periph, label, 7) \
	fn(DT_N_S_ec_host_cmd_periph, label, 8) \
	fn(DT_N_S_ec_host_cmd_periph, label, 9) \
	fn(DT_N_S_ec_host_cmd_periph, label, 10) \
	fn(DT_N_S_ec_host_cmd_periph, label, 11) \
	fn(DT_N_S_ec_host_cmd_periph, label, 12) \
	fn(DT_N_S_ec_host_cmd_periph, label, 13) \
	fn(DT_N_S_ec_host_cmd_periph, label, 14)
#define DT_N_S_ec_host_cmd_periph_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_ec_host_cmd_periph, label, 0, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 1, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 2, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 3, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 4, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 5, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 6, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 7, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 8, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 9, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 10, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 11, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 12, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 13, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, label, 14, __VA_ARGS__)
#define DT_N_S_ec_host_cmd_periph_P_label_EXISTS 1
#define DT_N_S_ec_host_cmd_periph_P_status "okay"
#define DT_N_S_ec_host_cmd_periph_P_status_STRING_TOKEN okay
#define DT_N_S_ec_host_cmd_periph_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_ec_host_cmd_periph_P_status_ENUM_IDX 1
#define DT_N_S_ec_host_cmd_periph_P_status_ENUM_TOKEN okay
#define DT_N_S_ec_host_cmd_periph_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_ec_host_cmd_periph_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_ec_host_cmd_periph, status, 0) \
	fn(DT_N_S_ec_host_cmd_periph, status, 1) \
	fn(DT_N_S_ec_host_cmd_periph, status, 2) \
	fn(DT_N_S_ec_host_cmd_periph, status, 3)
#define DT_N_S_ec_host_cmd_periph_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_ec_host_cmd_periph, status, 0, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, status, 1, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, status, 2, __VA_ARGS__) \
	fn(DT_N_S_ec_host_cmd_periph, status, 3, __VA_ARGS__)
#define DT_N_S_ec_host_cmd_periph_P_status_EXISTS 1
#define DT_N_S_ec_host_cmd_periph_P_compatible {"zephyr,sim-ec-host-cmd-periph"}
#define DT_N_S_ec_host_cmd_periph_P_compatible_IDX_0 "zephyr,sim-ec-host-cmd-periph"
#define DT_N_S_ec_host_cmd_periph_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_ec_host_cmd_periph_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_ec_host_cmd_periph, compatible, 0)
#define DT_N_S_ec_host_cmd_periph_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_ec_host_cmd_periph, compatible, 0, __VA_ARGS__)
#define DT_N_S_ec_host_cmd_periph_P_compatible_LEN 1
#define DT_N_S_ec_host_cmd_periph_P_compatible_EXISTS 1
#define DT_N_S_ec_host_cmd_periph_P_wakeup_source 0
#define DT_N_S_ec_host_cmd_periph_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /eeprom
 *
 * Node identifier: DT_N_S_eeprom
 *
 * Binding (compatible = zephyr,sim-eeprom):
 *   $ZEPHYR_BASE/dts/bindings/mtd/zephyr,sim-eeprom.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_eeprom_PATH "/eeprom"

/* Node's name with unit-address: */
#define DT_N_S_eeprom_FULL_NAME "eeprom"

/* Node parent (/) identifier: */
#define DT_N_S_eeprom_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_eeprom_CHILD_IDX 5
#define DT_N_S_eeprom_FOREACH_CHILD(fn) 
#define DT_N_S_eeprom_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_eeprom_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_eeprom_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_eeprom_ORD 6

/* Ordinals for what this node depends on directly: */
#define DT_N_S_eeprom_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_eeprom_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_eeprom_EXISTS 1
#define DT_N_ALIAS_eeprom_0           DT_N_S_eeprom
#define DT_N_INST_0_zephyr_sim_eeprom DT_N_S_eeprom
#define DT_N_NODELABEL_eeprom0        DT_N_S_eeprom

/* Macros for properties that are special in the specification: */
#define DT_N_S_eeprom_REG_NUM 0
#define DT_N_S_eeprom_RANGES_NUM 0
#define DT_N_S_eeprom_FOREACH_RANGE(fn) 
#define DT_N_S_eeprom_IRQ_NUM 0
#define DT_N_S_eeprom_COMPAT_MATCHES_zephyr_sim_eeprom 1
#define DT_N_S_eeprom_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_eeprom_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_eeprom_P_size 32768
#define DT_N_S_eeprom_P_size_EXISTS 1
#define DT_N_S_eeprom_P_read_only 0
#define DT_N_S_eeprom_P_read_only_EXISTS 1
#define DT_N_S_eeprom_P_label "EEPROM_0"
#define DT_N_S_eeprom_P_label_STRING_TOKEN EEPROM_0
#define DT_N_S_eeprom_P_label_STRING_UPPER_TOKEN EEPROM_0
#define DT_N_S_eeprom_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_eeprom, label, 0) \
	fn(DT_N_S_eeprom, label, 1) \
	fn(DT_N_S_eeprom, label, 2) \
	fn(DT_N_S_eeprom, label, 3) \
	fn(DT_N_S_eeprom, label, 4) \
	fn(DT_N_S_eeprom, label, 5) \
	fn(DT_N_S_eeprom, label, 6) \
	fn(DT_N_S_eeprom, label, 7)
#define DT_N_S_eeprom_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_eeprom, label, 0, __VA_ARGS__) \
	fn(DT_N_S_eeprom, label, 1, __VA_ARGS__) \
	fn(DT_N_S_eeprom, label, 2, __VA_ARGS__) \
	fn(DT_N_S_eeprom, label, 3, __VA_ARGS__) \
	fn(DT_N_S_eeprom, label, 4, __VA_ARGS__) \
	fn(DT_N_S_eeprom, label, 5, __VA_ARGS__) \
	fn(DT_N_S_eeprom, label, 6, __VA_ARGS__) \
	fn(DT_N_S_eeprom, label, 7, __VA_ARGS__)
#define DT_N_S_eeprom_P_label_EXISTS 1
#define DT_N_S_eeprom_P_status "okay"
#define DT_N_S_eeprom_P_status_STRING_TOKEN okay
#define DT_N_S_eeprom_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_eeprom_P_status_ENUM_IDX 1
#define DT_N_S_eeprom_P_status_ENUM_TOKEN okay
#define DT_N_S_eeprom_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_eeprom_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_eeprom, status, 0) \
	fn(DT_N_S_eeprom, status, 1) \
	fn(DT_N_S_eeprom, status, 2) \
	fn(DT_N_S_eeprom, status, 3)
#define DT_N_S_eeprom_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_eeprom, status, 0, __VA_ARGS__) \
	fn(DT_N_S_eeprom, status, 1, __VA_ARGS__) \
	fn(DT_N_S_eeprom, status, 2, __VA_ARGS__) \
	fn(DT_N_S_eeprom, status, 3, __VA_ARGS__)
#define DT_N_S_eeprom_P_status_EXISTS 1
#define DT_N_S_eeprom_P_compatible {"zephyr,sim-eeprom"}
#define DT_N_S_eeprom_P_compatible_IDX_0 "zephyr,sim-eeprom"
#define DT_N_S_eeprom_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_eeprom_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_eeprom, compatible, 0)
#define DT_N_S_eeprom_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_eeprom, compatible, 0, __VA_ARGS__)
#define DT_N_S_eeprom_P_compatible_LEN 1
#define DT_N_S_eeprom_P_compatible_EXISTS 1
#define DT_N_S_eeprom_P_wakeup_source 0
#define DT_N_S_eeprom_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /espi@300
 *
 * Node identifier: DT_N_S_espi_300
 *
 * Binding (compatible = zephyr,espi-emul-controller):
 *   $ZEPHYR_BASE/dts/bindings/espi/zephyr,espi-emul-controller.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_espi_300_PATH "/espi@300"

/* Node's name with unit-address: */
#define DT_N_S_espi_300_FULL_NAME "espi@300"

/* Node parent (/) identifier: */
#define DT_N_S_espi_300_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_espi_300_CHILD_IDX 8
#define DT_N_S_espi_300_FOREACH_CHILD(fn) 
#define DT_N_S_espi_300_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_espi_300_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_espi_300_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_espi_300_ORD 7

/* Ordinals for what this node depends on directly: */
#define DT_N_S_espi_300_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_espi_300_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_espi_300_EXISTS 1
#define DT_N_INST_0_zephyr_espi_emul_controller DT_N_S_espi_300
#define DT_N_NODELABEL_espi0                    DT_N_S_espi_300

/* Macros for properties that are special in the specification: */
#define DT_N_S_espi_300_REG_NUM 1
#define DT_N_S_espi_300_REG_IDX_0_EXISTS 1
#define DT_N_S_espi_300_REG_IDX_0_VAL_ADDRESS 768 /* 0x300 */
#define DT_N_S_espi_300_REG_IDX_0_VAL_SIZE 4 /* 0x4 */
#define DT_N_S_espi_300_RANGES_NUM 0
#define DT_N_S_espi_300_FOREACH_RANGE(fn) 
#define DT_N_S_espi_300_IRQ_NUM 0
#define DT_N_S_espi_300_COMPAT_MATCHES_zephyr_espi_emul_controller 1
#define DT_N_S_espi_300_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_espi_300_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_espi_300_P_reg {768 /* 0x300 */, 4 /* 0x4 */}
#define DT_N_S_espi_300_P_reg_IDX_0 768
#define DT_N_S_espi_300_P_reg_IDX_0_EXISTS 1
#define DT_N_S_espi_300_P_reg_IDX_1 4
#define DT_N_S_espi_300_P_reg_IDX_1_EXISTS 1
#define DT_N_S_espi_300_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_espi_300, reg, 0) \
	fn(DT_N_S_espi_300, reg, 1)
#define DT_N_S_espi_300_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_espi_300, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_espi_300, reg, 1, __VA_ARGS__)
#define DT_N_S_espi_300_P_reg_EXISTS 1
#define DT_N_S_espi_300_P_label "ESPI_0"
#define DT_N_S_espi_300_P_label_STRING_TOKEN ESPI_0
#define DT_N_S_espi_300_P_label_STRING_UPPER_TOKEN ESPI_0
#define DT_N_S_espi_300_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_espi_300, label, 0) \
	fn(DT_N_S_espi_300, label, 1) \
	fn(DT_N_S_espi_300, label, 2) \
	fn(DT_N_S_espi_300, label, 3) \
	fn(DT_N_S_espi_300, label, 4) \
	fn(DT_N_S_espi_300, label, 5)
#define DT_N_S_espi_300_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_espi_300, label, 0, __VA_ARGS__) \
	fn(DT_N_S_espi_300, label, 1, __VA_ARGS__) \
	fn(DT_N_S_espi_300, label, 2, __VA_ARGS__) \
	fn(DT_N_S_espi_300, label, 3, __VA_ARGS__) \
	fn(DT_N_S_espi_300, label, 4, __VA_ARGS__) \
	fn(DT_N_S_espi_300, label, 5, __VA_ARGS__)
#define DT_N_S_espi_300_P_label_EXISTS 1
#define DT_N_S_espi_300_P_status "okay"
#define DT_N_S_espi_300_P_status_STRING_TOKEN okay
#define DT_N_S_espi_300_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_espi_300_P_status_ENUM_IDX 1
#define DT_N_S_espi_300_P_status_ENUM_TOKEN okay
#define DT_N_S_espi_300_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_espi_300_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_espi_300, status, 0) \
	fn(DT_N_S_espi_300, status, 1) \
	fn(DT_N_S_espi_300, status, 2) \
	fn(DT_N_S_espi_300, status, 3)
#define DT_N_S_espi_300_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_espi_300, status, 0, __VA_ARGS__) \
	fn(DT_N_S_espi_300, status, 1, __VA_ARGS__) \
	fn(DT_N_S_espi_300, status, 2, __VA_ARGS__) \
	fn(DT_N_S_espi_300, status, 3, __VA_ARGS__)
#define DT_N_S_espi_300_P_status_EXISTS 1
#define DT_N_S_espi_300_P_compatible {"zephyr,espi-emul-controller"}
#define DT_N_S_espi_300_P_compatible_IDX_0 "zephyr,espi-emul-controller"
#define DT_N_S_espi_300_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_espi_300_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_espi_300, compatible, 0)
#define DT_N_S_espi_300_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_espi_300, compatible, 0, __VA_ARGS__)
#define DT_N_S_espi_300_P_compatible_LEN 1
#define DT_N_S_espi_300_P_compatible_EXISTS 1
#define DT_N_S_espi_300_P_wakeup_source 0
#define DT_N_S_espi_300_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /i2c@100
 *
 * Node identifier: DT_N_S_i2c_100
 *
 * Binding (compatible = zephyr,i2c-emul-controller):
 *   $ZEPHYR_BASE/dts/bindings/i2c/zephyr,i2c-emul-controller.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_i2c_100_PATH "/i2c@100"

/* Node's name with unit-address: */
#define DT_N_S_i2c_100_FULL_NAME "i2c@100"

/* Node parent (/) identifier: */
#define DT_N_S_i2c_100_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_i2c_100_CHILD_IDX 6
#define DT_N_S_i2c_100_FOREACH_CHILD(fn) 
#define DT_N_S_i2c_100_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_i2c_100_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_i2c_100_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_i2c_100_ORD 8

/* Ordinals for what this node depends on directly: */
#define DT_N_S_i2c_100_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_i2c_100_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_i2c_100_EXISTS 1
#define DT_N_ALIAS_i2c_0                       DT_N_S_i2c_100
#define DT_N_INST_0_zephyr_i2c_emul_controller DT_N_S_i2c_100
#define DT_N_NODELABEL_i2c0                    DT_N_S_i2c_100

/* Macros for properties that are special in the specification: */
#define DT_N_S_i2c_100_REG_NUM 1
#define DT_N_S_i2c_100_REG_IDX_0_EXISTS 1
#define DT_N_S_i2c_100_REG_IDX_0_VAL_ADDRESS 256 /* 0x100 */
#define DT_N_S_i2c_100_REG_IDX_0_VAL_SIZE 4 /* 0x4 */
#define DT_N_S_i2c_100_RANGES_NUM 0
#define DT_N_S_i2c_100_FOREACH_RANGE(fn) 
#define DT_N_S_i2c_100_IRQ_NUM 0
#define DT_N_S_i2c_100_COMPAT_MATCHES_zephyr_i2c_emul_controller 1
#define DT_N_S_i2c_100_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_i2c_100_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_i2c_100_P_reg {256 /* 0x100 */, 4 /* 0x4 */}
#define DT_N_S_i2c_100_P_reg_IDX_0 256
#define DT_N_S_i2c_100_P_reg_IDX_0_EXISTS 1
#define DT_N_S_i2c_100_P_reg_IDX_1 4
#define DT_N_S_i2c_100_P_reg_IDX_1_EXISTS 1
#define DT_N_S_i2c_100_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_i2c_100, reg, 0) \
	fn(DT_N_S_i2c_100, reg, 1)
#define DT_N_S_i2c_100_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_i2c_100, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_i2c_100, reg, 1, __VA_ARGS__)
#define DT_N_S_i2c_100_P_reg_EXISTS 1
#define DT_N_S_i2c_100_P_clock_frequency 100000
#define DT_N_S_i2c_100_P_clock_frequency_EXISTS 1
#define DT_N_S_i2c_100_P_label "I2C_0"
#define DT_N_S_i2c_100_P_label_STRING_TOKEN I2C_0
#define DT_N_S_i2c_100_P_label_STRING_UPPER_TOKEN I2C_0
#define DT_N_S_i2c_100_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_i2c_100, label, 0) \
	fn(DT_N_S_i2c_100, label, 1) \
	fn(DT_N_S_i2c_100, label, 2) \
	fn(DT_N_S_i2c_100, label, 3) \
	fn(DT_N_S_i2c_100, label, 4)
#define DT_N_S_i2c_100_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_i2c_100, label, 0, __VA_ARGS__) \
	fn(DT_N_S_i2c_100, label, 1, __VA_ARGS__) \
	fn(DT_N_S_i2c_100, label, 2, __VA_ARGS__) \
	fn(DT_N_S_i2c_100, label, 3, __VA_ARGS__) \
	fn(DT_N_S_i2c_100, label, 4, __VA_ARGS__)
#define DT_N_S_i2c_100_P_label_EXISTS 1
#define DT_N_S_i2c_100_P_status "okay"
#define DT_N_S_i2c_100_P_status_STRING_TOKEN okay
#define DT_N_S_i2c_100_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_i2c_100_P_status_ENUM_IDX 1
#define DT_N_S_i2c_100_P_status_ENUM_TOKEN okay
#define DT_N_S_i2c_100_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_i2c_100_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_i2c_100, status, 0) \
	fn(DT_N_S_i2c_100, status, 1) \
	fn(DT_N_S_i2c_100, status, 2) \
	fn(DT_N_S_i2c_100, status, 3)
#define DT_N_S_i2c_100_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_i2c_100, status, 0, __VA_ARGS__) \
	fn(DT_N_S_i2c_100, status, 1, __VA_ARGS__) \
	fn(DT_N_S_i2c_100, status, 2, __VA_ARGS__) \
	fn(DT_N_S_i2c_100, status, 3, __VA_ARGS__)
#define DT_N_S_i2c_100_P_status_EXISTS 1
#define DT_N_S_i2c_100_P_compatible {"zephyr,i2c-emul-controller"}
#define DT_N_S_i2c_100_P_compatible_IDX_0 "zephyr,i2c-emul-controller"
#define DT_N_S_i2c_100_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_i2c_100_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_i2c_100, compatible, 0)
#define DT_N_S_i2c_100_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_i2c_100, compatible, 0, __VA_ARGS__)
#define DT_N_S_i2c_100_P_compatible_LEN 1
#define DT_N_S_i2c_100_P_compatible_EXISTS 1
#define DT_N_S_i2c_100_P_wakeup_source 0
#define DT_N_S_i2c_100_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /rng
 *
 * Node identifier: DT_N_S_rng
 *
 * Binding (compatible = zephyr,native-posix-rng):
 *   $ZEPHYR_BASE/dts/bindings/rng/zephyr,native-posix-rng.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_rng_PATH "/rng"

/* Node's name with unit-address: */
#define DT_N_S_rng_FULL_NAME "rng"

/* Node parent (/) identifier: */
#define DT_N_S_rng_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_rng_CHILD_IDX 11
#define DT_N_S_rng_FOREACH_CHILD(fn) 
#define DT_N_S_rng_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_rng_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_rng_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_rng_ORD 9

/* Ordinals for what this node depends on directly: */
#define DT_N_S_rng_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_rng_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_rng_EXISTS 1
#define DT_N_INST_0_zephyr_native_posix_rng DT_N_S_rng
#define DT_N_NODELABEL_rng                  DT_N_S_rng

/* Macros for properties that are special in the specification: */
#define DT_N_S_rng_REG_NUM 0
#define DT_N_S_rng_RANGES_NUM 0
#define DT_N_S_rng_FOREACH_RANGE(fn) 
#define DT_N_S_rng_IRQ_NUM 0
#define DT_N_S_rng_COMPAT_MATCHES_zephyr_native_posix_rng 1
#define DT_N_S_rng_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_rng_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_rng_P_label "ENTROPY_0"
#define DT_N_S_rng_P_label_STRING_TOKEN ENTROPY_0
#define DT_N_S_rng_P_label_STRING_UPPER_TOKEN ENTROPY_0
#define DT_N_S_rng_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_rng, label, 0) \
	fn(DT_N_S_rng, label, 1) \
	fn(DT_N_S_rng, label, 2) \
	fn(DT_N_S_rng, label, 3) \
	fn(DT_N_S_rng, label, 4) \
	fn(DT_N_S_rng, label, 5) \
	fn(DT_N_S_rng, label, 6) \
	fn(DT_N_S_rng, label, 7) \
	fn(DT_N_S_rng, label, 8)
#define DT_N_S_rng_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_rng, label, 0, __VA_ARGS__) \
	fn(DT_N_S_rng, label, 1, __VA_ARGS__) \
	fn(DT_N_S_rng, label, 2, __VA_ARGS__) \
	fn(DT_N_S_rng, label, 3, __VA_ARGS__) \
	fn(DT_N_S_rng, label, 4, __VA_ARGS__) \
	fn(DT_N_S_rng, label, 5, __VA_ARGS__) \
	fn(DT_N_S_rng, label, 6, __VA_ARGS__) \
	fn(DT_N_S_rng, label, 7, __VA_ARGS__) \
	fn(DT_N_S_rng, label, 8, __VA_ARGS__)
#define DT_N_S_rng_P_label_EXISTS 1
#define DT_N_S_rng_P_status "okay"
#define DT_N_S_rng_P_status_STRING_TOKEN okay
#define DT_N_S_rng_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_rng_P_status_ENUM_IDX 1
#define DT_N_S_rng_P_status_ENUM_TOKEN okay
#define DT_N_S_rng_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_rng_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_rng, status, 0) \
	fn(DT_N_S_rng, status, 1) \
	fn(DT_N_S_rng, status, 2) \
	fn(DT_N_S_rng, status, 3)
#define DT_N_S_rng_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_rng, status, 0, __VA_ARGS__) \
	fn(DT_N_S_rng, status, 1, __VA_ARGS__) \
	fn(DT_N_S_rng, status, 2, __VA_ARGS__) \
	fn(DT_N_S_rng, status, 3, __VA_ARGS__)
#define DT_N_S_rng_P_status_EXISTS 1
#define DT_N_S_rng_P_compatible {"zephyr,native-posix-rng"}
#define DT_N_S_rng_P_compatible_IDX_0 "zephyr,native-posix-rng"
#define DT_N_S_rng_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_rng_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_rng, compatible, 0)
#define DT_N_S_rng_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_rng, compatible, 0, __VA_ARGS__)
#define DT_N_S_rng_P_compatible_LEN 1
#define DT_N_S_rng_P_compatible_EXISTS 1
#define DT_N_S_rng_P_wakeup_source 0
#define DT_N_S_rng_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /sdl_dc
 *
 * Node identifier: DT_N_S_sdl_dc
 *
 * Binding (compatible = zephyr,sdl-dc):
 *   $ZEPHYR_BASE/dts/bindings/display/zephyr,sdl-dc.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_sdl_dc_PATH "/sdl_dc"

/* Node's name with unit-address: */
#define DT_N_S_sdl_dc_FULL_NAME "sdl_dc"

/* Node parent (/) identifier: */
#define DT_N_S_sdl_dc_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_sdl_dc_CHILD_IDX 16
#define DT_N_S_sdl_dc_FOREACH_CHILD(fn) 
#define DT_N_S_sdl_dc_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_sdl_dc_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_sdl_dc_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_sdl_dc_ORD 10

/* Ordinals for what this node depends on directly: */
#define DT_N_S_sdl_dc_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_sdl_dc_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_sdl_dc_EXISTS 1
#define DT_N_INST_0_zephyr_sdl_dc DT_N_S_sdl_dc
#define DT_N_NODELABEL_sdl_dc     DT_N_S_sdl_dc

/* Macros for properties that are special in the specification: */
#define DT_N_S_sdl_dc_REG_NUM 0
#define DT_N_S_sdl_dc_RANGES_NUM 0
#define DT_N_S_sdl_dc_FOREACH_RANGE(fn) 
#define DT_N_S_sdl_dc_IRQ_NUM 0
#define DT_N_S_sdl_dc_COMPAT_MATCHES_zephyr_sdl_dc 1
#define DT_N_S_sdl_dc_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_sdl_dc_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_sdl_dc_P_height 240
#define DT_N_S_sdl_dc_P_height_EXISTS 1
#define DT_N_S_sdl_dc_P_width 320
#define DT_N_S_sdl_dc_P_width_EXISTS 1
#define DT_N_S_sdl_dc_P_label "SDL display controller"
#define DT_N_S_sdl_dc_P_label_STRING_TOKEN SDL_display_controller
#define DT_N_S_sdl_dc_P_label_STRING_UPPER_TOKEN SDL_DISPLAY_CONTROLLER
#define DT_N_S_sdl_dc_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sdl_dc, label, 0) \
	fn(DT_N_S_sdl_dc, label, 1) \
	fn(DT_N_S_sdl_dc, label, 2) \
	fn(DT_N_S_sdl_dc, label, 3) \
	fn(DT_N_S_sdl_dc, label, 4) \
	fn(DT_N_S_sdl_dc, label, 5) \
	fn(DT_N_S_sdl_dc, label, 6) \
	fn(DT_N_S_sdl_dc, label, 7) \
	fn(DT_N_S_sdl_dc, label, 8) \
	fn(DT_N_S_sdl_dc, label, 9) \
	fn(DT_N_S_sdl_dc, label, 10) \
	fn(DT_N_S_sdl_dc, label, 11) \
	fn(DT_N_S_sdl_dc, label, 12) \
	fn(DT_N_S_sdl_dc, label, 13) \
	fn(DT_N_S_sdl_dc, label, 14) \
	fn(DT_N_S_sdl_dc, label, 15) \
	fn(DT_N_S_sdl_dc, label, 16) \
	fn(DT_N_S_sdl_dc, label, 17) \
	fn(DT_N_S_sdl_dc, label, 18) \
	fn(DT_N_S_sdl_dc, label, 19) \
	fn(DT_N_S_sdl_dc, label, 20) \
	fn(DT_N_S_sdl_dc, label, 21)
#define DT_N_S_sdl_dc_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sdl_dc, label, 0, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 1, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 2, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 3, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 4, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 5, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 6, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 7, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 8, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 9, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 10, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 11, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 12, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 13, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 14, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 15, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 16, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 17, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 18, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 19, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 20, __VA_ARGS__) \
	fn(DT_N_S_sdl_dc, label, 21, __VA_ARGS__)
#define DT_N_S_sdl_dc_P_label_EXISTS 1
#define DT_N_S_sdl_dc_P_compatible {"zephyr,sdl-dc"}
#define DT_N_S_sdl_dc_P_compatible_IDX_0 "zephyr,sdl-dc"
#define DT_N_S_sdl_dc_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_sdl_dc_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_sdl_dc, compatible, 0)
#define DT_N_S_sdl_dc_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_sdl_dc, compatible, 0, __VA_ARGS__)
#define DT_N_S_sdl_dc_P_compatible_LEN 1
#define DT_N_S_sdl_dc_P_compatible_EXISTS 1
#define DT_N_S_sdl_dc_P_wakeup_source 0
#define DT_N_S_sdl_dc_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /spi@200
 *
 * Node identifier: DT_N_S_spi_200
 *
 * Binding (compatible = zephyr,spi-emul-controller):
 *   $ZEPHYR_BASE/dts/bindings/spi/zephyr,spi-emul-controller.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_spi_200_PATH "/spi@200"

/* Node's name with unit-address: */
#define DT_N_S_spi_200_FULL_NAME "spi@200"

/* Node parent (/) identifier: */
#define DT_N_S_spi_200_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_spi_200_CHILD_IDX 7
#define DT_N_S_spi_200_FOREACH_CHILD(fn) 
#define DT_N_S_spi_200_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_spi_200_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_spi_200_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_spi_200_ORD 11

/* Ordinals for what this node depends on directly: */
#define DT_N_S_spi_200_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_spi_200_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_spi_200_EXISTS 1
#define DT_N_ALIAS_spi_0                       DT_N_S_spi_200
#define DT_N_INST_0_zephyr_spi_emul_controller DT_N_S_spi_200
#define DT_N_NODELABEL_spi0                    DT_N_S_spi_200

/* Macros for properties that are special in the specification: */
#define DT_N_S_spi_200_REG_NUM 1
#define DT_N_S_spi_200_REG_IDX_0_EXISTS 1
#define DT_N_S_spi_200_REG_IDX_0_VAL_ADDRESS 512 /* 0x200 */
#define DT_N_S_spi_200_REG_IDX_0_VAL_SIZE 4 /* 0x4 */
#define DT_N_S_spi_200_RANGES_NUM 0
#define DT_N_S_spi_200_FOREACH_RANGE(fn) 
#define DT_N_S_spi_200_IRQ_NUM 0
#define DT_N_S_spi_200_COMPAT_MATCHES_zephyr_spi_emul_controller 1
#define DT_N_S_spi_200_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_spi_200_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_spi_200_P_reg {512 /* 0x200 */, 4 /* 0x4 */}
#define DT_N_S_spi_200_P_reg_IDX_0 512
#define DT_N_S_spi_200_P_reg_IDX_0_EXISTS 1
#define DT_N_S_spi_200_P_reg_IDX_1 4
#define DT_N_S_spi_200_P_reg_IDX_1_EXISTS 1
#define DT_N_S_spi_200_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_spi_200, reg, 0) \
	fn(DT_N_S_spi_200, reg, 1)
#define DT_N_S_spi_200_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_spi_200, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_spi_200, reg, 1, __VA_ARGS__)
#define DT_N_S_spi_200_P_reg_EXISTS 1
#define DT_N_S_spi_200_P_clock_frequency 50000000
#define DT_N_S_spi_200_P_clock_frequency_EXISTS 1
#define DT_N_S_spi_200_P_label "SPI_0"
#define DT_N_S_spi_200_P_label_STRING_TOKEN SPI_0
#define DT_N_S_spi_200_P_label_STRING_UPPER_TOKEN SPI_0
#define DT_N_S_spi_200_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_spi_200, label, 0) \
	fn(DT_N_S_spi_200, label, 1) \
	fn(DT_N_S_spi_200, label, 2) \
	fn(DT_N_S_spi_200, label, 3) \
	fn(DT_N_S_spi_200, label, 4)
#define DT_N_S_spi_200_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_spi_200, label, 0, __VA_ARGS__) \
	fn(DT_N_S_spi_200, label, 1, __VA_ARGS__) \
	fn(DT_N_S_spi_200, label, 2, __VA_ARGS__) \
	fn(DT_N_S_spi_200, label, 3, __VA_ARGS__) \
	fn(DT_N_S_spi_200, label, 4, __VA_ARGS__)
#define DT_N_S_spi_200_P_label_EXISTS 1
#define DT_N_S_spi_200_P_status "okay"
#define DT_N_S_spi_200_P_status_STRING_TOKEN okay
#define DT_N_S_spi_200_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_spi_200_P_status_ENUM_IDX 1
#define DT_N_S_spi_200_P_status_ENUM_TOKEN okay
#define DT_N_S_spi_200_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_spi_200_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_spi_200, status, 0) \
	fn(DT_N_S_spi_200, status, 1) \
	fn(DT_N_S_spi_200, status, 2) \
	fn(DT_N_S_spi_200, status, 3)
#define DT_N_S_spi_200_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_spi_200, status, 0, __VA_ARGS__) \
	fn(DT_N_S_spi_200, status, 1, __VA_ARGS__) \
	fn(DT_N_S_spi_200, status, 2, __VA_ARGS__) \
	fn(DT_N_S_spi_200, status, 3, __VA_ARGS__)
#define DT_N_S_spi_200_P_status_EXISTS 1
#define DT_N_S_spi_200_P_compatible {"zephyr,spi-emul-controller"}
#define DT_N_S_spi_200_P_compatible_IDX_0 "zephyr,spi-emul-controller"
#define DT_N_S_spi_200_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_spi_200_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_spi_200, compatible, 0)
#define DT_N_S_spi_200_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_spi_200, compatible, 0, __VA_ARGS__)
#define DT_N_S_spi_200_P_compatible_LEN 1
#define DT_N_S_spi_200_P_compatible_EXISTS 1
#define DT_N_S_spi_200_P_wakeup_source 0
#define DT_N_S_spi_200_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /uart
 *
 * Node identifier: DT_N_S_uart
 *
 * Binding (compatible = zephyr,native-posix-uart):
 *   $ZEPHYR_BASE/dts/bindings/serial/zephyr,native-posix-uart.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_uart_PATH "/uart"

/* Node's name with unit-address: */
#define DT_N_S_uart_FULL_NAME "uart"

/* Node parent (/) identifier: */
#define DT_N_S_uart_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_uart_CHILD_IDX 9
#define DT_N_S_uart_FOREACH_CHILD(fn) 
#define DT_N_S_uart_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_uart_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_uart_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_uart_ORD 12

/* Ordinals for what this node depends on directly: */
#define DT_N_S_uart_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_uart_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_uart_EXISTS 1
#define DT_N_INST_0_zephyr_native_posix_uart DT_N_S_uart
#define DT_N_NODELABEL_uart0                 DT_N_S_uart

/* Macros for properties that are special in the specification: */
#define DT_N_S_uart_REG_NUM 0
#define DT_N_S_uart_RANGES_NUM 0
#define DT_N_S_uart_FOREACH_RANGE(fn) 
#define DT_N_S_uart_IRQ_NUM 0
#define DT_N_S_uart_COMPAT_MATCHES_zephyr_native_posix_uart 1
#define DT_N_S_uart_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_uart_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_uart_P_current_speed 0
#define DT_N_S_uart_P_current_speed_EXISTS 1
#define DT_N_S_uart_P_label "UART_0"
#define DT_N_S_uart_P_label_STRING_TOKEN UART_0
#define DT_N_S_uart_P_label_STRING_UPPER_TOKEN UART_0
#define DT_N_S_uart_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_uart, label, 0) \
	fn(DT_N_S_uart, label, 1) \
	fn(DT_N_S_uart, label, 2) \
	fn(DT_N_S_uart, label, 3) \
	fn(DT_N_S_uart, label, 4) \
	fn(DT_N_S_uart, label, 5)
#define DT_N_S_uart_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_uart, label, 0, __VA_ARGS__) \
	fn(DT_N_S_uart, label, 1, __VA_ARGS__) \
	fn(DT_N_S_uart, label, 2, __VA_ARGS__) \
	fn(DT_N_S_uart, label, 3, __VA_ARGS__) \
	fn(DT_N_S_uart, label, 4, __VA_ARGS__) \
	fn(DT_N_S_uart, label, 5, __VA_ARGS__)
#define DT_N_S_uart_P_label_EXISTS 1
#define DT_N_S_uart_P_hw_flow_control 0
#define DT_N_S_uart_P_hw_flow_control_EXISTS 1
#define DT_N_S_uart_P_status "okay"
#define DT_N_S_uart_P_status_STRING_TOKEN okay
#define DT_N_S_uart_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_uart_P_status_ENUM_IDX 1
#define DT_N_S_uart_P_status_ENUM_TOKEN okay
#define DT_N_S_uart_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_uart_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_uart, status, 0) \
	fn(DT_N_S_uart, status, 1) \
	fn(DT_N_S_uart, status, 2) \
	fn(DT_N_S_uart, status, 3)
#define DT_N_S_uart_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_uart, status, 0, __VA_ARGS__) \
	fn(DT_N_S_uart, status, 1, __VA_ARGS__) \
	fn(DT_N_S_uart, status, 2, __VA_ARGS__) \
	fn(DT_N_S_uart, status, 3, __VA_ARGS__)
#define DT_N_S_uart_P_status_EXISTS 1
#define DT_N_S_uart_P_compatible {"zephyr,native-posix-uart"}
#define DT_N_S_uart_P_compatible_IDX_0 "zephyr,native-posix-uart"
#define DT_N_S_uart_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_uart_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_uart, compatible, 0)
#define DT_N_S_uart_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_uart, compatible, 0, __VA_ARGS__)
#define DT_N_S_uart_P_compatible_LEN 1
#define DT_N_S_uart_P_compatible_EXISTS 1
#define DT_N_S_uart_P_wakeup_source 0
#define DT_N_S_uart_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /uart_1
 *
 * Node identifier: DT_N_S_uart_1
 *
 * Binding (compatible = zephyr,native-posix-uart):
 *   $ZEPHYR_BASE/dts/bindings/serial/zephyr,native-posix-uart.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_uart_1_PATH "/uart_1"

/* Node's name with unit-address: */
#define DT_N_S_uart_1_FULL_NAME "uart_1"

/* Node parent (/) identifier: */
#define DT_N_S_uart_1_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_uart_1_CHILD_IDX 10
#define DT_N_S_uart_1_FOREACH_CHILD(fn) 
#define DT_N_S_uart_1_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_uart_1_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_uart_1_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_uart_1_ORD 13

/* Ordinals for what this node depends on directly: */
#define DT_N_S_uart_1_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_uart_1_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_uart_1_EXISTS 1
#define DT_N_INST_1_zephyr_native_posix_uart DT_N_S_uart_1
#define DT_N_NODELABEL_uart1                 DT_N_S_uart_1

/* Macros for properties that are special in the specification: */
#define DT_N_S_uart_1_REG_NUM 0
#define DT_N_S_uart_1_RANGES_NUM 0
#define DT_N_S_uart_1_FOREACH_RANGE(fn) 
#define DT_N_S_uart_1_IRQ_NUM 0
#define DT_N_S_uart_1_COMPAT_MATCHES_zephyr_native_posix_uart 1
#define DT_N_S_uart_1_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_uart_1_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_uart_1_P_current_speed 0
#define DT_N_S_uart_1_P_current_speed_EXISTS 1
#define DT_N_S_uart_1_P_label "UART_1"
#define DT_N_S_uart_1_P_label_STRING_TOKEN UART_1
#define DT_N_S_uart_1_P_label_STRING_UPPER_TOKEN UART_1
#define DT_N_S_uart_1_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_uart_1, label, 0) \
	fn(DT_N_S_uart_1, label, 1) \
	fn(DT_N_S_uart_1, label, 2) \
	fn(DT_N_S_uart_1, label, 3) \
	fn(DT_N_S_uart_1, label, 4) \
	fn(DT_N_S_uart_1, label, 5)
#define DT_N_S_uart_1_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_uart_1, label, 0, __VA_ARGS__) \
	fn(DT_N_S_uart_1, label, 1, __VA_ARGS__) \
	fn(DT_N_S_uart_1, label, 2, __VA_ARGS__) \
	fn(DT_N_S_uart_1, label, 3, __VA_ARGS__) \
	fn(DT_N_S_uart_1, label, 4, __VA_ARGS__) \
	fn(DT_N_S_uart_1, label, 5, __VA_ARGS__)
#define DT_N_S_uart_1_P_label_EXISTS 1
#define DT_N_S_uart_1_P_hw_flow_control 0
#define DT_N_S_uart_1_P_hw_flow_control_EXISTS 1
#define DT_N_S_uart_1_P_status "okay"
#define DT_N_S_uart_1_P_status_STRING_TOKEN okay
#define DT_N_S_uart_1_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_uart_1_P_status_ENUM_IDX 1
#define DT_N_S_uart_1_P_status_ENUM_TOKEN okay
#define DT_N_S_uart_1_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_uart_1_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_uart_1, status, 0) \
	fn(DT_N_S_uart_1, status, 1) \
	fn(DT_N_S_uart_1, status, 2) \
	fn(DT_N_S_uart_1, status, 3)
#define DT_N_S_uart_1_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_uart_1, status, 0, __VA_ARGS__) \
	fn(DT_N_S_uart_1, status, 1, __VA_ARGS__) \
	fn(DT_N_S_uart_1, status, 2, __VA_ARGS__) \
	fn(DT_N_S_uart_1, status, 3, __VA_ARGS__)
#define DT_N_S_uart_1_P_status_EXISTS 1
#define DT_N_S_uart_1_P_compatible {"zephyr,native-posix-uart"}
#define DT_N_S_uart_1_P_compatible_IDX_0 "zephyr,native-posix-uart"
#define DT_N_S_uart_1_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_uart_1_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_uart_1, compatible, 0)
#define DT_N_S_uart_1_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_uart_1, compatible, 0, __VA_ARGS__)
#define DT_N_S_uart_1_P_compatible_LEN 1
#define DT_N_S_uart_1_P_compatible_EXISTS 1
#define DT_N_S_uart_1_P_wakeup_source 0
#define DT_N_S_uart_1_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /udc0
 *
 * Node identifier: DT_N_S_udc0
 *
 * Binding (compatible = zephyr,native-posix-udc):
 *   $ZEPHYR_BASE/dts/bindings/usb/zephyr,native-posix-udc.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_udc0_PATH "/udc0"

/* Node's name with unit-address: */
#define DT_N_S_udc0_FULL_NAME "udc0"

/* Node parent (/) identifier: */
#define DT_N_S_udc0_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_udc0_CHILD_IDX 15
#define DT_N_S_udc0_FOREACH_CHILD(fn) 
#define DT_N_S_udc0_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_udc0_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_udc0_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_udc0_ORD 14

/* Ordinals for what this node depends on directly: */
#define DT_N_S_udc0_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_udc0_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_udc0_EXISTS 1
#define DT_N_INST_0_zephyr_native_posix_udc DT_N_S_udc0
#define DT_N_NODELABEL_zephyr_udc0          DT_N_S_udc0

/* Macros for properties that are special in the specification: */
#define DT_N_S_udc0_REG_NUM 0
#define DT_N_S_udc0_RANGES_NUM 0
#define DT_N_S_udc0_FOREACH_RANGE(fn) 
#define DT_N_S_udc0_IRQ_NUM 0
#define DT_N_S_udc0_COMPAT_MATCHES_zephyr_native_posix_udc 1
#define DT_N_S_udc0_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_udc0_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_udc0_P_label "USBD"
#define DT_N_S_udc0_P_label_STRING_TOKEN USBD
#define DT_N_S_udc0_P_label_STRING_UPPER_TOKEN USBD
#define DT_N_S_udc0_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_udc0, label, 0) \
	fn(DT_N_S_udc0, label, 1) \
	fn(DT_N_S_udc0, label, 2) \
	fn(DT_N_S_udc0, label, 3)
#define DT_N_S_udc0_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_udc0, label, 0, __VA_ARGS__) \
	fn(DT_N_S_udc0, label, 1, __VA_ARGS__) \
	fn(DT_N_S_udc0, label, 2, __VA_ARGS__) \
	fn(DT_N_S_udc0, label, 3, __VA_ARGS__)
#define DT_N_S_udc0_P_label_EXISTS 1
#define DT_N_S_udc0_P_compatible {"zephyr,native-posix-udc"}
#define DT_N_S_udc0_P_compatible_IDX_0 "zephyr,native-posix-udc"
#define DT_N_S_udc0_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_udc0_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_udc0, compatible, 0)
#define DT_N_S_udc0_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_udc0, compatible, 0, __VA_ARGS__)
#define DT_N_S_udc0_P_compatible_LEN 1
#define DT_N_S_udc0_P_compatible_EXISTS 1
#define DT_N_S_udc0_P_wakeup_source 0
#define DT_N_S_udc0_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /cpus
 *
 * Node identifier: DT_N_S_cpus
 */

/* Node's full path: */
#define DT_N_S_cpus_PATH "/cpus"

/* Node's name with unit-address: */
#define DT_N_S_cpus_FULL_NAME "cpus"

/* Node parent (/) identifier: */
#define DT_N_S_cpus_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_cpus_CHILD_IDX 3
#define DT_N_S_cpus_FOREACH_CHILD(fn) fn(DT_N_S_cpus_S_cpu_0)
#define DT_N_S_cpus_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_cpus_S_cpu_0, __VA_ARGS__)
#define DT_N_S_cpus_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_cpus_S_cpu_0) 
#define DT_N_S_cpus_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_cpus_S_cpu_0, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_S_cpus_ORD 15

/* Ordinals for what this node depends on directly: */
#define DT_N_S_cpus_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_cpus_SUPPORTS_ORDS \
	16, /* /cpus/cpu@0 */

/* Existence and alternate IDs: */
#define DT_N_S_cpus_EXISTS 1

/* Macros for properties that are special in the specification: */
#define DT_N_S_cpus_REG_NUM 0
#define DT_N_S_cpus_RANGES_NUM 0
#define DT_N_S_cpus_FOREACH_RANGE(fn) 
#define DT_N_S_cpus_IRQ_NUM 0
#define DT_N_S_cpus_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_cpus_PINCTRL_NUM 0

/* (No generic property macros) */

/*
 * Devicetree node: /cpus/cpu@0
 *
 * Node identifier: DT_N_S_cpus_S_cpu_0
 *
 * Binding (compatible = zephyr,native-posix-cpu):
 *   $ZEPHYR_BASE/dts/bindings/cpu/zephyr,native-posix-cpu.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_cpus_S_cpu_0_PATH "/cpus/cpu@0"

/* Node's name with unit-address: */
#define DT_N_S_cpus_S_cpu_0_FULL_NAME "cpu@0"

/* Node parent (/cpus) identifier: */
#define DT_N_S_cpus_S_cpu_0_PARENT DT_N_S_cpus

/* Node's index in its parent's list of children: */
#define DT_N_S_cpus_S_cpu_0_CHILD_IDX 0
#define DT_N_S_cpus_S_cpu_0_FOREACH_CHILD(fn) 
#define DT_N_S_cpus_S_cpu_0_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_cpus_S_cpu_0_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_cpus_S_cpu_0_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_cpus_S_cpu_0_ORD 16

/* Ordinals for what this node depends on directly: */
#define DT_N_S_cpus_S_cpu_0_REQUIRES_ORDS \
	15, /* /cpus */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_cpus_S_cpu_0_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_cpus_S_cpu_0_EXISTS 1
#define DT_N_INST_0_zephyr_native_posix_cpu DT_N_S_cpus_S_cpu_0
#define DT_N_NODELABEL_cpu0                 DT_N_S_cpus_S_cpu_0

/* Macros for properties that are special in the specification: */
#define DT_N_S_cpus_S_cpu_0_REG_NUM 1
#define DT_N_S_cpus_S_cpu_0_REG_IDX_0_EXISTS 1
#define DT_N_S_cpus_S_cpu_0_REG_IDX_0_VAL_ADDRESS 0 /* 0x0 */
#define DT_N_S_cpus_S_cpu_0_RANGES_NUM 0
#define DT_N_S_cpus_S_cpu_0_FOREACH_RANGE(fn) 
#define DT_N_S_cpus_S_cpu_0_IRQ_NUM 0
#define DT_N_S_cpus_S_cpu_0_COMPAT_MATCHES_zephyr_native_posix_cpu 1
#define DT_N_S_cpus_S_cpu_0_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_cpus_S_cpu_0_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_cpus_S_cpu_0_P_compatible {"zephyr,native-posix-cpu"}
#define DT_N_S_cpus_S_cpu_0_P_compatible_IDX_0 "zephyr,native-posix-cpu"
#define DT_N_S_cpus_S_cpu_0_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_cpus_S_cpu_0_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_cpus_S_cpu_0, compatible, 0)
#define DT_N_S_cpus_S_cpu_0_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_cpus_S_cpu_0, compatible, 0, __VA_ARGS__)
#define DT_N_S_cpus_S_cpu_0_P_compatible_LEN 1
#define DT_N_S_cpus_S_cpu_0_P_compatible_EXISTS 1
#define DT_N_S_cpus_S_cpu_0_P_reg {0 /* 0x0 */}
#define DT_N_S_cpus_S_cpu_0_P_reg_IDX_0 0
#define DT_N_S_cpus_S_cpu_0_P_reg_IDX_0_EXISTS 1
#define DT_N_S_cpus_S_cpu_0_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_cpus_S_cpu_0, reg, 0)
#define DT_N_S_cpus_S_cpu_0_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_cpus_S_cpu_0, reg, 0, __VA_ARGS__)
#define DT_N_S_cpus_S_cpu_0_P_reg_EXISTS 1
#define DT_N_S_cpus_S_cpu_0_P_wakeup_source 0
#define DT_N_S_cpus_S_cpu_0_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /flash-controller@0
 *
 * Node identifier: DT_N_S_flash_controller_0
 *
 * Binding (compatible = zephyr,sim-flash):
 *   $ZEPHYR_BASE/dts/bindings/flash_controller/zephyr,sim-flash.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_flash_controller_0_PATH "/flash-controller@0"

/* Node's name with unit-address: */
#define DT_N_S_flash_controller_0_FULL_NAME "flash-controller@0"

/* Node parent (/) identifier: */
#define DT_N_S_flash_controller_0_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_flash_controller_0_CHILD_IDX 4
#define DT_N_S_flash_controller_0_FOREACH_CHILD(fn) fn(DT_N_S_flash_controller_0_S_flash_0)
#define DT_N_S_flash_controller_0_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0, __VA_ARGS__)
#define DT_N_S_flash_controller_0_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_flash_controller_0_S_flash_0) 
#define DT_N_S_flash_controller_0_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_S_flash_controller_0_ORD 17

/* Ordinals for what this node depends on directly: */
#define DT_N_S_flash_controller_0_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_flash_controller_0_SUPPORTS_ORDS \
	18, /* /flash-controller@0/flash@0 */

/* Existence and alternate IDs: */
#define DT_N_S_flash_controller_0_EXISTS 1
#define DT_N_INST_0_zephyr_sim_flash    DT_N_S_flash_controller_0
#define DT_N_NODELABEL_flashcontroller0 DT_N_S_flash_controller_0

/* Macros for properties that are special in the specification: */
#define DT_N_S_flash_controller_0_REG_NUM 1
#define DT_N_S_flash_controller_0_REG_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_REG_IDX_0_VAL_ADDRESS 0 /* 0x0 */
#define DT_N_S_flash_controller_0_REG_IDX_0_VAL_SIZE 2097152 /* 0x200000 */
#define DT_N_S_flash_controller_0_RANGES_NUM 0
#define DT_N_S_flash_controller_0_FOREACH_RANGE(fn) 
#define DT_N_S_flash_controller_0_IRQ_NUM 0
#define DT_N_S_flash_controller_0_COMPAT_MATCHES_zephyr_sim_flash 1
#define DT_N_S_flash_controller_0_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_flash_controller_0_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_flash_controller_0_P_label "flash_ctrl"
#define DT_N_S_flash_controller_0_P_label_STRING_TOKEN flash_ctrl
#define DT_N_S_flash_controller_0_P_label_STRING_UPPER_TOKEN FLASH_CTRL
#define DT_N_S_flash_controller_0_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0, label, 0) \
	fn(DT_N_S_flash_controller_0, label, 1) \
	fn(DT_N_S_flash_controller_0, label, 2) \
	fn(DT_N_S_flash_controller_0, label, 3) \
	fn(DT_N_S_flash_controller_0, label, 4) \
	fn(DT_N_S_flash_controller_0, label, 5) \
	fn(DT_N_S_flash_controller_0, label, 6) \
	fn(DT_N_S_flash_controller_0, label, 7) \
	fn(DT_N_S_flash_controller_0, label, 8) \
	fn(DT_N_S_flash_controller_0, label, 9)
#define DT_N_S_flash_controller_0_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0, label, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0, label, 1, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0, label, 2, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0, label, 3, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0, label, 4, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0, label, 5, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0, label, 6, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0, label, 7, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0, label, 8, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0, label, 9, __VA_ARGS__)
#define DT_N_S_flash_controller_0_P_label_EXISTS 1
#define DT_N_S_flash_controller_0_P_erase_value 255
#define DT_N_S_flash_controller_0_P_erase_value_EXISTS 1
#define DT_N_S_flash_controller_0_P_compatible {"zephyr,sim-flash"}
#define DT_N_S_flash_controller_0_P_compatible_IDX_0 "zephyr,sim-flash"
#define DT_N_S_flash_controller_0_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0, compatible, 0)
#define DT_N_S_flash_controller_0_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0, compatible, 0, __VA_ARGS__)
#define DT_N_S_flash_controller_0_P_compatible_LEN 1
#define DT_N_S_flash_controller_0_P_compatible_EXISTS 1
#define DT_N_S_flash_controller_0_P_reg {0 /* 0x0 */, 2097152 /* 0x200000 */}
#define DT_N_S_flash_controller_0_P_reg_IDX_0 0
#define DT_N_S_flash_controller_0_P_reg_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_P_reg_IDX_1 2097152
#define DT_N_S_flash_controller_0_P_reg_IDX_1_EXISTS 1
#define DT_N_S_flash_controller_0_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0, reg, 0) \
	fn(DT_N_S_flash_controller_0, reg, 1)
#define DT_N_S_flash_controller_0_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0, reg, 1, __VA_ARGS__)
#define DT_N_S_flash_controller_0_P_reg_EXISTS 1
#define DT_N_S_flash_controller_0_P_wakeup_source 0
#define DT_N_S_flash_controller_0_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /flash-controller@0/flash@0
 *
 * Node identifier: DT_N_S_flash_controller_0_S_flash_0
 *
 * Binding (compatible = soc-nv-flash):
 *   $ZEPHYR_BASE/dts/bindings/mtd/soc-nv-flash.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_flash_controller_0_S_flash_0_PATH "/flash-controller@0/flash@0"

/* Node's name with unit-address: */
#define DT_N_S_flash_controller_0_S_flash_0_FULL_NAME "flash@0"

/* Node parent (/flash-controller@0) identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_PARENT DT_N_S_flash_controller_0

/* Node's index in its parent's list of children: */
#define DT_N_S_flash_controller_0_S_flash_0_CHILD_IDX 0
#define DT_N_S_flash_controller_0_S_flash_0_FOREACH_CHILD(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions)
#define DT_N_S_flash_controller_0_S_flash_0_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions) 
#define DT_N_S_flash_controller_0_S_flash_0_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_S_flash_controller_0_S_flash_0_ORD 18

/* Ordinals for what this node depends on directly: */
#define DT_N_S_flash_controller_0_S_flash_0_REQUIRES_ORDS \
	17, /* /flash-controller@0 */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_flash_controller_0_S_flash_0_SUPPORTS_ORDS \
	19, /* /flash-controller@0/flash@0/partitions */

/* Existence and alternate IDs: */
#define DT_N_S_flash_controller_0_S_flash_0_EXISTS 1
#define DT_N_INST_0_soc_nv_flash DT_N_S_flash_controller_0_S_flash_0
#define DT_N_NODELABEL_flash0    DT_N_S_flash_controller_0_S_flash_0

/* Macros for properties that are special in the specification: */
#define DT_N_S_flash_controller_0_S_flash_0_REG_NUM 1
#define DT_N_S_flash_controller_0_S_flash_0_REG_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_REG_IDX_0_VAL_ADDRESS 0 /* 0x0 */
#define DT_N_S_flash_controller_0_S_flash_0_REG_IDX_0_VAL_SIZE 2097152 /* 0x200000 */
#define DT_N_S_flash_controller_0_S_flash_0_RANGES_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_FOREACH_RANGE(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_IRQ_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_COMPAT_MATCHES_soc_nv_flash 1
#define DT_N_S_flash_controller_0_S_flash_0_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_flash_controller_0_S_flash_0_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_flash_controller_0_S_flash_0_P_label "flash"
#define DT_N_S_flash_controller_0_S_flash_0_P_label_STRING_TOKEN flash
#define DT_N_S_flash_controller_0_S_flash_0_P_label_STRING_UPPER_TOKEN FLASH
#define DT_N_S_flash_controller_0_S_flash_0_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0, label, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0, label, 1) \
	fn(DT_N_S_flash_controller_0_S_flash_0, label, 2) \
	fn(DT_N_S_flash_controller_0_S_flash_0, label, 3) \
	fn(DT_N_S_flash_controller_0_S_flash_0, label, 4)
#define DT_N_S_flash_controller_0_S_flash_0_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0, label, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0, label, 1, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0, label, 2, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0, label, 3, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0, label, 4, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_P_label_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_P_erase_block_size 4096
#define DT_N_S_flash_controller_0_S_flash_0_P_erase_block_size_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_P_write_block_size 1
#define DT_N_S_flash_controller_0_S_flash_0_P_write_block_size_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_P_status "okay"
#define DT_N_S_flash_controller_0_S_flash_0_P_status_STRING_TOKEN okay
#define DT_N_S_flash_controller_0_S_flash_0_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_flash_controller_0_S_flash_0_P_status_ENUM_IDX 1
#define DT_N_S_flash_controller_0_S_flash_0_P_status_ENUM_TOKEN okay
#define DT_N_S_flash_controller_0_S_flash_0_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_flash_controller_0_S_flash_0_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0, status, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0, status, 1) \
	fn(DT_N_S_flash_controller_0_S_flash_0, status, 2) \
	fn(DT_N_S_flash_controller_0_S_flash_0, status, 3)
#define DT_N_S_flash_controller_0_S_flash_0_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0, status, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0, status, 1, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0, status, 2, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0, status, 3, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_P_status_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_P_compatible {"soc-nv-flash"}
#define DT_N_S_flash_controller_0_S_flash_0_P_compatible_IDX_0 "soc-nv-flash"
#define DT_N_S_flash_controller_0_S_flash_0_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0, compatible, 0)
#define DT_N_S_flash_controller_0_S_flash_0_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0, compatible, 0, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_P_compatible_LEN 1
#define DT_N_S_flash_controller_0_S_flash_0_P_compatible_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_P_reg {0 /* 0x0 */, 2097152 /* 0x200000 */}
#define DT_N_S_flash_controller_0_S_flash_0_P_reg_IDX_0 0
#define DT_N_S_flash_controller_0_S_flash_0_P_reg_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_P_reg_IDX_1 2097152
#define DT_N_S_flash_controller_0_S_flash_0_P_reg_IDX_1_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0, reg, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0, reg, 1)
#define DT_N_S_flash_controller_0_S_flash_0_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0, reg, 1, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_P_reg_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_P_wakeup_source 0
#define DT_N_S_flash_controller_0_S_flash_0_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /flash-controller@0/flash@0/partitions
 *
 * Node identifier: DT_N_S_flash_controller_0_S_flash_0_S_partitions
 *
 * Binding (compatible = fixed-partitions):
 *   $ZEPHYR_BASE/dts/bindings/mtd/fixed-partitions.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_PATH "/flash-controller@0/flash@0/partitions"

/* Node's name with unit-address: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_FULL_NAME "partitions"

/* Node parent (/flash-controller@0/flash@0) identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_PARENT DT_N_S_flash_controller_0_S_flash_0

/* Node's index in its parent's list of children: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_CHILD_IDX 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_FOREACH_CHILD(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, __VA_ARGS__) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, __VA_ARGS__) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, __VA_ARGS__) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, __VA_ARGS__) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, __VA_ARGS__) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, __VA_ARGS__) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, __VA_ARGS__) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, __VA_ARGS__) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_ORD 19

/* Ordinals for what this node depends on directly: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_REQUIRES_ORDS \
	18, /* /flash-controller@0/flash@0 */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_SUPPORTS_ORDS \
	20, /* /flash-controller@0/flash@0/partitions/partition@0 */ \
	21, /* /flash-controller@0/flash@0/partitions/partition@c000 */ \
	22, /* /flash-controller@0/flash@0/partitions/partition@75000 */ \
	23, /* /flash-controller@0/flash@0/partitions/partition@de000 */ \
	24, /* /flash-controller@0/flash@0/partitions/partition@fc000 */

/* Existence and alternate IDs: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_EXISTS 1
#define DT_N_INST_0_fixed_partitions DT_N_S_flash_controller_0_S_flash_0_S_partitions

/* Macros for properties that are special in the specification: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_REG_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_RANGES_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_FOREACH_RANGE(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_IRQ_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_COMPAT_MATCHES_fixed_partitions 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_PINCTRL_NUM 0

/* (No generic property macros) */

/*
 * Devicetree node: /flash-controller@0/flash@0/partitions/partition@0
 *
 * Node identifier: DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_PATH "/flash-controller@0/flash@0/partitions/partition@0"

/* Node's name with unit-address: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_FULL_NAME "partition@0"

/* Node parent (/flash-controller@0/flash@0/partitions) identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_PARENT DT_N_S_flash_controller_0_S_flash_0_S_partitions

/* Node's index in its parent's list of children: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_CHILD_IDX 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_FOREACH_CHILD(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_ORD 20

/* Ordinals for what this node depends on directly: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_REQUIRES_ORDS \
	19, /* /flash-controller@0/flash@0/partitions */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_EXISTS 1
#define DT_N_NODELABEL_boot_partition DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0

/* Macros for properties that are special in the specification: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_REG_NUM 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_REG_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_REG_IDX_0_VAL_ADDRESS 0 /* 0x0 */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_REG_IDX_0_VAL_SIZE 49152 /* 0xc000 */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_RANGES_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_FOREACH_RANGE(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_IRQ_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_PINCTRL_NUM 0

/* fixed-partitions identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_PARTITION_ID 0

/* Generic property macros: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_label "mcuboot"
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_label_STRING_TOKEN mcuboot
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_label_STRING_UPPER_TOKEN MCUBOOT
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 1) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 2) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 3) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 4) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 5) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 6)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 1, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 2, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 3, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 4, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 5, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, label, 6, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_label_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_read_only 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_read_only_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_reg {0 /* 0x0 */, 49152 /* 0xc000 */}
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_reg_IDX_0 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_reg_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_reg_IDX_1 49152
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_reg_IDX_1_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, reg, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, reg, 1)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0, reg, 1, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0_P_reg_EXISTS 1

/*
 * Devicetree node: /flash-controller@0/flash@0/partitions/partition@c000
 *
 * Node identifier: DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_PATH "/flash-controller@0/flash@0/partitions/partition@c000"

/* Node's name with unit-address: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_FULL_NAME "partition@c000"

/* Node parent (/flash-controller@0/flash@0/partitions) identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_PARENT DT_N_S_flash_controller_0_S_flash_0_S_partitions

/* Node's index in its parent's list of children: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_CHILD_IDX 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_FOREACH_CHILD(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_ORD 21

/* Ordinals for what this node depends on directly: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_REQUIRES_ORDS \
	19, /* /flash-controller@0/flash@0/partitions */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_EXISTS 1
#define DT_N_NODELABEL_slot0_partition DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000

/* Macros for properties that are special in the specification: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_REG_NUM 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_REG_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_REG_IDX_0_VAL_ADDRESS 49152 /* 0xc000 */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_REG_IDX_0_VAL_SIZE 430080 /* 0x69000 */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_RANGES_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_FOREACH_RANGE(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_IRQ_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_PINCTRL_NUM 0

/* fixed-partitions identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_PARTITION_ID 1

/* Generic property macros: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_label "image-0"
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_label_STRING_TOKEN image_0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_label_STRING_UPPER_TOKEN IMAGE_0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 1) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 2) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 3) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 4) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 5) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 6)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 1, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 2, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 3, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 4, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 5, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, label, 6, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_label_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_read_only 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_read_only_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_reg {49152 /* 0xc000 */, 430080 /* 0x69000 */}
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_reg_IDX_0 49152
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_reg_IDX_1 430080
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, reg, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, reg, 1)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000, reg, 1, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000_P_reg_EXISTS 1

/*
 * Devicetree node: /flash-controller@0/flash@0/partitions/partition@75000
 *
 * Node identifier: DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_PATH "/flash-controller@0/flash@0/partitions/partition@75000"

/* Node's name with unit-address: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_FULL_NAME "partition@75000"

/* Node parent (/flash-controller@0/flash@0/partitions) identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_PARENT DT_N_S_flash_controller_0_S_flash_0_S_partitions

/* Node's index in its parent's list of children: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_CHILD_IDX 2
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_FOREACH_CHILD(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_ORD 22

/* Ordinals for what this node depends on directly: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_REQUIRES_ORDS \
	19, /* /flash-controller@0/flash@0/partitions */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_EXISTS 1
#define DT_N_NODELABEL_slot1_partition DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000

/* Macros for properties that are special in the specification: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_REG_NUM 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_REG_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_REG_IDX_0_VAL_ADDRESS 479232 /* 0x75000 */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_REG_IDX_0_VAL_SIZE 430080 /* 0x69000 */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_RANGES_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_FOREACH_RANGE(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_IRQ_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_PINCTRL_NUM 0

/* fixed-partitions identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_PARTITION_ID 2

/* Generic property macros: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_label "image-1"
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_label_STRING_TOKEN image_1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_label_STRING_UPPER_TOKEN IMAGE_1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 1) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 2) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 3) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 4) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 5) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 6)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 1, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 2, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 3, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 4, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 5, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, label, 6, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_label_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_read_only 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_read_only_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_reg {479232 /* 0x75000 */, 430080 /* 0x69000 */}
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_reg_IDX_0 479232
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_reg_IDX_1 430080
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, reg, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, reg, 1)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000, reg, 1, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000_P_reg_EXISTS 1

/*
 * Devicetree node: /flash-controller@0/flash@0/partitions/partition@de000
 *
 * Node identifier: DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_PATH "/flash-controller@0/flash@0/partitions/partition@de000"

/* Node's name with unit-address: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_FULL_NAME "partition@de000"

/* Node parent (/flash-controller@0/flash@0/partitions) identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_PARENT DT_N_S_flash_controller_0_S_flash_0_S_partitions

/* Node's index in its parent's list of children: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_CHILD_IDX 3
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_FOREACH_CHILD(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_ORD 23

/* Ordinals for what this node depends on directly: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_REQUIRES_ORDS \
	19, /* /flash-controller@0/flash@0/partitions */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_EXISTS 1
#define DT_N_NODELABEL_scratch_partition DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000

/* Macros for properties that are special in the specification: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_REG_NUM 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_REG_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_REG_IDX_0_VAL_ADDRESS 909312 /* 0xde000 */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_REG_IDX_0_VAL_SIZE 122880 /* 0x1e000 */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_RANGES_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_FOREACH_RANGE(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_IRQ_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_PINCTRL_NUM 0

/* fixed-partitions identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_PARTITION_ID 3

/* Generic property macros: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_label "image-scratch"
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_label_STRING_TOKEN image_scratch
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_label_STRING_UPPER_TOKEN IMAGE_SCRATCH
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 1) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 2) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 3) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 4) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 5) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 6) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 7) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 8) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 9) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 10) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 11) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 12)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 1, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 2, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 3, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 4, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 5, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 6, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 7, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 8, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 9, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 10, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 11, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, label, 12, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_label_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_read_only 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_read_only_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_reg {909312 /* 0xde000 */, 122880 /* 0x1e000 */}
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_reg_IDX_0 909312
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_reg_IDX_1 122880
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, reg, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, reg, 1)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000, reg, 1, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000_P_reg_EXISTS 1

/*
 * Devicetree node: /flash-controller@0/flash@0/partitions/partition@fc000
 *
 * Node identifier: DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_PATH "/flash-controller@0/flash@0/partitions/partition@fc000"

/* Node's name with unit-address: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_FULL_NAME "partition@fc000"

/* Node parent (/flash-controller@0/flash@0/partitions) identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_PARENT DT_N_S_flash_controller_0_S_flash_0_S_partitions

/* Node's index in its parent's list of children: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_CHILD_IDX 4
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_FOREACH_CHILD(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_ORD 24

/* Ordinals for what this node depends on directly: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_REQUIRES_ORDS \
	19, /* /flash-controller@0/flash@0/partitions */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_EXISTS 1
#define DT_N_NODELABEL_storage_partition DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000

/* Macros for properties that are special in the specification: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_REG_NUM 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_REG_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_REG_IDX_0_VAL_ADDRESS 1032192 /* 0xfc000 */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_REG_IDX_0_VAL_SIZE 16384 /* 0x4000 */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_RANGES_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_FOREACH_RANGE(fn) 
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_IRQ_NUM 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_PINCTRL_NUM 0

/* fixed-partitions identifier: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_PARTITION_ID 4

/* Generic property macros: */
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_label "storage"
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_label_STRING_TOKEN storage
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_label_STRING_UPPER_TOKEN STORAGE
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 1) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 2) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 3) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 4) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 5) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 6)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 1, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 2, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 3, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 4, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 5, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, label, 6, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_label_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_read_only 0
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_read_only_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_reg {1032192 /* 0xfc000 */, 16384 /* 0x4000 */}
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_reg_IDX_0 1032192
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_reg_IDX_1 16384
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, reg, 0) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, reg, 1)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000, reg, 1, __VA_ARGS__)
#define DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000_P_reg_EXISTS 1

/*
 * Devicetree node: /gpio@800
 *
 * Node identifier: DT_N_S_gpio_800
 *
 * Binding (compatible = zephyr,gpio-emul):
 *   $ZEPHYR_BASE/dts/bindings/gpio/zephyr,gpio-emul.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_gpio_800_PATH "/gpio@800"

/* Node's name with unit-address: */
#define DT_N_S_gpio_800_FULL_NAME "gpio@800"

/* Node parent (/) identifier: */
#define DT_N_S_gpio_800_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_gpio_800_CHILD_IDX 14
#define DT_N_S_gpio_800_FOREACH_CHILD(fn) 
#define DT_N_S_gpio_800_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_gpio_800_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_gpio_800_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_gpio_800_ORD 25

/* Ordinals for what this node depends on directly: */
#define DT_N_S_gpio_800_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_gpio_800_SUPPORTS_ORDS \
	27, /* /leds/led_0 */

/* Existence and alternate IDs: */
#define DT_N_S_gpio_800_EXISTS 1
#define DT_N_INST_0_zephyr_gpio_emul DT_N_S_gpio_800
#define DT_N_NODELABEL_gpio0         DT_N_S_gpio_800

/* Macros for properties that are special in the specification: */
#define DT_N_S_gpio_800_REG_NUM 1
#define DT_N_S_gpio_800_REG_IDX_0_EXISTS 1
#define DT_N_S_gpio_800_REG_IDX_0_VAL_ADDRESS 2048 /* 0x800 */
#define DT_N_S_gpio_800_REG_IDX_0_VAL_SIZE 4 /* 0x4 */
#define DT_N_S_gpio_800_RANGES_NUM 0
#define DT_N_S_gpio_800_FOREACH_RANGE(fn) 
#define DT_N_S_gpio_800_IRQ_NUM 0
#define DT_N_S_gpio_800_COMPAT_MATCHES_zephyr_gpio_emul 1
#define DT_N_S_gpio_800_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_gpio_800_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_gpio_800_P_reg {2048 /* 0x800 */, 4 /* 0x4 */}
#define DT_N_S_gpio_800_P_reg_IDX_0 2048
#define DT_N_S_gpio_800_P_reg_IDX_0_EXISTS 1
#define DT_N_S_gpio_800_P_reg_IDX_1 4
#define DT_N_S_gpio_800_P_reg_IDX_1_EXISTS 1
#define DT_N_S_gpio_800_P_reg_FOREACH_PROP_ELEM(fn) fn(DT_N_S_gpio_800, reg, 0) \
	fn(DT_N_S_gpio_800, reg, 1)
#define DT_N_S_gpio_800_P_reg_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_gpio_800, reg, 0, __VA_ARGS__) \
	fn(DT_N_S_gpio_800, reg, 1, __VA_ARGS__)
#define DT_N_S_gpio_800_P_reg_EXISTS 1
#define DT_N_S_gpio_800_P_label "GPIO_0"
#define DT_N_S_gpio_800_P_label_STRING_TOKEN GPIO_0
#define DT_N_S_gpio_800_P_label_STRING_UPPER_TOKEN GPIO_0
#define DT_N_S_gpio_800_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_gpio_800, label, 0) \
	fn(DT_N_S_gpio_800, label, 1) \
	fn(DT_N_S_gpio_800, label, 2) \
	fn(DT_N_S_gpio_800, label, 3) \
	fn(DT_N_S_gpio_800, label, 4) \
	fn(DT_N_S_gpio_800, label, 5)
#define DT_N_S_gpio_800_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_gpio_800, label, 0, __VA_ARGS__) \
	fn(DT_N_S_gpio_800, label, 1, __VA_ARGS__) \
	fn(DT_N_S_gpio_800, label, 2, __VA_ARGS__) \
	fn(DT_N_S_gpio_800, label, 3, __VA_ARGS__) \
	fn(DT_N_S_gpio_800, label, 4, __VA_ARGS__) \
	fn(DT_N_S_gpio_800, label, 5, __VA_ARGS__)
#define DT_N_S_gpio_800_P_label_EXISTS 1
#define DT_N_S_gpio_800_P_rising_edge 1
#define DT_N_S_gpio_800_P_rising_edge_EXISTS 1
#define DT_N_S_gpio_800_P_falling_edge 1
#define DT_N_S_gpio_800_P_falling_edge_EXISTS 1
#define DT_N_S_gpio_800_P_high_level 1
#define DT_N_S_gpio_800_P_high_level_EXISTS 1
#define DT_N_S_gpio_800_P_low_level 1
#define DT_N_S_gpio_800_P_low_level_EXISTS 1
#define DT_N_S_gpio_800_P_gpio_controller 1
#define DT_N_S_gpio_800_P_gpio_controller_EXISTS 1
#define DT_N_S_gpio_800_P_ngpios 32
#define DT_N_S_gpio_800_P_ngpios_EXISTS 1
#define DT_N_S_gpio_800_P_status "okay"
#define DT_N_S_gpio_800_P_status_STRING_TOKEN okay
#define DT_N_S_gpio_800_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_gpio_800_P_status_ENUM_IDX 1
#define DT_N_S_gpio_800_P_status_ENUM_TOKEN okay
#define DT_N_S_gpio_800_P_status_ENUM_UPPER_TOKEN OKAY
#define DT_N_S_gpio_800_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_gpio_800, status, 0) \
	fn(DT_N_S_gpio_800, status, 1) \
	fn(DT_N_S_gpio_800, status, 2) \
	fn(DT_N_S_gpio_800, status, 3)
#define DT_N_S_gpio_800_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_gpio_800, status, 0, __VA_ARGS__) \
	fn(DT_N_S_gpio_800, status, 1, __VA_ARGS__) \
	fn(DT_N_S_gpio_800, status, 2, __VA_ARGS__) \
	fn(DT_N_S_gpio_800, status, 3, __VA_ARGS__)
#define DT_N_S_gpio_800_P_status_EXISTS 1
#define DT_N_S_gpio_800_P_compatible {"zephyr,gpio-emul"}
#define DT_N_S_gpio_800_P_compatible_IDX_0 "zephyr,gpio-emul"
#define DT_N_S_gpio_800_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_gpio_800_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_gpio_800, compatible, 0)
#define DT_N_S_gpio_800_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_gpio_800, compatible, 0, __VA_ARGS__)
#define DT_N_S_gpio_800_P_compatible_LEN 1
#define DT_N_S_gpio_800_P_compatible_EXISTS 1
#define DT_N_S_gpio_800_P_wakeup_source 0
#define DT_N_S_gpio_800_P_wakeup_source_EXISTS 1

/*
 * Devicetree node: /leds
 *
 * Node identifier: DT_N_S_leds
 *
 * Binding (compatible = gpio-leds):
 *   $ZEPHYR_BASE/dts/bindings/gpio/gpio-leds.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_leds_PATH "/leds"

/* Node's name with unit-address: */
#define DT_N_S_leds_FULL_NAME "leds"

/* Node parent (/) identifier: */
#define DT_N_S_leds_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_leds_CHILD_IDX 2
#define DT_N_S_leds_FOREACH_CHILD(fn) fn(DT_N_S_leds_S_led_0)
#define DT_N_S_leds_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_leds_S_led_0, __VA_ARGS__)
#define DT_N_S_leds_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_leds_S_led_0) 
#define DT_N_S_leds_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_leds_S_led_0, __VA_ARGS__) 

/* Node's dependency ordinal: */
#define DT_N_S_leds_ORD 26

/* Ordinals for what this node depends on directly: */
#define DT_N_S_leds_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_leds_SUPPORTS_ORDS \
	27, /* /leds/led_0 */

/* Existence and alternate IDs: */
#define DT_N_S_leds_EXISTS 1
#define DT_N_INST_0_gpio_leds DT_N_S_leds

/* Macros for properties that are special in the specification: */
#define DT_N_S_leds_REG_NUM 0
#define DT_N_S_leds_RANGES_NUM 0
#define DT_N_S_leds_FOREACH_RANGE(fn) 
#define DT_N_S_leds_IRQ_NUM 0
#define DT_N_S_leds_COMPAT_MATCHES_gpio_leds 1
#define DT_N_S_leds_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_leds_PINCTRL_NUM 0

/* (No generic property macros) */

/*
 * Devicetree node: /leds/led_0
 *
 * Node identifier: DT_N_S_leds_S_led_0
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_leds_S_led_0_PATH "/leds/led_0"

/* Node's name with unit-address: */
#define DT_N_S_leds_S_led_0_FULL_NAME "led_0"

/* Node parent (/leds) identifier: */
#define DT_N_S_leds_S_led_0_PARENT DT_N_S_leds

/* Node's index in its parent's list of children: */
#define DT_N_S_leds_S_led_0_CHILD_IDX 0
#define DT_N_S_leds_S_led_0_FOREACH_CHILD(fn) 
#define DT_N_S_leds_S_led_0_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_leds_S_led_0_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_leds_S_led_0_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 

/* Node's dependency ordinal: */
#define DT_N_S_leds_S_led_0_ORD 27

/* Ordinals for what this node depends on directly: */
#define DT_N_S_leds_S_led_0_REQUIRES_ORDS \
	25, /* /gpio@800 */ \
	26, /* /leds */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_leds_S_led_0_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_leds_S_led_0_EXISTS 1
#define DT_N_ALIAS_led0     DT_N_S_leds_S_led_0
#define DT_N_NODELABEL_led0 DT_N_S_leds_S_led_0

/* Macros for properties that are special in the specification: */
#define DT_N_S_leds_S_led_0_REG_NUM 0
#define DT_N_S_leds_S_led_0_RANGES_NUM 0
#define DT_N_S_leds_S_led_0_FOREACH_RANGE(fn) 
#define DT_N_S_leds_S_led_0_IRQ_NUM 0
#define DT_N_S_leds_S_led_0_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_leds_S_led_0_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_leds_S_led_0_P_gpios_IDX_0_EXISTS 1
#define DT_N_S_leds_S_led_0_P_gpios_IDX_0_PH DT_N_S_gpio_800
#define DT_N_S_leds_S_led_0_P_gpios_IDX_0_VAL_pin 0
#define DT_N_S_leds_S_led_0_P_gpios_IDX_0_VAL_pin_EXISTS 1
#define DT_N_S_leds_S_led_0_P_gpios_IDX_0_VAL_flags 0
#define DT_N_S_leds_S_led_0_P_gpios_IDX_0_VAL_flags_EXISTS 1
#define DT_N_S_leds_S_led_0_P_gpios_FOREACH_PROP_ELEM(fn) fn(DT_N_S_leds_S_led_0, gpios, 0)
#define DT_N_S_leds_S_led_0_P_gpios_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_leds_S_led_0, gpios, 0, __VA_ARGS__)
#define DT_N_S_leds_S_led_0_P_gpios_LEN 1
#define DT_N_S_leds_S_led_0_P_gpios_EXISTS 1
#define DT_N_S_leds_S_led_0_P_label "Green LED"
#define DT_N_S_leds_S_led_0_P_label_STRING_TOKEN Green_LED
#define DT_N_S_leds_S_led_0_P_label_STRING_UPPER_TOKEN GREEN_LED
#define DT_N_S_leds_S_led_0_P_label_FOREACH_PROP_ELEM(fn) fn(DT_N_S_leds_S_led_0, label, 0) \
	fn(DT_N_S_leds_S_led_0, label, 1) \
	fn(DT_N_S_leds_S_led_0, label, 2) \
	fn(DT_N_S_leds_S_led_0, label, 3) \
	fn(DT_N_S_leds_S_led_0, label, 4) \
	fn(DT_N_S_leds_S_led_0, label, 5) \
	fn(DT_N_S_leds_S_led_0, label, 6) \
	fn(DT_N_S_leds_S_led_0, label, 7) \
	fn(DT_N_S_leds_S_led_0, label, 8)
#define DT_N_S_leds_S_led_0_P_label_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_leds_S_led_0, label, 0, __VA_ARGS__) \
	fn(DT_N_S_leds_S_led_0, label, 1, __VA_ARGS__) \
	fn(DT_N_S_leds_S_led_0, label, 2, __VA_ARGS__) \
	fn(DT_N_S_leds_S_led_0, label, 3, __VA_ARGS__) \
	fn(DT_N_S_leds_S_led_0, label, 4, __VA_ARGS__) \
	fn(DT_N_S_leds_S_led_0, label, 5, __VA_ARGS__) \
	fn(DT_N_S_leds_S_led_0, label, 6, __VA_ARGS__) \
	fn(DT_N_S_leds_S_led_0, label, 7, __VA_ARGS__) \
	fn(DT_N_S_leds_S_led_0, label, 8, __VA_ARGS__)
#define DT_N_S_leds_S_led_0_P_label_EXISTS 1

/*
 * Chosen nodes
 */
#define DT_CHOSEN_zephyr_console                  DT_N_S_uart
#define DT_CHOSEN_zephyr_console_EXISTS           1
#define DT_CHOSEN_zephyr_shell_uart               DT_N_S_uart
#define DT_CHOSEN_zephyr_shell_uart_EXISTS        1
#define DT_CHOSEN_zephyr_uart_mcumgr              DT_N_S_uart
#define DT_CHOSEN_zephyr_uart_mcumgr_EXISTS       1
#define DT_CHOSEN_zephyr_flash                    DT_N_S_flash_controller_0_S_flash_0
#define DT_CHOSEN_zephyr_flash_EXISTS             1
#define DT_CHOSEN_zephyr_entropy                  DT_N_S_rng
#define DT_CHOSEN_zephyr_entropy_EXISTS           1
#define DT_CHOSEN_zephyr_flash_controller         DT_N_S_flash_controller_0
#define DT_CHOSEN_zephyr_flash_controller_EXISTS  1
#define DT_CHOSEN_zephyr_ec_host_interface        DT_N_S_ec_host_cmd_periph
#define DT_CHOSEN_zephyr_ec_host_interface_EXISTS 1
#define DT_CHOSEN_zephyr_display                  DT_N_S_sdl_dc
#define DT_CHOSEN_zephyr_display_EXISTS           1
#define DT_CHOSEN_zephyr_canbus                   DT_N_S_can_loopback0
#define DT_CHOSEN_zephyr_canbus_EXISTS            1
#define DT_COMPAT_fixed_partitions_LABEL_mcuboot DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_0
#define DT_COMPAT_fixed_partitions_LABEL_mcuboot_EXISTS 1
#define DT_COMPAT_fixed_partitions_LABEL_image_0 DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_c000
#define DT_COMPAT_fixed_partitions_LABEL_image_0_EXISTS 1
#define DT_COMPAT_fixed_partitions_LABEL_image_1 DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_75000
#define DT_COMPAT_fixed_partitions_LABEL_image_1_EXISTS 1
#define DT_COMPAT_fixed_partitions_LABEL_image_scratch DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_de000
#define DT_COMPAT_fixed_partitions_LABEL_image_scratch_EXISTS 1
#define DT_COMPAT_fixed_partitions_LABEL_storage DT_N_S_flash_controller_0_S_flash_0_S_partitions_S_partition_fc000
#define DT_COMPAT_fixed_partitions_LABEL_storage_EXISTS 1

/*
 * Macros for compatibles with status "okay" nodes
 */
#define DT_COMPAT_HAS_OKAY_zephyr_posix 1
#define DT_COMPAT_HAS_OKAY_gpio_leds 1
#define DT_COMPAT_HAS_OKAY_zephyr_native_posix_cpu 1
#define DT_COMPAT_HAS_OKAY_zephyr_sim_flash 1
#define DT_COMPAT_HAS_OKAY_soc_nv_flash 1
#define DT_COMPAT_HAS_OKAY_fixed_partitions 1
#define DT_COMPAT_HAS_OKAY_zephyr_sim_eeprom 1
#define DT_COMPAT_HAS_OKAY_zephyr_i2c_emul_controller 1
#define DT_COMPAT_HAS_OKAY_zephyr_spi_emul_controller 1
#define DT_COMPAT_HAS_OKAY_zephyr_espi_emul_controller 1
#define DT_COMPAT_HAS_OKAY_zephyr_native_posix_uart 1
#define DT_COMPAT_HAS_OKAY_zephyr_native_posix_rng 1
#define DT_COMPAT_HAS_OKAY_zephyr_native_posix_counter 1
#define DT_COMPAT_HAS_OKAY_zephyr_sim_ec_host_cmd_periph 1
#define DT_COMPAT_HAS_OKAY_zephyr_gpio_emul 1
#define DT_COMPAT_HAS_OKAY_zephyr_native_posix_udc 1
#define DT_COMPAT_HAS_OKAY_zephyr_sdl_dc 1

/*
 * Macros for status "okay" instances of each compatible
 */
#define DT_N_INST_zephyr_posix_NUM_OKAY 1
#define DT_N_INST_gpio_leds_NUM_OKAY 1
#define DT_N_INST_zephyr_native_posix_cpu_NUM_OKAY 1
#define DT_N_INST_zephyr_sim_flash_NUM_OKAY 1
#define DT_N_INST_soc_nv_flash_NUM_OKAY 1
#define DT_N_INST_fixed_partitions_NUM_OKAY 1
#define DT_N_INST_zephyr_sim_eeprom_NUM_OKAY 1
#define DT_N_INST_zephyr_i2c_emul_controller_NUM_OKAY 1
#define DT_N_INST_zephyr_spi_emul_controller_NUM_OKAY 1
#define DT_N_INST_zephyr_espi_emul_controller_NUM_OKAY 1
#define DT_N_INST_zephyr_native_posix_uart_NUM_OKAY 2
#define DT_N_INST_zephyr_native_posix_rng_NUM_OKAY 1
#define DT_N_INST_zephyr_native_posix_counter_NUM_OKAY 1
#define DT_N_INST_zephyr_sim_ec_host_cmd_periph_NUM_OKAY 1
#define DT_N_INST_zephyr_gpio_emul_NUM_OKAY 1
#define DT_N_INST_zephyr_native_posix_udc_NUM_OKAY 1
#define DT_N_INST_zephyr_sdl_dc_NUM_OKAY 1
#define DT_FOREACH_OKAY_zephyr_posix(fn) fn(DT_N)
#define DT_FOREACH_OKAY_VARGS_zephyr_posix(fn, ...) fn(DT_N, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_posix(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_posix(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_gpio_leds(fn) fn(DT_N_S_leds)
#define DT_FOREACH_OKAY_VARGS_gpio_leds(fn, ...) fn(DT_N_S_leds, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_gpio_leds(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_gpio_leds(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_native_posix_cpu(fn) fn(DT_N_S_cpus_S_cpu_0)
#define DT_FOREACH_OKAY_VARGS_zephyr_native_posix_cpu(fn, ...) fn(DT_N_S_cpus_S_cpu_0, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_native_posix_cpu(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_native_posix_cpu(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_sim_flash(fn) fn(DT_N_S_flash_controller_0)
#define DT_FOREACH_OKAY_VARGS_zephyr_sim_flash(fn, ...) fn(DT_N_S_flash_controller_0, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_sim_flash(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_sim_flash(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_soc_nv_flash(fn) fn(DT_N_S_flash_controller_0_S_flash_0)
#define DT_FOREACH_OKAY_VARGS_soc_nv_flash(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_soc_nv_flash(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_soc_nv_flash(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_fixed_partitions(fn) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions)
#define DT_FOREACH_OKAY_VARGS_fixed_partitions(fn, ...) fn(DT_N_S_flash_controller_0_S_flash_0_S_partitions, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_fixed_partitions(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_fixed_partitions(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_sim_eeprom(fn) fn(DT_N_S_eeprom)
#define DT_FOREACH_OKAY_VARGS_zephyr_sim_eeprom(fn, ...) fn(DT_N_S_eeprom, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_sim_eeprom(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_sim_eeprom(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_i2c_emul_controller(fn) fn(DT_N_S_i2c_100)
#define DT_FOREACH_OKAY_VARGS_zephyr_i2c_emul_controller(fn, ...) fn(DT_N_S_i2c_100, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_i2c_emul_controller(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_i2c_emul_controller(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_spi_emul_controller(fn) fn(DT_N_S_spi_200)
#define DT_FOREACH_OKAY_VARGS_zephyr_spi_emul_controller(fn, ...) fn(DT_N_S_spi_200, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_spi_emul_controller(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_spi_emul_controller(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_espi_emul_controller(fn) fn(DT_N_S_espi_300)
#define DT_FOREACH_OKAY_VARGS_zephyr_espi_emul_controller(fn, ...) fn(DT_N_S_espi_300, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_espi_emul_controller(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_espi_emul_controller(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_native_posix_uart(fn) fn(DT_N_S_uart) fn(DT_N_S_uart_1)
#define DT_FOREACH_OKAY_VARGS_zephyr_native_posix_uart(fn, ...) fn(DT_N_S_uart, __VA_ARGS__) fn(DT_N_S_uart_1, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_native_posix_uart(fn) fn(0) fn(1)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_native_posix_uart(fn, ...) fn(0, __VA_ARGS__) fn(1, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_native_posix_rng(fn) fn(DT_N_S_rng)
#define DT_FOREACH_OKAY_VARGS_zephyr_native_posix_rng(fn, ...) fn(DT_N_S_rng, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_native_posix_rng(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_native_posix_rng(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_native_posix_counter(fn) fn(DT_N_S_counter)
#define DT_FOREACH_OKAY_VARGS_zephyr_native_posix_counter(fn, ...) fn(DT_N_S_counter, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_native_posix_counter(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_native_posix_counter(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_sim_ec_host_cmd_periph(fn) fn(DT_N_S_ec_host_cmd_periph)
#define DT_FOREACH_OKAY_VARGS_zephyr_sim_ec_host_cmd_periph(fn, ...) fn(DT_N_S_ec_host_cmd_periph, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_sim_ec_host_cmd_periph(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_sim_ec_host_cmd_periph(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_gpio_emul(fn) fn(DT_N_S_gpio_800)
#define DT_FOREACH_OKAY_VARGS_zephyr_gpio_emul(fn, ...) fn(DT_N_S_gpio_800, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_gpio_emul(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_gpio_emul(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_native_posix_udc(fn) fn(DT_N_S_udc0)
#define DT_FOREACH_OKAY_VARGS_zephyr_native_posix_udc(fn, ...) fn(DT_N_S_udc0, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_native_posix_udc(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_native_posix_udc(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_zephyr_sdl_dc(fn) fn(DT_N_S_sdl_dc)
#define DT_FOREACH_OKAY_VARGS_zephyr_sdl_dc(fn, ...) fn(DT_N_S_sdl_dc, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_zephyr_sdl_dc(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_zephyr_sdl_dc(fn, ...) fn(0, __VA_ARGS__)

/*
 * Bus information for status "okay" nodes of each compatible
 */
