
zephyr.elf:     file format elf32-i386


Disassembly of section .init:

08049000 <_init>:
 8049000:	f3 0f 1e fb          	endbr32 
 8049004:	53                   	push   %ebx
 8049005:	83 ec 08             	sub    $0x8,%esp
 8049008:	e8 a3 05 00 00       	call   80495b0 <__x86.get_pc_thunk.bx>
 804900d:	81 c3 f3 7f 00 00    	add    $0x7ff3,%ebx
 8049013:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049019:	85 c0                	test   %eax,%eax
 804901b:	74 02                	je     804901f <_init+0x1f>
 804901d:	ff d0                	call   *%eax
 804901f:	83 c4 08             	add    $0x8,%esp
 8049022:	5b                   	pop    %ebx
 8049023:	c3                   	ret    

Disassembly of section .plt:

08049030 <.plt>:
 8049030:	ff 35 04 10 05 08    	pushl  0x8051004
 8049036:	ff 25 08 10 05 08    	jmp    *0x8051008
 804903c:	0f 1f 40 00          	nopl   0x0(%eax)
 8049040:	f3 0f 1e fb          	endbr32 
 8049044:	68 00 00 00 00       	push   $0x0
 8049049:	e9 e2 ff ff ff       	jmp    8049030 <.plt>
 804904e:	66 90                	xchg   %ax,%ax
 8049050:	f3 0f 1e fb          	endbr32 
 8049054:	68 08 00 00 00       	push   $0x8
 8049059:	e9 d2 ff ff ff       	jmp    8049030 <.plt>
 804905e:	66 90                	xchg   %ax,%ax
 8049060:	f3 0f 1e fb          	endbr32 
 8049064:	68 10 00 00 00       	push   $0x10
 8049069:	e9 c2 ff ff ff       	jmp    8049030 <.plt>
 804906e:	66 90                	xchg   %ax,%ax
 8049070:	f3 0f 1e fb          	endbr32 
 8049074:	68 18 00 00 00       	push   $0x18
 8049079:	e9 b2 ff ff ff       	jmp    8049030 <.plt>
 804907e:	66 90                	xchg   %ax,%ax
 8049080:	f3 0f 1e fb          	endbr32 
 8049084:	68 20 00 00 00       	push   $0x20
 8049089:	e9 a2 ff ff ff       	jmp    8049030 <.plt>
 804908e:	66 90                	xchg   %ax,%ax
 8049090:	f3 0f 1e fb          	endbr32 
 8049094:	68 28 00 00 00       	push   $0x28
 8049099:	e9 92 ff ff ff       	jmp    8049030 <.plt>
 804909e:	66 90                	xchg   %ax,%ax
 80490a0:	f3 0f 1e fb          	endbr32 
 80490a4:	68 30 00 00 00       	push   $0x30
 80490a9:	e9 82 ff ff ff       	jmp    8049030 <.plt>
 80490ae:	66 90                	xchg   %ax,%ax
 80490b0:	f3 0f 1e fb          	endbr32 
 80490b4:	68 38 00 00 00       	push   $0x38
 80490b9:	e9 72 ff ff ff       	jmp    8049030 <.plt>
 80490be:	66 90                	xchg   %ax,%ax
 80490c0:	f3 0f 1e fb          	endbr32 
 80490c4:	68 40 00 00 00       	push   $0x40
 80490c9:	e9 62 ff ff ff       	jmp    8049030 <.plt>
 80490ce:	66 90                	xchg   %ax,%ax
 80490d0:	f3 0f 1e fb          	endbr32 
 80490d4:	68 48 00 00 00       	push   $0x48
 80490d9:	e9 52 ff ff ff       	jmp    8049030 <.plt>
 80490de:	66 90                	xchg   %ax,%ax
 80490e0:	f3 0f 1e fb          	endbr32 
 80490e4:	68 50 00 00 00       	push   $0x50
 80490e9:	e9 42 ff ff ff       	jmp    8049030 <.plt>
 80490ee:	66 90                	xchg   %ax,%ax
 80490f0:	f3 0f 1e fb          	endbr32 
 80490f4:	68 58 00 00 00       	push   $0x58
 80490f9:	e9 32 ff ff ff       	jmp    8049030 <.plt>
 80490fe:	66 90                	xchg   %ax,%ax
 8049100:	f3 0f 1e fb          	endbr32 
 8049104:	68 60 00 00 00       	push   $0x60
 8049109:	e9 22 ff ff ff       	jmp    8049030 <.plt>
 804910e:	66 90                	xchg   %ax,%ax
 8049110:	f3 0f 1e fb          	endbr32 
 8049114:	68 68 00 00 00       	push   $0x68
 8049119:	e9 12 ff ff ff       	jmp    8049030 <.plt>
 804911e:	66 90                	xchg   %ax,%ax
 8049120:	f3 0f 1e fb          	endbr32 
 8049124:	68 70 00 00 00       	push   $0x70
 8049129:	e9 02 ff ff ff       	jmp    8049030 <.plt>
 804912e:	66 90                	xchg   %ax,%ax
 8049130:	f3 0f 1e fb          	endbr32 
 8049134:	68 78 00 00 00       	push   $0x78
 8049139:	e9 f2 fe ff ff       	jmp    8049030 <.plt>
 804913e:	66 90                	xchg   %ax,%ax
 8049140:	f3 0f 1e fb          	endbr32 
 8049144:	68 80 00 00 00       	push   $0x80
 8049149:	e9 e2 fe ff ff       	jmp    8049030 <.plt>
 804914e:	66 90                	xchg   %ax,%ax
 8049150:	f3 0f 1e fb          	endbr32 
 8049154:	68 88 00 00 00       	push   $0x88
 8049159:	e9 d2 fe ff ff       	jmp    8049030 <.plt>
 804915e:	66 90                	xchg   %ax,%ax
 8049160:	f3 0f 1e fb          	endbr32 
 8049164:	68 90 00 00 00       	push   $0x90
 8049169:	e9 c2 fe ff ff       	jmp    8049030 <.plt>
 804916e:	66 90                	xchg   %ax,%ax
 8049170:	f3 0f 1e fb          	endbr32 
 8049174:	68 98 00 00 00       	push   $0x98
 8049179:	e9 b2 fe ff ff       	jmp    8049030 <.plt>
 804917e:	66 90                	xchg   %ax,%ax
 8049180:	f3 0f 1e fb          	endbr32 
 8049184:	68 a0 00 00 00       	push   $0xa0
 8049189:	e9 a2 fe ff ff       	jmp    8049030 <.plt>
 804918e:	66 90                	xchg   %ax,%ax
 8049190:	f3 0f 1e fb          	endbr32 
 8049194:	68 a8 00 00 00       	push   $0xa8
 8049199:	e9 92 fe ff ff       	jmp    8049030 <.plt>
 804919e:	66 90                	xchg   %ax,%ax
 80491a0:	f3 0f 1e fb          	endbr32 
 80491a4:	68 b0 00 00 00       	push   $0xb0
 80491a9:	e9 82 fe ff ff       	jmp    8049030 <.plt>
 80491ae:	66 90                	xchg   %ax,%ax
 80491b0:	f3 0f 1e fb          	endbr32 
 80491b4:	68 b8 00 00 00       	push   $0xb8
 80491b9:	e9 72 fe ff ff       	jmp    8049030 <.plt>
 80491be:	66 90                	xchg   %ax,%ax
 80491c0:	f3 0f 1e fb          	endbr32 
 80491c4:	68 c0 00 00 00       	push   $0xc0
 80491c9:	e9 62 fe ff ff       	jmp    8049030 <.plt>
 80491ce:	66 90                	xchg   %ax,%ax
 80491d0:	f3 0f 1e fb          	endbr32 
 80491d4:	68 c8 00 00 00       	push   $0xc8
 80491d9:	e9 52 fe ff ff       	jmp    8049030 <.plt>
 80491de:	66 90                	xchg   %ax,%ax
 80491e0:	f3 0f 1e fb          	endbr32 
 80491e4:	68 d0 00 00 00       	push   $0xd0
 80491e9:	e9 42 fe ff ff       	jmp    8049030 <.plt>
 80491ee:	66 90                	xchg   %ax,%ax
 80491f0:	f3 0f 1e fb          	endbr32 
 80491f4:	68 d8 00 00 00       	push   $0xd8
 80491f9:	e9 32 fe ff ff       	jmp    8049030 <.plt>
 80491fe:	66 90                	xchg   %ax,%ax
 8049200:	f3 0f 1e fb          	endbr32 
 8049204:	68 e0 00 00 00       	push   $0xe0
 8049209:	e9 22 fe ff ff       	jmp    8049030 <.plt>
 804920e:	66 90                	xchg   %ax,%ax
 8049210:	f3 0f 1e fb          	endbr32 
 8049214:	68 e8 00 00 00       	push   $0xe8
 8049219:	e9 12 fe ff ff       	jmp    8049030 <.plt>
 804921e:	66 90                	xchg   %ax,%ax
 8049220:	f3 0f 1e fb          	endbr32 
 8049224:	68 f0 00 00 00       	push   $0xf0
 8049229:	e9 02 fe ff ff       	jmp    8049030 <.plt>
 804922e:	66 90                	xchg   %ax,%ax
 8049230:	f3 0f 1e fb          	endbr32 
 8049234:	68 f8 00 00 00       	push   $0xf8
 8049239:	e9 f2 fd ff ff       	jmp    8049030 <.plt>
 804923e:	66 90                	xchg   %ax,%ax
 8049240:	f3 0f 1e fb          	endbr32 
 8049244:	68 00 01 00 00       	push   $0x100
 8049249:	e9 e2 fd ff ff       	jmp    8049030 <.plt>
 804924e:	66 90                	xchg   %ax,%ax
 8049250:	f3 0f 1e fb          	endbr32 
 8049254:	68 08 01 00 00       	push   $0x108
 8049259:	e9 d2 fd ff ff       	jmp    8049030 <.plt>
 804925e:	66 90                	xchg   %ax,%ax
 8049260:	f3 0f 1e fb          	endbr32 
 8049264:	68 10 01 00 00       	push   $0x110
 8049269:	e9 c2 fd ff ff       	jmp    8049030 <.plt>
 804926e:	66 90                	xchg   %ax,%ax
 8049270:	f3 0f 1e fb          	endbr32 
 8049274:	68 18 01 00 00       	push   $0x118
 8049279:	e9 b2 fd ff ff       	jmp    8049030 <.plt>
 804927e:	66 90                	xchg   %ax,%ax
 8049280:	f3 0f 1e fb          	endbr32 
 8049284:	68 20 01 00 00       	push   $0x120
 8049289:	e9 a2 fd ff ff       	jmp    8049030 <.plt>
 804928e:	66 90                	xchg   %ax,%ax
 8049290:	f3 0f 1e fb          	endbr32 
 8049294:	68 28 01 00 00       	push   $0x128
 8049299:	e9 92 fd ff ff       	jmp    8049030 <.plt>
 804929e:	66 90                	xchg   %ax,%ax
 80492a0:	f3 0f 1e fb          	endbr32 
 80492a4:	68 30 01 00 00       	push   $0x130
 80492a9:	e9 82 fd ff ff       	jmp    8049030 <.plt>
 80492ae:	66 90                	xchg   %ax,%ax
 80492b0:	f3 0f 1e fb          	endbr32 
 80492b4:	68 38 01 00 00       	push   $0x138
 80492b9:	e9 72 fd ff ff       	jmp    8049030 <.plt>
 80492be:	66 90                	xchg   %ax,%ax
 80492c0:	f3 0f 1e fb          	endbr32 
 80492c4:	68 40 01 00 00       	push   $0x140
 80492c9:	e9 62 fd ff ff       	jmp    8049030 <.plt>
 80492ce:	66 90                	xchg   %ax,%ax

Disassembly of section .plt.sec:

080492d0 <pthread_mutex_unlock@plt>:
 80492d0:	f3 0f 1e fb          	endbr32 
 80492d4:	ff 25 0c 10 05 08    	jmp    *0x805100c
 80492da:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080492e0 <__snprintf_chk@plt>:
 80492e0:	f3 0f 1e fb          	endbr32 
 80492e4:	ff 25 10 10 05 08    	jmp    *0x8051010
 80492ea:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080492f0 <__udivdi3@plt>:
 80492f0:	f3 0f 1e fb          	endbr32 
 80492f4:	ff 25 14 10 05 08    	jmp    *0x8051014
 80492fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049300 <strcmp@plt>:
 8049300:	f3 0f 1e fb          	endbr32 
 8049304:	ff 25 18 10 05 08    	jmp    *0x8051018
 804930a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049310 <__vfprintf_chk@plt>:
 8049310:	f3 0f 1e fb          	endbr32 
 8049314:	ff 25 1c 10 05 08    	jmp    *0x805101c
 804931a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049320 <pthread_cond_broadcast@plt>:
 8049320:	f3 0f 1e fb          	endbr32 
 8049324:	ff 25 20 10 05 08    	jmp    *0x8051020
 804932a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049330 <free@plt>:
 8049330:	f3 0f 1e fb          	endbr32 
 8049334:	ff 25 24 10 05 08    	jmp    *0x8051024
 804933a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049340 <__pthread_register_cancel@plt>:
 8049340:	f3 0f 1e fb          	endbr32 
 8049344:	ff 25 28 10 05 08    	jmp    *0x8051028
 804934a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049350 <clock_gettime@plt>:
 8049350:	f3 0f 1e fb          	endbr32 
 8049354:	ff 25 2c 10 05 08    	jmp    *0x805102c
 804935a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049360 <pthread_self@plt>:
 8049360:	f3 0f 1e fb          	endbr32 
 8049364:	ff 25 30 10 05 08    	jmp    *0x8051030
 804936a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049370 <pthread_cond_wait@plt>:
 8049370:	f3 0f 1e fb          	endbr32 
 8049374:	ff 25 34 10 05 08    	jmp    *0x8051034
 804937a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049380 <sleep@plt>:
 8049380:	f3 0f 1e fb          	endbr32 
 8049384:	ff 25 38 10 05 08    	jmp    *0x8051038
 804938a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049390 <__stack_chk_fail@plt>:
 8049390:	f3 0f 1e fb          	endbr32 
 8049394:	ff 25 3c 10 05 08    	jmp    *0x805103c
 804939a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493a0 <pthread_mutex_lock@plt>:
 80493a0:	f3 0f 1e fb          	endbr32 
 80493a4:	ff 25 40 10 05 08    	jmp    *0x8051040
 80493aa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493b0 <strtoll@plt>:
 80493b0:	f3 0f 1e fb          	endbr32 
 80493b4:	ff 25 44 10 05 08    	jmp    *0x8051044
 80493ba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493c0 <realloc@plt>:
 80493c0:	f3 0f 1e fb          	endbr32 
 80493c4:	ff 25 48 10 05 08    	jmp    *0x8051048
 80493ca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493d0 <exit@plt>:
 80493d0:	f3 0f 1e fb          	endbr32 
 80493d4:	ff 25 4c 10 05 08    	jmp    *0x805104c
 80493da:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493e0 <__udivmoddi4@plt>:
 80493e0:	f3 0f 1e fb          	endbr32 
 80493e4:	ff 25 50 10 05 08    	jmp    *0x8051050
 80493ea:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493f0 <strtoul@plt>:
 80493f0:	f3 0f 1e fb          	endbr32 
 80493f4:	ff 25 54 10 05 08    	jmp    *0x8051054
 80493fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049400 <__libc_start_main@plt>:
 8049400:	f3 0f 1e fb          	endbr32 
 8049404:	ff 25 58 10 05 08    	jmp    *0x8051058
 804940a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049410 <strcasecmp@plt>:
 8049410:	f3 0f 1e fb          	endbr32 
 8049414:	ff 25 5c 10 05 08    	jmp    *0x805105c
 804941a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049420 <setvbuf@plt>:
 8049420:	f3 0f 1e fb          	endbr32 
 8049424:	ff 25 60 10 05 08    	jmp    *0x8051060
 804942a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049430 <snprintf@plt>:
 8049430:	f3 0f 1e fb          	endbr32 
 8049434:	ff 25 64 10 05 08    	jmp    *0x8051064
 804943a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049440 <putchar@plt>:
 8049440:	f3 0f 1e fb          	endbr32 
 8049444:	ff 25 68 10 05 08    	jmp    *0x8051068
 804944a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049450 <pthread_cancel@plt>:
 8049450:	f3 0f 1e fb          	endbr32 
 8049454:	ff 25 6c 10 05 08    	jmp    *0x805106c
 804945a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049460 <strtoull@plt>:
 8049460:	f3 0f 1e fb          	endbr32 
 8049464:	ff 25 70 10 05 08    	jmp    *0x8051070
 804946a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049470 <strtod@plt>:
 8049470:	f3 0f 1e fb          	endbr32 
 8049474:	ff 25 74 10 05 08    	jmp    *0x8051074
 804947a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049480 <pthread_exit@plt>:
 8049480:	f3 0f 1e fb          	endbr32 
 8049484:	ff 25 78 10 05 08    	jmp    *0x8051078
 804948a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049490 <strnlen@plt>:
 8049490:	f3 0f 1e fb          	endbr32 
 8049494:	ff 25 7c 10 05 08    	jmp    *0x805107c
 804949a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494a0 <__sigsetjmp@plt>:
 80494a0:	f3 0f 1e fb          	endbr32 
 80494a4:	ff 25 80 10 05 08    	jmp    *0x8051080
 80494aa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494b0 <sigemptyset@plt>:
 80494b0:	f3 0f 1e fb          	endbr32 
 80494b4:	ff 25 84 10 05 08    	jmp    *0x8051084
 80494ba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494c0 <__pthread_unwind_next@plt>:
 80494c0:	f3 0f 1e fb          	endbr32 
 80494c4:	ff 25 88 10 05 08    	jmp    *0x8051088
 80494ca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494d0 <nanosleep@plt>:
 80494d0:	f3 0f 1e fb          	endbr32 
 80494d4:	ff 25 8c 10 05 08    	jmp    *0x805108c
 80494da:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494e0 <__fprintf_chk@plt>:
 80494e0:	f3 0f 1e fb          	endbr32 
 80494e4:	ff 25 90 10 05 08    	jmp    *0x8051090
 80494ea:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494f0 <pthread_create@plt>:
 80494f0:	f3 0f 1e fb          	endbr32 
 80494f4:	ff 25 94 10 05 08    	jmp    *0x8051094
 80494fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049500 <sigaction@plt>:
 8049500:	f3 0f 1e fb          	endbr32 
 8049504:	ff 25 98 10 05 08    	jmp    *0x8051098
 804950a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049510 <pthread_detach@plt>:
 8049510:	f3 0f 1e fb          	endbr32 
 8049514:	ff 25 9c 10 05 08    	jmp    *0x805109c
 804951a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049520 <isatty@plt>:
 8049520:	f3 0f 1e fb          	endbr32 
 8049524:	ff 25 a0 10 05 08    	jmp    *0x80510a0
 804952a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049530 <strtol@plt>:
 8049530:	f3 0f 1e fb          	endbr32 
 8049534:	ff 25 a4 10 05 08    	jmp    *0x80510a4
 804953a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049540 <__ctype_b_loc@plt>:
 8049540:	f3 0f 1e fb          	endbr32 
 8049544:	ff 25 a8 10 05 08    	jmp    *0x80510a8
 804954a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049550 <calloc@plt>:
 8049550:	f3 0f 1e fb          	endbr32 
 8049554:	ff 25 ac 10 05 08    	jmp    *0x80510ac
 804955a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

Disassembly of section .text:

08049560 <_start>:
 8049560:	f3 0f 1e fb          	endbr32 
 8049564:	31 ed                	xor    %ebp,%ebp
 8049566:	5e                   	pop    %esi
 8049567:	89 e1                	mov    %esp,%ecx
 8049569:	83 e4 f0             	and    $0xfffffff0,%esp
 804956c:	50                   	push   %eax
 804956d:	54                   	push   %esp
 804956e:	52                   	push   %edx
 804956f:	e8 23 00 00 00       	call   8049597 <_start+0x37>
 8049574:	81 c3 8c 7a 00 00    	add    $0x7a8c,%ebx
 804957a:	8d 83 f0 86 ff ff    	lea    -0x7910(%ebx),%eax
 8049580:	50                   	push   %eax
 8049581:	8d 83 80 86 ff ff    	lea    -0x7980(%ebx),%eax
 8049587:	50                   	push   %eax
 8049588:	51                   	push   %ecx
 8049589:	56                   	push   %esi
 804958a:	c7 c0 17 b7 04 08    	mov    $0x804b717,%eax
 8049590:	50                   	push   %eax
 8049591:	e8 6a fe ff ff       	call   8049400 <__libc_start_main@plt>
 8049596:	f4                   	hlt    
 8049597:	8b 1c 24             	mov    (%esp),%ebx
 804959a:	c3                   	ret    
 804959b:	66 90                	xchg   %ax,%ax
 804959d:	66 90                	xchg   %ax,%ax
 804959f:	90                   	nop

080495a0 <_dl_relocate_static_pie>:
 80495a0:	f3 0f 1e fb          	endbr32 
 80495a4:	c3                   	ret    
 80495a5:	66 90                	xchg   %ax,%ax
 80495a7:	66 90                	xchg   %ax,%ax
 80495a9:	66 90                	xchg   %ax,%ax
 80495ab:	66 90                	xchg   %ax,%ax
 80495ad:	66 90                	xchg   %ax,%ax
 80495af:	90                   	nop

080495b0 <__x86.get_pc_thunk.bx>:
 80495b0:	8b 1c 24             	mov    (%esp),%ebx
 80495b3:	c3                   	ret    
 80495b4:	66 90                	xchg   %ax,%ax
 80495b6:	66 90                	xchg   %ax,%ax
 80495b8:	66 90                	xchg   %ax,%ax
 80495ba:	66 90                	xchg   %ax,%ax
 80495bc:	66 90                	xchg   %ax,%ax
 80495be:	66 90                	xchg   %ax,%ax

080495c0 <deregister_tm_clones>:
 80495c0:	b8 94 12 05 08       	mov    $0x8051294,%eax
 80495c5:	3d 94 12 05 08       	cmp    $0x8051294,%eax
 80495ca:	74 24                	je     80495f0 <deregister_tm_clones+0x30>
 80495cc:	b8 00 00 00 00       	mov    $0x0,%eax
 80495d1:	85 c0                	test   %eax,%eax
 80495d3:	74 1b                	je     80495f0 <deregister_tm_clones+0x30>
 80495d5:	55                   	push   %ebp
 80495d6:	89 e5                	mov    %esp,%ebp
 80495d8:	83 ec 14             	sub    $0x14,%esp
 80495db:	68 94 12 05 08       	push   $0x8051294
 80495e0:	ff d0                	call   *%eax
 80495e2:	83 c4 10             	add    $0x10,%esp
 80495e5:	c9                   	leave  
 80495e6:	c3                   	ret    
 80495e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80495ee:	66 90                	xchg   %ax,%ax
 80495f0:	c3                   	ret    
 80495f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80495f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80495ff:	90                   	nop

08049600 <register_tm_clones>:
 8049600:	b8 94 12 05 08       	mov    $0x8051294,%eax
 8049605:	2d 94 12 05 08       	sub    $0x8051294,%eax
 804960a:	89 c2                	mov    %eax,%edx
 804960c:	c1 e8 1f             	shr    $0x1f,%eax
 804960f:	c1 fa 02             	sar    $0x2,%edx
 8049612:	01 d0                	add    %edx,%eax
 8049614:	d1 f8                	sar    %eax
 8049616:	74 20                	je     8049638 <register_tm_clones+0x38>
 8049618:	ba 00 00 00 00       	mov    $0x0,%edx
 804961d:	85 d2                	test   %edx,%edx
 804961f:	74 17                	je     8049638 <register_tm_clones+0x38>
 8049621:	55                   	push   %ebp
 8049622:	89 e5                	mov    %esp,%ebp
 8049624:	83 ec 10             	sub    $0x10,%esp
 8049627:	50                   	push   %eax
 8049628:	68 94 12 05 08       	push   $0x8051294
 804962d:	ff d2                	call   *%edx
 804962f:	83 c4 10             	add    $0x10,%esp
 8049632:	c9                   	leave  
 8049633:	c3                   	ret    
 8049634:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049638:	c3                   	ret    
 8049639:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049640 <__do_global_dtors_aux>:
 8049640:	f3 0f 1e fb          	endbr32 
 8049644:	80 3d 9c 24 05 08 00 	cmpb   $0x0,0x805249c
 804964b:	75 1b                	jne    8049668 <__do_global_dtors_aux+0x28>
 804964d:	55                   	push   %ebp
 804964e:	89 e5                	mov    %esp,%ebp
 8049650:	83 ec 08             	sub    $0x8,%esp
 8049653:	e8 68 ff ff ff       	call   80495c0 <deregister_tm_clones>
 8049658:	c6 05 9c 24 05 08 01 	movb   $0x1,0x805249c
 804965f:	c9                   	leave  
 8049660:	c3                   	ret    
 8049661:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049668:	c3                   	ret    
 8049669:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049670 <frame_dummy>:
 8049670:	f3 0f 1e fb          	endbr32 
 8049674:	eb 8a                	jmp    8049600 <register_tm_clones>
 8049676:	66 90                	xchg   %ax,%ax
 8049678:	66 90                	xchg   %ax,%ax
 804967a:	66 90                	xchg   %ax,%ax
 804967c:	66 90                	xchg   %ax,%ax
 804967e:	66 90                	xchg   %ax,%ax

08049680 <__libc_csu_init>:
 8049680:	f3 0f 1e fb          	endbr32 
 8049684:	55                   	push   %ebp
 8049685:	e8 7a 39 00 00       	call   804d004 <__x86.get_pc_thunk.bp>
 804968a:	81 c5 76 79 00 00    	add    $0x7976,%ebp
 8049690:	57                   	push   %edi
 8049691:	56                   	push   %esi
 8049692:	53                   	push   %ebx
 8049693:	83 ec 0c             	sub    $0xc,%esp
 8049696:	89 eb                	mov    %ebp,%ebx
 8049698:	8b 7c 24 28          	mov    0x28(%esp),%edi
 804969c:	e8 5f f9 ff ff       	call   8049000 <_init>
 80496a1:	8d 9d b0 0f 00 00    	lea    0xfb0(%ebp),%ebx
 80496a7:	8d 85 ac 0f 00 00    	lea    0xfac(%ebp),%eax
 80496ad:	29 c3                	sub    %eax,%ebx
 80496af:	c1 fb 02             	sar    $0x2,%ebx
 80496b2:	74 29                	je     80496dd <__libc_csu_init+0x5d>
 80496b4:	31 f6                	xor    %esi,%esi
 80496b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80496bd:	8d 76 00             	lea    0x0(%esi),%esi
 80496c0:	83 ec 04             	sub    $0x4,%esp
 80496c3:	57                   	push   %edi
 80496c4:	ff 74 24 2c          	pushl  0x2c(%esp)
 80496c8:	ff 74 24 2c          	pushl  0x2c(%esp)
 80496cc:	ff 94 b5 ac 0f 00 00 	call   *0xfac(%ebp,%esi,4)
 80496d3:	83 c6 01             	add    $0x1,%esi
 80496d6:	83 c4 10             	add    $0x10,%esp
 80496d9:	39 f3                	cmp    %esi,%ebx
 80496db:	75 e3                	jne    80496c0 <__libc_csu_init+0x40>
 80496dd:	83 c4 0c             	add    $0xc,%esp
 80496e0:	5b                   	pop    %ebx
 80496e1:	5e                   	pop    %esi
 80496e2:	5f                   	pop    %edi
 80496e3:	5d                   	pop    %ebp
 80496e4:	c3                   	ret    
 80496e5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80496ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080496f0 <__libc_csu_fini>:
 80496f0:	f3 0f 1e fb          	endbr32 
 80496f4:	c3                   	ret    

080496f5 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
 80496f5:	f3 0f 1e fb          	endbr32 

#if defined(CONFIG_FPU_SHARING)
GEN_OFFSET_SYM(_thread_arch_t, excNestCount);
#endif

GEN_ABS_SYM_END
 80496f9:	c3                   	ret    

080496fa <zephyr_app_main>:
#include <zephyr/zephyr.h>
#include "math.hpp"

void main() {
 80496fa:	f3 0f 1e fb          	endbr32 
 80496fe:	55                   	push   %ebp
 80496ff:	89 e5                	mov    %esp,%ebp
 8049701:	83 ec 10             	sub    $0x10,%esp
	printk("Hello! 6 + 4 = %d\n", math::add(6,4));
 8049704:	6a 04                	push   $0x4
 8049706:	6a 06                	push   $0x6
 8049708:	e8 12 00 00 00       	call   804971f <_ZN4math3addEjj>
 804970d:	5a                   	pop    %edx
 804970e:	59                   	pop    %ecx
 804970f:	50                   	push   %eax
 8049710:	68 64 e1 04 08       	push   $0x804e164
 8049715:	e8 85 00 00 00       	call   804979f <printk>
 804971a:	83 c4 10             	add    $0x10,%esp
}
 804971d:	c9                   	leave  
 804971e:	c3                   	ret    

0804971f <_ZN4math3addEjj>:
#include "math.hpp"

namespace math {

uint32_t add(uint32_t op1, uint32_t op2) {
 804971f:	f3 0f 1e fb          	endbr32 
 8049723:	55                   	push   %ebp
 8049724:	89 e5                	mov    %esp,%ebp
	return op1 + op2;
 8049726:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049729:	03 45 08             	add    0x8(%ebp),%eax
}
 804972c:	5d                   	pop    %ebp
 804972d:	c3                   	ret    

0804972e <arch_printk_char_out>:
 *
 * @return 0
 */
/* LCOV_EXCL_START */
__attribute__((weak)) int arch_printk_char_out(int c)
{
 804972e:	f3 0f 1e fb          	endbr32 
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
 8049732:	31 c0                	xor    %eax,%eax
 8049734:	c3                   	ret    

08049735 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
 8049735:	f3 0f 1e fb          	endbr32 
 8049739:	55                   	push   %ebp
 804973a:	89 e5                	mov    %esp,%ebp
 804973c:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct out_context *ctx = ctx_p;

	ctx->count++;
 804973f:	ff 00                	incl   (%eax)
	return _char_out(c);
}
 8049741:	5d                   	pop    %ebp
	return _char_out(c);
 8049742:	ff 25 70 12 05 08    	jmp    *0x8051270

08049748 <__printk_hook_install>:
{
 8049748:	f3 0f 1e fb          	endbr32 
 804974c:	55                   	push   %ebp
 804974d:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
 804974f:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8049752:	5d                   	pop    %ebp
	_char_out = fn;
 8049753:	a3 70 12 05 08       	mov    %eax,0x8051270
}
 8049758:	c3                   	ret    

08049759 <vprintk>:

void vprintk(const char *fmt, va_list ap)
{
 8049759:	f3 0f 1e fb          	endbr32 
 804975d:	55                   	push   %ebp
 804975e:	89 e5                	mov    %esp,%ebp
 8049760:	83 ec 18             	sub    $0x18,%esp
 8049763:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8049769:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804976c:	31 c0                	xor    %eax,%eax
		struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
		k_spinlock_key_t key = k_spin_lock(&lock);
#endif

		cbvprintf(char_out, &ctx, fmt, ap);
 804976e:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8049771:	ff 75 0c             	pushl  0xc(%ebp)
 8049774:	ff 75 08             	pushl  0x8(%ebp)
 8049777:	50                   	push   %eax
 8049778:	68 35 97 04 08       	push   $0x8049735
		struct out_context ctx = { 0 };
 804977d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cbvprintf(char_out, &ctx, fmt, ap);
 8049784:	e8 cc 01 00 00       	call   8049955 <cbvprintf>
 8049789:	83 c4 10             	add    $0x10,%esp

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
 804978c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804978f:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 8049796:	74 05                	je     804979d <vprintk+0x44>
 8049798:	e8 f3 fb ff ff       	call   8049390 <__stack_chk_fail@plt>
 804979d:	c9                   	leave  
 804979e:	c3                   	ret    

0804979f <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
 804979f:	f3 0f 1e fb          	endbr32 
 80497a3:	55                   	push   %ebp
 80497a4:	89 e5                	mov    %esp,%ebp
 80497a6:	83 ec 10             	sub    $0x10,%esp
	va_list ap;

	va_start(ap, fmt);
 80497a9:	8d 45 0c             	lea    0xc(%ebp),%eax

	vprintk(fmt, ap);
 80497ac:	50                   	push   %eax
 80497ad:	ff 75 08             	pushl  0x8(%ebp)
 80497b0:	e8 a4 ff ff ff       	call   8049759 <vprintk>
 80497b5:	83 c4 10             	add    $0x10,%esp

	va_end(ap);
}
 80497b8:	c9                   	leave  
 80497b9:	c3                   	ret    

080497ba <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
 80497ba:	f3 0f 1e fb          	endbr32 
 80497be:	55                   	push   %ebp
 80497bf:	89 e5                	mov    %esp,%ebp
 80497c1:	83 ec 0c             	sub    $0xc,%esp
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
 80497c4:	ff 75 14             	pushl  0x14(%ebp)
 80497c7:	ff 75 10             	pushl  0x10(%ebp)
 80497ca:	ff 75 0c             	pushl  0xc(%ebp)
 80497cd:	ff 55 08             	call   *0x8(%ebp)
 80497d0:	83 c4 10             	add    $0x10,%esp
	if (z_syscall_trap()) {
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
 80497d3:	e8 23 33 00 00       	call   804cafb <z_impl_z_current_get>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
 80497d8:	83 ec 0c             	sub    $0xc,%esp
 80497db:	50                   	push   %eax
 80497dc:	e8 96 0d 00 00       	call   804a577 <z_impl_k_thread_abort>
 80497e1:	83 c4 0c             	add    $0xc,%esp
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 80497e4:	6a 2d                	push   $0x2d
 80497e6:	68 77 e1 04 08       	push   $0x804e177
 80497eb:	68 a0 e1 04 08       	push   $0x804e1a0
 80497f0:	e8 23 20 00 00       	call   804b818 <posix_print_error_and_exit>
 80497f5:	83 c4 10             	add    $0x10,%esp

080497f8 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
 80497f8:	55                   	push   %ebp
 80497f9:	89 e5                	mov    %esp,%ebp
 80497fb:	57                   	push   %edi
 80497fc:	89 cf                	mov    %ecx,%edi
 80497fe:	56                   	push   %esi
 80497ff:	89 c6                	mov    %eax,%esi
 8049801:	53                   	push   %ebx
	size_t count = 0;
 8049802:	31 db                	xor    %ebx,%ebx
{
 8049804:	83 ec 1c             	sub    $0x1c,%esp

	while ((sp < ep) || ((ep == NULL) && *sp)) {
 8049807:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
 804980a:	39 45 08             	cmp    %eax,0x8(%ebp)
 804980d:	76 1a                	jbe    8049829 <outs+0x31>
		int rc = out((int)*sp++, ctx);
 804980f:	50                   	push   %eax
 8049810:	50                   	push   %eax
 8049811:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
 8049815:	52                   	push   %edx
 8049816:	50                   	push   %eax
 8049817:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804981a:	ff d6                	call   *%esi
 804981c:	83 c4 10             	add    $0x10,%esp

		if (rc < 0) {
 804981f:	85 c0                	test   %eax,%eax
 8049821:	78 18                	js     804983b <outs+0x43>
			return rc;
		}
		++count;
 8049823:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049826:	43                   	inc    %ebx
 8049827:	eb de                	jmp    8049807 <outs+0xf>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 8049829:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804982d:	74 04                	je     8049833 <outs+0x3b>
	}

	return (int)count;
 804982f:	89 d8                	mov    %ebx,%eax
 8049831:	eb 08                	jmp    804983b <outs+0x43>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 8049833:	80 3c 1f 00          	cmpb   $0x0,(%edi,%ebx,1)
 8049837:	75 d6                	jne    804980f <outs+0x17>
 8049839:	eb f4                	jmp    804982f <outs+0x37>
}
 804983b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804983e:	5b                   	pop    %ebx
 804983f:	5e                   	pop    %esi
 8049840:	5f                   	pop    %edi
 8049841:	5d                   	pop    %ebp
 8049842:	c3                   	ret    

08049843 <extract_decimal>:
{
 8049843:	55                   	push   %ebp
 8049844:	89 e5                	mov    %esp,%ebp
 8049846:	57                   	push   %edi
 8049847:	56                   	push   %esi
 8049848:	53                   	push   %ebx
 8049849:	89 c3                	mov    %eax,%ebx
 804984b:	83 ec 0c             	sub    $0xc,%esp
	const char *sp = *str;
 804984e:	8b 30                	mov    (%eax),%esi
	while (isdigit((int)(unsigned char)*sp)) {
 8049850:	e8 eb fc ff ff       	call   8049540 <__ctype_b_loc@plt>
 8049855:	8b 08                	mov    (%eax),%ecx
	size_t val = 0;
 8049857:	31 c0                	xor    %eax,%eax
	while (isdigit((int)(unsigned char)*sp)) {
 8049859:	0f be 16             	movsbl (%esi),%edx
 804985c:	0f b6 fa             	movzbl %dl,%edi
 804985f:	f6 44 79 01 08       	testb  $0x8,0x1(%ecx,%edi,2)
 8049864:	74 0a                	je     8049870 <extract_decimal+0x2d>
		val = 10U * val + *sp++ - '0';
 8049866:	6b c0 0a             	imul   $0xa,%eax,%eax
 8049869:	46                   	inc    %esi
 804986a:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
 804986e:	eb e9                	jmp    8049859 <extract_decimal+0x16>
	*str = sp;
 8049870:	89 33                	mov    %esi,(%ebx)
}
 8049872:	83 c4 0c             	add    $0xc,%esp
 8049875:	5b                   	pop    %ebx
 8049876:	5e                   	pop    %esi
 8049877:	5f                   	pop    %edi
 8049878:	5d                   	pop    %ebp
 8049879:	c3                   	ret    

0804987a <encode_uint>:
{
 804987a:	55                   	push   %ebp
 804987b:	89 e5                	mov    %esp,%ebp
 804987d:	57                   	push   %edi
 804987e:	56                   	push   %esi
 804987f:	89 ce                	mov    %ecx,%esi
 8049881:	53                   	push   %ebx
	switch (specifier) {
 8049882:	bb 08 00 00 00       	mov    $0x8,%ebx
{
 8049887:	83 ec 3c             	sub    $0x3c,%esp
 804988a:	89 55 dc             	mov    %edx,-0x24(%ebp)
 804988d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	bool upcase = isupper((int)conv->specifier);
 8049890:	e8 ab fc ff ff       	call   8049540 <__ctype_b_loc@plt>
 8049895:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
 8049899:	8b 10                	mov    (%eax),%edx
 804989b:	66 8b 14 4a          	mov    (%edx,%ecx,2),%dx
 804989f:	66 81 e2 00 01       	and    $0x100,%dx
 80498a4:	66 89 55 ce          	mov    %dx,-0x32(%ebp)
	switch (specifier) {
 80498a8:	80 f9 6f             	cmp    $0x6f,%cl
 80498ab:	74 1b                	je     80498c8 <encode_uint+0x4e>
 80498ad:	89 c8                	mov    %ecx,%eax
 80498af:	77 05                	ja     80498b6 <encode_uint+0x3c>
		return 16;
 80498b1:	80 f9 58             	cmp    $0x58,%cl
 80498b4:	eb 05                	jmp    80498bb <encode_uint+0x41>
	switch (specifier) {
 80498b6:	83 e0 f7             	and    $0xfffffff7,%eax
		return 16;
 80498b9:	3c 70                	cmp    $0x70,%al
 80498bb:	bb 0a 00 00 00       	mov    $0xa,%ebx
 80498c0:	b8 10 00 00 00       	mov    $0x10,%eax
 80498c5:	0f 44 d8             	cmove  %eax,%ebx
		unsigned int lsv = (unsigned int)(value % radix);
 80498c8:	89 5d d0             	mov    %ebx,-0x30(%ebp)
	char *bp = bps + (bpe - bps);
 80498cb:	8b 7d 0c             	mov    0xc(%ebp),%edi
		unsigned int lsv = (unsigned int)(value % radix);
 80498ce:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
 80498d5:	83 ec 0c             	sub    $0xc,%esp
 80498d8:	8d 45 e0             	lea    -0x20(%ebp),%eax
 80498db:	50                   	push   %eax
 80498dc:	ff 75 d4             	pushl  -0x2c(%ebp)
 80498df:	ff 75 d0             	pushl  -0x30(%ebp)
 80498e2:	ff 75 dc             	pushl  -0x24(%ebp)
 80498e5:	ff 75 d8             	pushl  -0x28(%ebp)
 80498e8:	e8 f3 fa ff ff       	call   80493e0 <__udivmoddi4@plt>
 80498ed:	83 c4 20             	add    $0x20,%esp
 80498f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
 80498f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
 80498f6:	89 55 c4             	mov    %edx,-0x3c(%ebp)
 80498f9:	8d 50 30             	lea    0x30(%eax),%edx
 80498fc:	83 f8 09             	cmp    $0x9,%eax
 80498ff:	76 0d                	jbe    804990e <encode_uint+0x94>
 8049901:	66 83 7d ce 00       	cmpw   $0x0,-0x32(%ebp)
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
 8049906:	8d 50 57             	lea    0x57(%eax),%edx
		*--bp = (lsv <= 9) ? ('0' + lsv)
 8049909:	74 03                	je     804990e <encode_uint+0x94>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
 804990b:	8d 50 37             	lea    0x37(%eax),%edx
	} while ((value != 0) && (bps < bp));
 804990e:	8b 45 d0             	mov    -0x30(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
 8049911:	4f                   	dec    %edi
	} while ((value != 0) && (bps < bp));
 8049912:	39 45 d8             	cmp    %eax,-0x28(%ebp)
		*--bp = (lsv <= 9) ? ('0' + lsv)
 8049915:	88 17                	mov    %dl,(%edi)
	} while ((value != 0) && (bps < bp));
 8049917:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804991a:	1b 45 d4             	sbb    -0x2c(%ebp),%eax
 804991d:	72 13                	jb     8049932 <encode_uint+0xb8>
 804991f:	3b 7d 08             	cmp    0x8(%ebp),%edi
 8049922:	76 0e                	jbe    8049932 <encode_uint+0xb8>
		value /= radix;
 8049924:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049927:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804992a:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804992d:	89 55 dc             	mov    %edx,-0x24(%ebp)
 8049930:	eb a3                	jmp    80498d5 <encode_uint+0x5b>
	if (conv->flag_hash) {
 8049932:	f6 06 20             	testb  $0x20,(%esi)
 8049935:	74 14                	je     804994b <encode_uint+0xd1>
		if (radix == 8) {
 8049937:	83 fb 08             	cmp    $0x8,%ebx
 804993a:	75 06                	jne    8049942 <encode_uint+0xc8>
			conv->altform_0 = true;
 804993c:	80 4e 02 08          	orb    $0x8,0x2(%esi)
 8049940:	eb 09                	jmp    804994b <encode_uint+0xd1>
		} else if (radix == 16) {
 8049942:	83 fb 10             	cmp    $0x10,%ebx
 8049945:	75 04                	jne    804994b <encode_uint+0xd1>
			conv->altform_0c = true;
 8049947:	80 4e 02 10          	orb    $0x10,0x2(%esi)
}
 804994b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804994e:	89 f8                	mov    %edi,%eax
 8049950:	5b                   	pop    %ebx
 8049951:	5e                   	pop    %esi
 8049952:	5f                   	pop    %edi
 8049953:	5d                   	pop    %ebp
 8049954:	c3                   	ret    

08049955 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
 8049955:	f3 0f 1e fb          	endbr32 
 8049959:	55                   	push   %ebp
 804995a:	89 e5                	mov    %esp,%ebp
 804995c:	57                   	push   %edi
 804995d:	56                   	push   %esi
 804995e:	53                   	push   %ebx
 804995f:	83 ec 6c             	sub    $0x6c,%esp
 8049962:	8b 45 08             	mov    0x8(%ebp),%eax
 8049965:	8b 5d 14             	mov    0x14(%ebp),%ebx
 8049968:	89 45 98             	mov    %eax,-0x68(%ebp)
 804996b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804996e:	89 45 94             	mov    %eax,-0x6c(%ebp)
 8049971:	8b 45 10             	mov    0x10(%ebp),%eax
 8049974:	89 45 9c             	mov    %eax,-0x64(%ebp)
 8049977:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804997d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8049980:	31 c0                	xor    %eax,%eax
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
 8049982:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
 8049989:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804998c:	0f be 00             	movsbl (%eax),%eax
 804998f:	84 c0                	test   %al,%al
 8049991:	0f 84 81 07 00 00    	je     804a118 <cbvprintf+0x7c3>
		if (*fp != '%') {
 8049997:	8b 7d 9c             	mov    -0x64(%ebp),%edi
 804999a:	47                   	inc    %edi
 804999b:	89 7d 90             	mov    %edi,-0x70(%ebp)
 804999e:	3c 25                	cmp    $0x25,%al
 80499a0:	74 0b                	je     80499ad <cbvprintf+0x58>
			OUTC(*fp++);
 80499a2:	56                   	push   %esi
 80499a3:	56                   	push   %esi
 80499a4:	ff 75 94             	pushl  -0x6c(%ebp)
 80499a7:	50                   	push   %eax
 80499a8:	e9 5b 04 00 00       	jmp    8049e08 <cbvprintf+0x4b3>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
 80499ad:	31 c0                	xor    %eax,%eax
 80499af:	8d 7d b4             	lea    -0x4c(%ebp),%edi
 80499b2:	b9 03 00 00 00       	mov    $0x3,%ecx
 80499b7:	f3 ab                	rep stos %eax,%es:(%edi)
	*conv = (struct conversion) {
 80499b9:	8d 7d c0             	lea    -0x40(%ebp),%edi
 80499bc:	b9 03 00 00 00       	mov    $0x3,%ecx
 80499c1:	f3 ab                	rep stos %eax,%es:(%edi)
	if (*sp == '%') {
 80499c3:	8b 45 9c             	mov    -0x64(%ebp),%eax
 80499c6:	80 78 01 25          	cmpb   $0x25,0x1(%eax)
 80499ca:	75 1c                	jne    80499e8 <cbvprintf+0x93>
		conv->specifier = *sp++;
 80499cc:	83 c0 02             	add    $0x2,%eax
 80499cf:	c6 45 c3 25          	movb   $0x25,-0x3d(%ebp)
 80499d3:	89 45 90             	mov    %eax,-0x70(%ebp)
		return sp;
 80499d6:	e9 52 02 00 00       	jmp    8049c2d <cbvprintf+0x2d8>
		switch (*sp) {
 80499db:	7e 16                	jle    80499f3 <cbvprintf+0x9e>
 80499dd:	3c 2d                	cmp    $0x2d,%al
 80499df:	75 1c                	jne    80499fd <cbvprintf+0xa8>
			conv->flag_dash = true;
 80499e1:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
			++sp;
 80499e5:	ff 45 90             	incl   -0x70(%ebp)
		switch (*sp) {
 80499e8:	8b 45 90             	mov    -0x70(%ebp),%eax
 80499eb:	8a 00                	mov    (%eax),%al
 80499ed:	3c 2b                	cmp    $0x2b,%al
 80499ef:	75 ea                	jne    80499db <cbvprintf+0x86>
 80499f1:	eb 23                	jmp    8049a16 <cbvprintf+0xc1>
 80499f3:	3c 20                	cmp    $0x20,%al
 80499f5:	74 25                	je     8049a1c <cbvprintf+0xc7>
 80499f7:	3c 23                	cmp    $0x23,%al
 80499f9:	74 27                	je     8049a22 <cbvprintf+0xcd>
 80499fb:	eb 04                	jmp    8049a01 <cbvprintf+0xac>
 80499fd:	3c 30                	cmp    $0x30,%al
 80499ff:	74 27                	je     8049a28 <cbvprintf+0xd3>
	if (conv->flag_zero && conv->flag_dash) {
 8049a01:	8a 45 c0             	mov    -0x40(%ebp),%al
 8049a04:	89 c2                	mov    %eax,%edx
 8049a06:	83 e2 44             	and    $0x44,%edx
 8049a09:	80 fa 44             	cmp    $0x44,%dl
 8049a0c:	75 20                	jne    8049a2e <cbvprintf+0xd9>
		conv->flag_zero = false;
 8049a0e:	83 e0 bf             	and    $0xffffffbf,%eax
 8049a11:	88 45 c0             	mov    %al,-0x40(%ebp)
 8049a14:	eb 18                	jmp    8049a2e <cbvprintf+0xd9>
			conv->flag_plus = true;
 8049a16:	80 4d c0 08          	orb    $0x8,-0x40(%ebp)
			break;
 8049a1a:	eb c9                	jmp    80499e5 <cbvprintf+0x90>
			conv->flag_space = true;
 8049a1c:	80 4d c0 10          	orb    $0x10,-0x40(%ebp)
			break;
 8049a20:	eb c3                	jmp    80499e5 <cbvprintf+0x90>
			conv->flag_hash = true;
 8049a22:	80 4d c0 20          	orb    $0x20,-0x40(%ebp)
			break;
 8049a26:	eb bd                	jmp    80499e5 <cbvprintf+0x90>
			conv->flag_zero = true;
 8049a28:	80 4d c0 40          	orb    $0x40,-0x40(%ebp)
			break;
 8049a2c:	eb b7                	jmp    80499e5 <cbvprintf+0x90>
	sp = extract_width(conv, sp);
 8049a2e:	8b 45 90             	mov    -0x70(%ebp),%eax
	conv->width_present = true;
 8049a31:	80 4d c0 80          	orb    $0x80,-0x40(%ebp)
 8049a35:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (*sp == '*') {
 8049a38:	80 38 2a             	cmpb   $0x2a,(%eax)
 8049a3b:	75 09                	jne    8049a46 <cbvprintf+0xf1>
		return ++sp;
 8049a3d:	89 c2                	mov    %eax,%edx
		conv->width_star = true;
 8049a3f:	80 4d c1 01          	orb    $0x1,-0x3f(%ebp)
		return ++sp;
 8049a43:	42                   	inc    %edx
 8049a44:	eb 30                	jmp    8049a76 <cbvprintf+0x121>
	size_t width = extract_decimal(&sp);
 8049a46:	8d 45 b0             	lea    -0x50(%ebp),%eax
 8049a49:	e8 f5 fd ff ff       	call   8049843 <extract_decimal>
	if (sp != wp) {
 8049a4e:	8b 55 b0             	mov    -0x50(%ebp),%edx
 8049a51:	3b 55 90             	cmp    -0x70(%ebp),%edx
 8049a54:	74 20                	je     8049a76 <cbvprintf+0x121>
		conv->unsupported |= ((conv->width_value < 0)
 8049a56:	8a 4d c0             	mov    -0x40(%ebp),%cl
		conv->width_value = width;
 8049a59:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				      || (width != (size_t)conv->width_value));
 8049a5c:	c1 e8 1f             	shr    $0x1f,%eax
		conv->unsupported |= ((conv->width_value < 0)
 8049a5f:	d0 e9                	shr    %cl
 8049a61:	83 e1 01             	and    $0x1,%ecx
 8049a64:	09 c8                	or     %ecx,%eax
 8049a66:	8a 4d c0             	mov    -0x40(%ebp),%cl
 8049a69:	01 c0                	add    %eax,%eax
 8049a6b:	83 c8 80             	or     $0xffffff80,%eax
 8049a6e:	83 e1 7d             	and    $0x7d,%ecx
 8049a71:	09 c8                	or     %ecx,%eax
 8049a73:	88 45 c0             	mov    %al,-0x40(%ebp)
	sp = extract_prec(conv, sp);
 8049a76:	89 55 b0             	mov    %edx,-0x50(%ebp)
	conv->prec_present = (*sp == '.');
 8049a79:	8a 0a                	mov    (%edx),%cl
 8049a7b:	80 f9 2e             	cmp    $0x2e,%cl
 8049a7e:	0f 94 c0             	sete   %al
 8049a81:	8d 34 00             	lea    (%eax,%eax,1),%esi
 8049a84:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049a87:	83 e0 fd             	and    $0xfffffffd,%eax
 8049a8a:	09 f0                	or     %esi,%eax
 8049a8c:	88 45 c1             	mov    %al,-0x3f(%ebp)
	if (!conv->prec_present) {
 8049a8f:	80 f9 2e             	cmp    $0x2e,%cl
 8049a92:	75 3e                	jne    8049ad2 <cbvprintf+0x17d>
	++sp;
 8049a94:	8d 4a 01             	lea    0x1(%edx),%ecx
 8049a97:	89 4d b0             	mov    %ecx,-0x50(%ebp)
	if (*sp == '*') {
 8049a9a:	80 7a 01 2a          	cmpb   $0x2a,0x1(%edx)
 8049a9e:	75 0b                	jne    8049aab <cbvprintf+0x156>
		conv->prec_star = true;
 8049aa0:	83 c8 04             	or     $0x4,%eax
		return ++sp;
 8049aa3:	83 c2 02             	add    $0x2,%edx
		conv->prec_star = true;
 8049aa6:	88 45 c1             	mov    %al,-0x3f(%ebp)
		return ++sp;
 8049aa9:	eb 27                	jmp    8049ad2 <cbvprintf+0x17d>
	size_t prec = extract_decimal(&sp);
 8049aab:	8d 45 b0             	lea    -0x50(%ebp),%eax
 8049aae:	e8 90 fd ff ff       	call   8049843 <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
 8049ab3:	8a 55 c0             	mov    -0x40(%ebp),%dl
	conv->prec_value = prec;
 8049ab6:	89 45 c8             	mov    %eax,-0x38(%ebp)
			      || (prec != (size_t)conv->prec_value));
 8049ab9:	c1 e8 1f             	shr    $0x1f,%eax
	conv->unsupported |= ((conv->prec_value < 0)
 8049abc:	89 d1                	mov    %edx,%ecx
 8049abe:	83 e2 fd             	and    $0xfffffffd,%edx
 8049ac1:	d0 e9                	shr    %cl
 8049ac3:	83 e1 01             	and    $0x1,%ecx
 8049ac6:	09 c8                	or     %ecx,%eax
 8049ac8:	01 c0                	add    %eax,%eax
 8049aca:	09 c2                	or     %eax,%edx
 8049acc:	88 55 c0             	mov    %dl,-0x40(%ebp)
	return sp;
 8049acf:	8b 55 b0             	mov    -0x50(%ebp),%edx
	switch (*sp) {
 8049ad2:	8a 0a                	mov    (%edx),%cl
 8049ad4:	8d 72 01             	lea    0x1(%edx),%esi
 8049ad7:	80 f9 6c             	cmp    $0x6c,%cl
 8049ada:	74 50                	je     8049b2c <cbvprintf+0x1d7>
 8049adc:	7f 20                	jg     8049afe <cbvprintf+0x1a9>
 8049ade:	80 f9 68             	cmp    $0x68,%cl
 8049ae1:	74 30                	je     8049b13 <cbvprintf+0x1be>
 8049ae3:	80 f9 6a             	cmp    $0x6a,%cl
 8049ae6:	74 66                	je     8049b4e <cbvprintf+0x1f9>
 8049ae8:	80 f9 4c             	cmp    $0x4c,%cl
 8049aeb:	75 74                	jne    8049b61 <cbvprintf+0x20c>
		conv->unsupported = true;
 8049aed:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049af0:	66 25 fd 87          	and    $0x87fd,%ax
 8049af4:	66 0d 02 40          	or     $0x4002,%ax
 8049af8:	66 89 45 c0          	mov    %ax,-0x40(%ebp)
		break;
 8049afc:	eb 69                	jmp    8049b67 <cbvprintf+0x212>
	switch (*sp) {
 8049afe:	80 f9 74             	cmp    $0x74,%cl
 8049b01:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049b04:	74 53                	je     8049b59 <cbvprintf+0x204>
 8049b06:	80 f9 7a             	cmp    $0x7a,%cl
 8049b09:	75 56                	jne    8049b61 <cbvprintf+0x20c>
		conv->length_mod = LENGTH_Z;
 8049b0b:	83 e0 87             	and    $0xffffff87,%eax
 8049b0e:	83 c8 30             	or     $0x30,%eax
 8049b11:	eb 36                	jmp    8049b49 <cbvprintf+0x1f4>
		if (*++sp == 'h') {
 8049b13:	80 7a 01 68          	cmpb   $0x68,0x1(%edx)
 8049b17:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049b1a:	75 08                	jne    8049b24 <cbvprintf+0x1cf>
			conv->length_mod = LENGTH_HH;
 8049b1c:	83 e0 87             	and    $0xffffff87,%eax
 8049b1f:	83 c8 08             	or     $0x8,%eax
 8049b22:	eb 17                	jmp    8049b3b <cbvprintf+0x1e6>
			conv->length_mod = LENGTH_H;
 8049b24:	83 e0 87             	and    $0xffffff87,%eax
 8049b27:	83 c8 10             	or     $0x10,%eax
 8049b2a:	eb 1d                	jmp    8049b49 <cbvprintf+0x1f4>
		if (*++sp == 'l') {
 8049b2c:	80 7a 01 6c          	cmpb   $0x6c,0x1(%edx)
 8049b30:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049b33:	75 0e                	jne    8049b43 <cbvprintf+0x1ee>
			conv->length_mod = LENGTH_LL;
 8049b35:	83 e0 87             	and    $0xffffff87,%eax
 8049b38:	83 c8 20             	or     $0x20,%eax
 8049b3b:	88 45 c1             	mov    %al,-0x3f(%ebp)
			++sp;
 8049b3e:	8d 72 02             	lea    0x2(%edx),%esi
 8049b41:	eb 24                	jmp    8049b67 <cbvprintf+0x212>
			conv->length_mod = LENGTH_L;
 8049b43:	83 e0 87             	and    $0xffffff87,%eax
 8049b46:	83 c8 18             	or     $0x18,%eax
 8049b49:	88 45 c1             	mov    %al,-0x3f(%ebp)
 8049b4c:	eb 19                	jmp    8049b67 <cbvprintf+0x212>
		conv->length_mod = LENGTH_J;
 8049b4e:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049b51:	83 e0 87             	and    $0xffffff87,%eax
 8049b54:	83 c8 28             	or     $0x28,%eax
 8049b57:	eb f0                	jmp    8049b49 <cbvprintf+0x1f4>
		conv->length_mod = LENGTH_T;
 8049b59:	83 e0 87             	and    $0xffffff87,%eax
 8049b5c:	83 c8 38             	or     $0x38,%eax
 8049b5f:	eb e8                	jmp    8049b49 <cbvprintf+0x1f4>
		conv->length_mod = LENGTH_NONE;
 8049b61:	80 65 c1 87          	andb   $0x87,-0x3f(%ebp)
		break;
 8049b65:	89 d6                	mov    %edx,%esi
	conv->specifier = *sp++;
 8049b67:	8d 46 01             	lea    0x1(%esi),%eax
 8049b6a:	8a 55 c1             	mov    -0x3f(%ebp),%dl
 8049b6d:	89 45 90             	mov    %eax,-0x70(%ebp)
 8049b70:	8a 06                	mov    (%esi),%al
 8049b72:	88 45 c3             	mov    %al,-0x3d(%ebp)
	switch (conv->specifier) {
 8049b75:	3c 78                	cmp    $0x78,%al
 8049b77:	0f 8f 94 00 00 00    	jg     8049c11 <cbvprintf+0x2bc>
 8049b7d:	3c 57                	cmp    $0x57,%al
 8049b7f:	7f 11                	jg     8049b92 <cbvprintf+0x23d>
 8049b81:	3c 41                	cmp    $0x41,%al
 8049b83:	74 51                	je     8049bd6 <cbvprintf+0x281>
 8049b85:	83 e8 45             	sub    $0x45,%eax
 8049b88:	3c 02                	cmp    $0x2,%al
 8049b8a:	0f 87 81 00 00 00    	ja     8049c11 <cbvprintf+0x2bc>
 8049b90:	eb 44                	jmp    8049bd6 <cbvprintf+0x281>
 8049b92:	8d 48 a8             	lea    -0x58(%eax),%ecx
 8049b95:	80 f9 20             	cmp    $0x20,%cl
 8049b98:	77 77                	ja     8049c11 <cbvprintf+0x2bc>
 8049b9a:	0f b6 c9             	movzbl %cl,%ecx
 8049b9d:	3e ff 24 8d 04 e0 04 	notrack jmp *0x804e004(,%ecx,4)
 8049ba4:	08 
		conv->specifier_cat = SPECIFIER_SINT;
 8049ba5:	8a 4d c2             	mov    -0x3e(%ebp),%cl
 8049ba8:	83 e1 f8             	and    $0xfffffff8,%ecx
 8049bab:	83 c9 01             	or     $0x1,%ecx
 8049bae:	eb 09                	jmp    8049bb9 <cbvprintf+0x264>
		conv->specifier_cat = SPECIFIER_UINT;
 8049bb0:	8a 4d c2             	mov    -0x3e(%ebp),%cl
 8049bb3:	83 e1 f8             	and    $0xfffffff8,%ecx
 8049bb6:	83 c9 02             	or     $0x2,%ecx
 8049bb9:	f3 0f 1e fb          	endbr32 
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049bbd:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_UINT;
 8049bc0:	88 4d c2             	mov    %cl,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049bc3:	80 fa 40             	cmp    $0x40,%dl
 8049bc6:	75 04                	jne    8049bcc <cbvprintf+0x277>
			conv->invalid = true;
 8049bc8:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
 8049bcc:	31 c9                	xor    %ecx,%ecx
		if (conv->specifier == 'c') {
 8049bce:	3c 63                	cmp    $0x63,%al
 8049bd0:	75 45                	jne    8049c17 <cbvprintf+0x2c2>
			unsupported = (conv->length_mod != LENGTH_NONE);
 8049bd2:	84 d2                	test   %dl,%dl
 8049bd4:	eb 36                	jmp    8049c0c <cbvprintf+0x2b7>
		conv->specifier_cat = SPECIFIER_FP;
 8049bd6:	8a 45 c2             	mov    -0x3e(%ebp),%al
			unsupported = true;
 8049bd9:	b1 01                	mov    $0x1,%cl
		conv->specifier_cat = SPECIFIER_FP;
 8049bdb:	83 e0 f8             	and    $0xfffffff8,%eax
 8049bde:	83 c8 04             	or     $0x4,%eax
 8049be1:	88 45 c2             	mov    %al,-0x3e(%ebp)
			break;
 8049be4:	eb 31                	jmp    8049c17 <cbvprintf+0x2c2>
		conv->specifier_cat = SPECIFIER_PTR;
 8049be6:	8a 45 c2             	mov    -0x3e(%ebp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049be9:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_PTR;
 8049bec:	83 e0 f8             	and    $0xfffffff8,%eax
 8049bef:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049bf2:	80 fa 40             	cmp    $0x40,%dl
		conv->specifier_cat = SPECIFIER_PTR;
 8049bf5:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049bf8:	0f 94 c1             	sete   %cl
 8049bfb:	eb 1a                	jmp    8049c17 <cbvprintf+0x2c2>
		conv->specifier_cat = SPECIFIER_PTR;
 8049bfd:	8a 45 c2             	mov    -0x3e(%ebp),%al
 8049c00:	83 e0 f8             	and    $0xfffffff8,%eax
 8049c03:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
 8049c06:	80 e2 78             	and    $0x78,%dl
		conv->specifier_cat = SPECIFIER_PTR;
 8049c09:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod != LENGTH_NONE) {
 8049c0c:	0f 95 c1             	setne  %cl
 8049c0f:	eb 06                	jmp    8049c17 <cbvprintf+0x2c2>
		conv->invalid = true;
 8049c11:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
 8049c15:	31 c9                	xor    %ecx,%ecx
	conv->unsupported |= unsupported;
 8049c17:	8a 55 c0             	mov    -0x40(%ebp),%dl
 8049c1a:	89 d0                	mov    %edx,%eax
 8049c1c:	83 e2 fd             	and    $0xfffffffd,%edx
 8049c1f:	d0 e8                	shr    %al
 8049c21:	83 e0 01             	and    $0x1,%eax
 8049c24:	09 c8                	or     %ecx,%eax
 8049c26:	01 c0                	add    %eax,%eax
 8049c28:	09 d0                	or     %edx,%eax
 8049c2a:	88 45 c0             	mov    %al,-0x40(%ebp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
 8049c2d:	8a 55 c1             	mov    -0x3f(%ebp),%dl
 8049c30:	f6 c2 01             	test   $0x1,%dl
 8049c33:	74 15                	je     8049c4a <cbvprintf+0x2f5>
			width = va_arg(ap, int);
 8049c35:	8d 43 04             	lea    0x4(%ebx),%eax
 8049c38:	8b 1b                	mov    (%ebx),%ebx
 8049c3a:	89 5d a0             	mov    %ebx,-0x60(%ebp)

			if (width < 0) {
 8049c3d:	85 db                	test   %ebx,%ebx
 8049c3f:	79 22                	jns    8049c63 <cbvprintf+0x30e>
				conv->flag_dash = true;
 8049c41:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
				width = -width;
 8049c45:	f7 5d a0             	negl   -0x60(%ebp)
 8049c48:	eb 19                	jmp    8049c63 <cbvprintf+0x30e>
			}
		} else if (conv->width_present) {
 8049c4a:	80 7d c0 00          	cmpb   $0x0,-0x40(%ebp)
 8049c4e:	79 0a                	jns    8049c5a <cbvprintf+0x305>
			width = conv->width_value;
 8049c50:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8049c53:	89 45 a0             	mov    %eax,-0x60(%ebp)
 8049c56:	89 d8                	mov    %ebx,%eax
 8049c58:	eb 09                	jmp    8049c63 <cbvprintf+0x30e>
		int width = -1;
 8049c5a:	c7 45 a0 ff ff ff ff 	movl   $0xffffffff,-0x60(%ebp)
 8049c61:	89 d8                	mov    %ebx,%eax

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
 8049c63:	f6 c2 04             	test   $0x4,%dl
 8049c66:	74 0f                	je     8049c77 <cbvprintf+0x322>
			int arg = va_arg(ap, int);
 8049c68:	8b 38                	mov    (%eax),%edi
 8049c6a:	8d 58 04             	lea    0x4(%eax),%ebx

			if (arg < 0) {
 8049c6d:	85 ff                	test   %edi,%edi
 8049c6f:	79 17                	jns    8049c88 <cbvprintf+0x333>
				conv->prec_present = false;
 8049c71:	80 65 c1 fd          	andb   $0xfd,-0x3f(%ebp)
 8049c75:	eb 0e                	jmp    8049c85 <cbvprintf+0x330>
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
 8049c77:	80 e2 02             	and    $0x2,%dl
 8049c7a:	74 07                	je     8049c83 <cbvprintf+0x32e>
			precision = conv->prec_value;
 8049c7c:	8b 7d c8             	mov    -0x38(%ebp),%edi
 8049c7f:	89 c3                	mov    %eax,%ebx
 8049c81:	eb 05                	jmp    8049c88 <cbvprintf+0x333>
 8049c83:	89 c3                	mov    %eax,%ebx
		int precision = -1;
 8049c85:	83 cf ff             	or     $0xffffffff,%edi
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
 8049c88:	8a 45 c1             	mov    -0x3f(%ebp),%al
			= (enum specifier_cat_enum)conv->specifier_cat;
 8049c8b:	8a 55 c2             	mov    -0x3e(%ebp),%dl
		conv->pad0_value = 0;
 8049c8e:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		conv->pad0_pre_exp = 0;
 8049c95:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
			= (enum length_mod_enum)conv->length_mod;
 8049c9c:	c0 e8 03             	shr    $0x3,%al
		enum specifier_cat_enum specifier_cat
 8049c9f:	83 e2 07             	and    $0x7,%edx
			= (enum length_mod_enum)conv->length_mod;
 8049ca2:	83 e0 0f             	and    $0xf,%eax
		enum length_mod_enum length_mod
 8049ca5:	0f b6 c8             	movzbl %al,%ecx
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
 8049ca8:	83 fa 01             	cmp    $0x1,%edx
 8049cab:	75 1f                	jne    8049ccc <cbvprintf+0x377>
			switch (length_mod) {
 8049cad:	3c 05                	cmp    $0x5,%al
 8049caf:	74 28                	je     8049cd9 <cbvprintf+0x384>
 8049cb1:	77 39                	ja     8049cec <cbvprintf+0x397>
 8049cb3:	3c 03                	cmp    $0x3,%al
 8049cb5:	74 06                	je     8049cbd <cbvprintf+0x368>
 8049cb7:	3c 04                	cmp    $0x4,%al
 8049cb9:	74 1e                	je     8049cd9 <cbvprintf+0x384>
 8049cbb:	eb 2f                	jmp    8049cec <cbvprintf+0x397>
				if (WCHAR_IS_SIGNED
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->sint = va_arg(ap, long);
 8049cbd:	8b 0b                	mov    (%ebx),%ecx
 8049cbf:	8d 53 04             	lea    0x4(%ebx),%edx
 8049cc2:	89 cb                	mov    %ecx,%ebx
 8049cc4:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
 8049cc7:	c1 fb 1f             	sar    $0x1f,%ebx
 8049cca:	eb 18                	jmp    8049ce4 <cbvprintf+0x38f>
			if (length_mod == LENGTH_HH) {
				value->sint = (char)value->sint;
			} else if (length_mod == LENGTH_H) {
				value->sint = (short)value->sint;
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
 8049ccc:	83 fa 02             	cmp    $0x2,%edx
 8049ccf:	0f 85 97 00 00 00    	jne    8049d6c <cbvprintf+0x417>
			switch (length_mod) {
 8049cd5:	3c 05                	cmp    $0x5,%al
 8049cd7:	75 44                	jne    8049d1d <cbvprintf+0x3c8>
				value->sint =
 8049cd9:	8b 0b                	mov    (%ebx),%ecx
					(sint_value_type)va_arg(ap, long long);
 8049cdb:	8d 53 08             	lea    0x8(%ebx),%edx
				value->sint =
 8049cde:	8b 5b 04             	mov    0x4(%ebx),%ebx
 8049ce1:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
 8049ce4:	89 5d b8             	mov    %ebx,-0x48(%ebp)
				break;
 8049ce7:	e9 31 04 00 00       	jmp    804a11d <cbvprintf+0x7c8>
					(sint_value_type)va_arg(ap, ptrdiff_t);
 8049cec:	8b 13                	mov    (%ebx),%edx
 8049cee:	83 c3 04             	add    $0x4,%ebx
 8049cf1:	89 55 b4             	mov    %edx,-0x4c(%ebp)
 8049cf4:	c1 fa 1f             	sar    $0x1f,%edx
 8049cf7:	89 55 b8             	mov    %edx,-0x48(%ebp)
			if (length_mod == LENGTH_HH) {
 8049cfa:	83 f9 01             	cmp    $0x1,%ecx
 8049cfd:	75 06                	jne    8049d05 <cbvprintf+0x3b0>
				value->sint = (char)value->sint;
 8049cff:	0f be 55 b4          	movsbl -0x4c(%ebp),%edx
 8049d03:	eb 0d                	jmp    8049d12 <cbvprintf+0x3bd>
			} else if (length_mod == LENGTH_H) {
 8049d05:	83 f9 02             	cmp    $0x2,%ecx
 8049d08:	0f 85 89 00 00 00    	jne    8049d97 <cbvprintf+0x442>
				value->sint = (short)value->sint;
 8049d0e:	0f bf 55 b4          	movswl -0x4c(%ebp),%edx
 8049d12:	89 55 b4             	mov    %edx,-0x4c(%ebp)
 8049d15:	c1 fa 1f             	sar    $0x1f,%edx
 8049d18:	89 55 b8             	mov    %edx,-0x48(%ebp)
 8049d1b:	eb 7a                	jmp    8049d97 <cbvprintf+0x442>
			switch (length_mod) {
 8049d1d:	77 1e                	ja     8049d3d <cbvprintf+0x3e8>
 8049d1f:	3c 03                	cmp    $0x3,%al
 8049d21:	74 06                	je     8049d29 <cbvprintf+0x3d4>
 8049d23:	3c 04                	cmp    $0x4,%al
 8049d25:	74 b2                	je     8049cd9 <cbvprintf+0x384>
 8049d27:	eb 14                	jmp    8049d3d <cbvprintf+0x3e8>
				if ((!WCHAR_IS_SIGNED)
				    && (conv->specifier == 'c')) {
					value->uint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->uint = va_arg(ap, unsigned long);
 8049d29:	8d 53 04             	lea    0x4(%ebx),%edx
 8049d2c:	8b 1b                	mov    (%ebx),%ebx
 8049d2e:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 8049d35:	89 5d b4             	mov    %ebx,-0x4c(%ebp)
				}
				break;
 8049d38:	e9 e0 03 00 00       	jmp    804a11d <cbvprintf+0x7c8>
								uintmax_t);
				break;
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
 8049d3d:	8b 33                	mov    (%ebx),%esi
 8049d3f:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 8049d46:	83 c3 04             	add    $0x4,%ebx
 8049d49:	89 75 b4             	mov    %esi,-0x4c(%ebp)
				break;
			}
			if (length_mod == LENGTH_HH) {
 8049d4c:	83 f9 01             	cmp    $0x1,%ecx
 8049d4f:	75 06                	jne    8049d57 <cbvprintf+0x402>
				value->uint = (unsigned char)value->uint;
 8049d51:	0f b6 55 b4          	movzbl -0x4c(%ebp),%edx
 8049d55:	eb 09                	jmp    8049d60 <cbvprintf+0x40b>
			} else if (length_mod == LENGTH_H) {
 8049d57:	83 f9 02             	cmp    $0x2,%ecx
 8049d5a:	75 3b                	jne    8049d97 <cbvprintf+0x442>
				value->uint = (unsigned short)value->uint;
 8049d5c:	0f b7 55 b4          	movzwl -0x4c(%ebp),%edx
 8049d60:	89 55 b4             	mov    %edx,-0x4c(%ebp)
 8049d63:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 8049d6a:	eb 2b                	jmp    8049d97 <cbvprintf+0x442>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
 8049d6c:	83 fa 04             	cmp    $0x4,%edx
 8049d6f:	75 19                	jne    8049d8a <cbvprintf+0x435>
			if (length_mod == LENGTH_UPPER_L) {
 8049d71:	83 f9 08             	cmp    $0x8,%ecx
 8049d74:	75 0a                	jne    8049d80 <cbvprintf+0x42b>
				value->ldbl = va_arg(ap, long double);
 8049d76:	db 2b                	fldt   (%ebx)
 8049d78:	83 c3 0c             	add    $0xc,%ebx
 8049d7b:	db 7d b4             	fstpt  -0x4c(%ebp)
 8049d7e:	eb 17                	jmp    8049d97 <cbvprintf+0x442>
			} else {
				value->dbl = va_arg(ap, double);
 8049d80:	dd 03                	fldl   (%ebx)
 8049d82:	83 c3 08             	add    $0x8,%ebx
 8049d85:	dd 5d b4             	fstpl  -0x4c(%ebp)
 8049d88:	eb 0d                	jmp    8049d97 <cbvprintf+0x442>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
 8049d8a:	83 fa 03             	cmp    $0x3,%edx
 8049d8d:	75 08                	jne    8049d97 <cbvprintf+0x442>
			value->ptr = va_arg(ap, void *);
 8049d8f:	8b 13                	mov    (%ebx),%edx
 8049d91:	83 c3 04             	add    $0x4,%ebx
 8049d94:	89 55 b4             	mov    %edx,-0x4c(%ebp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
 8049d97:	8a 55 c0             	mov    -0x40(%ebp),%dl
 8049d9a:	f6 c2 03             	test   $0x3,%dl
 8049d9d:	74 27                	je     8049dc6 <cbvprintf+0x471>
			OUTS(sp, fp);
 8049d9f:	83 ec 0c             	sub    $0xc,%esp
 8049da2:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
 8049da5:	8b 55 94             	mov    -0x6c(%ebp),%edx
 8049da8:	ff 75 90             	pushl  -0x70(%ebp)
 8049dab:	8b 45 98             	mov    -0x68(%ebp),%eax
 8049dae:	e8 45 fa ff ff       	call   80497f8 <outs>
 8049db3:	83 c4 10             	add    $0x10,%esp
 8049db6:	85 c0                	test   %eax,%eax
 8049db8:	0f 88 66 03 00 00    	js     804a124 <cbvprintf+0x7cf>
 8049dbe:	01 45 a4             	add    %eax,-0x5c(%ebp)
			continue;
 8049dc1:	e9 47 03 00 00       	jmp    804a10d <cbvprintf+0x7b8>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
 8049dc6:	8a 4d c3             	mov    -0x3d(%ebp),%cl
 8049dc9:	80 f9 78             	cmp    $0x78,%cl
 8049dcc:	0f 87 3b 03 00 00    	ja     804a10d <cbvprintf+0x7b8>
 8049dd2:	80 f9 62             	cmp    $0x62,%cl
 8049dd5:	77 13                	ja     8049dea <cbvprintf+0x495>
 8049dd7:	80 f9 25             	cmp    $0x25,%cl
 8049dda:	74 25                	je     8049e01 <cbvprintf+0x4ac>
 8049ddc:	80 f9 58             	cmp    $0x58,%cl
 8049ddf:	0f 84 bb 00 00 00    	je     8049ea0 <cbvprintf+0x54b>
 8049de5:	e9 23 03 00 00       	jmp    804a10d <cbvprintf+0x7b8>
 8049dea:	83 e9 63             	sub    $0x63,%ecx
 8049ded:	80 f9 15             	cmp    $0x15,%cl
 8049df0:	0f 87 17 03 00 00    	ja     804a10d <cbvprintf+0x7b8>
 8049df6:	0f b6 c9             	movzbl %cl,%ecx
 8049df9:	3e ff 24 8d 88 e0 04 	notrack jmp *0x804e088(,%ecx,4)
 8049e00:	08 
		case '%':
			OUTC('%');
 8049e01:	51                   	push   %ecx
 8049e02:	51                   	push   %ecx
 8049e03:	ff 75 94             	pushl  -0x6c(%ebp)
 8049e06:	6a 25                	push   $0x25
 8049e08:	8b 45 98             	mov    -0x68(%ebp),%eax
 8049e0b:	ff d0                	call   *%eax
 8049e0d:	83 c4 10             	add    $0x10,%esp
 8049e10:	85 c0                	test   %eax,%eax
 8049e12:	0f 88 0c 03 00 00    	js     804a124 <cbvprintf+0x7cf>
 8049e18:	ff 45 a4             	incl   -0x5c(%ebp)
			break;
 8049e1b:	e9 ed 02 00 00       	jmp    804a10d <cbvprintf+0x7b8>
		case 's': {
			bps = (const char *)value->ptr;
 8049e20:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8049e23:	89 45 9c             	mov    %eax,-0x64(%ebp)

			size_t len;

			if (precision >= 0) {
 8049e26:	85 ff                	test   %edi,%edi
 8049e28:	78 0e                	js     8049e38 <cbvprintf+0x4e3>
				len = strnlen(bps, precision);
 8049e2a:	52                   	push   %edx
 8049e2b:	52                   	push   %edx
 8049e2c:	57                   	push   %edi
 8049e2d:	50                   	push   %eax
 8049e2e:	e8 5d f6 ff ff       	call   8049490 <strnlen@plt>
 8049e33:	83 c4 10             	add    $0x10,%esp
 8049e36:	eb 0f                	jmp    8049e47 <cbvprintf+0x4f2>
			} else {
				len = strlen(bps);
 8049e38:	8b 7d 9c             	mov    -0x64(%ebp),%edi
 8049e3b:	31 c0                	xor    %eax,%eax
 8049e3d:	83 c9 ff             	or     $0xffffffff,%ecx
 8049e40:	f2 ae                	repnz scas %es:(%edi),%al
 8049e42:	89 c8                	mov    %ecx,%eax
 8049e44:	f7 d0                	not    %eax
 8049e46:	48                   	dec    %eax
			}

			bpe = bps + len;
 8049e47:	03 45 9c             	add    -0x64(%ebp),%eax
		char sign = 0;
 8049e4a:	31 f6                	xor    %esi,%esi
			bpe = bps + len;
 8049e4c:	89 45 8c             	mov    %eax,-0x74(%ebp)
			precision = -1;

			break;
 8049e4f:	e9 16 01 00 00       	jmp    8049f6a <cbvprintf+0x615>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 8049e54:	8b 45 b4             	mov    -0x4c(%ebp),%eax
			bpe = buf + 1;
			break;
 8049e57:	31 f6                	xor    %esi,%esi
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 8049e59:	88 45 ce             	mov    %al,-0x32(%ebp)
			bpe = buf + 1;
 8049e5c:	8d 45 cf             	lea    -0x31(%ebp),%eax
 8049e5f:	89 45 8c             	mov    %eax,-0x74(%ebp)
			bps = buf;
 8049e62:	8d 45 ce             	lea    -0x32(%ebp),%eax
 8049e65:	89 45 9c             	mov    %eax,-0x64(%ebp)
			break;
 8049e68:	e9 18 01 00 00       	jmp    8049f85 <cbvprintf+0x630>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
				sign = '+';
 8049e6d:	be 2b 00 00 00       	mov    $0x2b,%esi
			if (conv->flag_plus) {
 8049e72:	f6 c2 08             	test   $0x8,%dl
 8049e75:	75 0b                	jne    8049e82 <cbvprintf+0x52d>
			} else if (conv->flag_space) {
				sign = ' ';
 8049e77:	80 e2 10             	and    $0x10,%dl
 8049e7a:	0f 95 c0             	setne  %al
 8049e7d:	c1 e0 05             	shl    $0x5,%eax
 8049e80:	89 c6                	mov    %eax,%esi

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
 8049e82:	8b 55 b8             	mov    -0x48(%ebp),%edx
 8049e85:	8b 45 b4             	mov    -0x4c(%ebp),%eax
			if (sint < 0) {
 8049e88:	85 d2                	test   %edx,%edx
 8049e8a:	79 16                	jns    8049ea2 <cbvprintf+0x54d>
				sign = '-';
				value->uint = (uint_value_type)-sint;
 8049e8c:	f7 d8                	neg    %eax
				sign = '-';
 8049e8e:	be 2d 00 00 00       	mov    $0x2d,%esi
				value->uint = (uint_value_type)-sint;
 8049e93:	83 d2 00             	adc    $0x0,%edx
 8049e96:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 8049e99:	f7 da                	neg    %edx
 8049e9b:	89 55 b8             	mov    %edx,-0x48(%ebp)
 8049e9e:	eb 02                	jmp    8049ea2 <cbvprintf+0x54d>
		switch (conv->specifier) {
 8049ea0:	31 f6                	xor    %esi,%esi
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
 8049ea2:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 8049ea5:	50                   	push   %eax
 8049ea6:	8d 4d c0             	lea    -0x40(%ebp),%ecx
 8049ea9:	50                   	push   %eax
 8049eaa:	8d 45 ce             	lea    -0x32(%ebp),%eax
 8049ead:	52                   	push   %edx
 8049eae:	8b 55 b8             	mov    -0x48(%ebp),%edx
 8049eb1:	50                   	push   %eax
 8049eb2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8049eb5:	e8 c0 f9 ff ff       	call   804987a <encode_uint>
 8049eba:	83 c4 10             	add    $0x10,%esp
 8049ebd:	89 45 9c             	mov    %eax,-0x64(%ebp)
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
 8049ec0:	85 ff                	test   %edi,%edi
 8049ec2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049ec5:	0f 88 9c 00 00 00    	js     8049f67 <cbvprintf+0x612>
				size_t len = bpe - bps;
 8049ecb:	89 c2                	mov    %eax,%edx
 8049ecd:	2b 55 9c             	sub    -0x64(%ebp),%edx

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv->flag_zero = false;
 8049ed0:	80 65 c0 bf          	andb   $0xbf,-0x40(%ebp)
		const char *bpe = buf + sizeof(buf);
 8049ed4:	89 45 8c             	mov    %eax,-0x74(%ebp)

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
 8049ed7:	39 d7                	cmp    %edx,%edi
 8049ed9:	0f 86 8b 00 00 00    	jbe    8049f6a <cbvprintf+0x615>
					conv->pad0_value = precision - (int)len;
 8049edf:	29 d7                	sub    %edx,%edi
 8049ee1:	89 7d c4             	mov    %edi,-0x3c(%ebp)
 8049ee4:	e9 81 00 00 00       	jmp    8049f6a <cbvprintf+0x615>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
 8049ee9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8049eec:	85 c0                	test   %eax,%eax
 8049eee:	0f 84 81 00 00 00    	je     8049f75 <cbvprintf+0x620>
				bps = encode_uint((uintptr_t)value->ptr, conv,
 8049ef4:	8d 75 e4             	lea    -0x1c(%ebp),%esi
 8049ef7:	51                   	push   %ecx
 8049ef8:	31 d2                	xor    %edx,%edx
 8049efa:	51                   	push   %ecx
 8049efb:	8d 4d ce             	lea    -0x32(%ebp),%ecx
 8049efe:	56                   	push   %esi
		char sign = 0;
 8049eff:	31 f6                	xor    %esi,%esi
				bps = encode_uint((uintptr_t)value->ptr, conv,
 8049f01:	51                   	push   %ecx
 8049f02:	8d 4d c0             	lea    -0x40(%ebp),%ecx
 8049f05:	e8 70 f9 ff ff       	call   804987a <encode_uint>
 8049f0a:	83 c4 10             	add    $0x10,%esp
 8049f0d:	89 45 9c             	mov    %eax,-0x64(%ebp)
						  buf, bpe);

				/* Use 0x prefix */
				conv->altform_0c = true;
 8049f10:	66 8b 45 c2          	mov    -0x3e(%ebp),%ax
 8049f14:	66 25 ef 00          	and    $0xef,%ax
 8049f18:	66 0d 10 78          	or     $0x7810,%ax
 8049f1c:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
				conv->specifier = 'x';

				goto prec_int_pad0;
 8049f20:	eb 9e                	jmp    8049ec0 <cbvprintf+0x56b>
			bpe = bps + 5;

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
 8049f22:	8b 55 b4             	mov    -0x4c(%ebp),%edx
	switch ((enum length_mod_enum)conv->length_mod) {
 8049f25:	3c 07                	cmp    $0x7,%al
 8049f27:	0f 87 e0 01 00 00    	ja     804a10d <cbvprintf+0x7b8>
 8049f2d:	0f b6 c0             	movzbl %al,%eax
 8049f30:	3e ff 24 85 e0 e0 04 	notrack jmp *0x804e0e0(,%eax,4)
 8049f37:	08 
		*(signed char *)dp = (signed char)count;
 8049f38:	8a 45 a4             	mov    -0x5c(%ebp),%al
 8049f3b:	88 02                	mov    %al,(%edx)
		break;
 8049f3d:	e9 cb 01 00 00       	jmp    804a10d <cbvprintf+0x7b8>
		*(short *)dp = (short)count;
 8049f42:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8049f45:	66 89 02             	mov    %ax,(%edx)
		break;
 8049f48:	e9 c0 01 00 00       	jmp    804a10d <cbvprintf+0x7b8>
		*(intmax_t *)dp = (intmax_t)count;
 8049f4d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8049f50:	89 02                	mov    %eax,(%edx)
 8049f52:	c1 f8 1f             	sar    $0x1f,%eax
 8049f55:	89 42 04             	mov    %eax,0x4(%edx)
		break;
 8049f58:	e9 b0 01 00 00       	jmp    804a10d <cbvprintf+0x7b8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
 8049f5d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8049f60:	89 02                	mov    %eax,(%edx)
		break;
 8049f62:	e9 a6 01 00 00       	jmp    804a10d <cbvprintf+0x7b8>
		const char *bpe = buf + sizeof(buf);
 8049f67:	89 45 8c             	mov    %eax,-0x74(%ebp)
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
 8049f6a:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
 8049f6e:	75 15                	jne    8049f85 <cbvprintf+0x630>
 8049f70:	e9 98 01 00 00       	jmp    804a10d <cbvprintf+0x7b8>
			bpe = bps + 5;
 8049f75:	c7 45 8c ca e1 04 08 	movl   $0x804e1ca,-0x74(%ebp)
 8049f7c:	31 f6                	xor    %esi,%esi
			bps = "(nil)";
 8049f7e:	c7 45 9c c5 e1 04 08 	movl   $0x804e1c5,-0x64(%ebp)
		 */
		size_t nj_len = (bpe - bps);
		int pad_len = 0;

		if (sign != 0) {
			nj_len += 1U;
 8049f85:	89 f1                	mov    %esi,%ecx
		}

		if (conv->altform_0c) {
 8049f87:	8a 55 c2             	mov    -0x3e(%ebp),%dl
		size_t nj_len = (bpe - bps);
 8049f8a:	8b 45 8c             	mov    -0x74(%ebp),%eax
 8049f8d:	2b 45 9c             	sub    -0x64(%ebp),%eax
			nj_len += 1U;
 8049f90:	80 f9 01             	cmp    $0x1,%cl
 8049f93:	83 d8 ff             	sbb    $0xffffffff,%eax
		if (conv->altform_0c) {
 8049f96:	f6 c2 10             	test   $0x10,%dl
 8049f99:	74 05                	je     8049fa0 <cbvprintf+0x64b>
			nj_len += 2U;
 8049f9b:	83 c0 02             	add    $0x2,%eax
 8049f9e:	eb 0b                	jmp    8049fab <cbvprintf+0x656>
		} else if (conv->altform_0) {
 8049fa0:	89 d1                	mov    %edx,%ecx
 8049fa2:	83 e1 08             	and    $0x8,%ecx
			nj_len += 1U;
 8049fa5:	80 f9 01             	cmp    $0x1,%cl
 8049fa8:	83 d8 ff             	sbb    $0xffffffff,%eax
		}

		nj_len += conv->pad0_value;
 8049fab:	03 45 c4             	add    -0x3c(%ebp),%eax
		if (conv->pad_fp) {
 8049fae:	80 e2 40             	and    $0x40,%dl
 8049fb1:	74 03                	je     8049fb6 <cbvprintf+0x661>
			nj_len += conv->pad0_pre_exp;
 8049fb3:	03 45 c8             	add    -0x38(%ebp),%eax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
 8049fb6:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
 8049fba:	7e 7c                	jle    804a038 <cbvprintf+0x6e3>
			width -= (int)nj_len;
 8049fbc:	8b 7d a0             	mov    -0x60(%ebp),%edi
 8049fbf:	29 c7                	sub    %eax,%edi

			if (!conv->flag_dash) {
 8049fc1:	8a 45 c0             	mov    -0x40(%ebp),%al
 8049fc4:	a8 04                	test   $0x4,%al
 8049fc6:	75 6d                	jne    804a035 <cbvprintf+0x6e0>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
 8049fc8:	a8 40                	test   $0x40,%al
 8049fca:	74 26                	je     8049ff2 <cbvprintf+0x69d>
					if (sign != 0) {
 8049fcc:	89 f0                	mov    %esi,%eax
 8049fce:	84 c0                	test   %al,%al
 8049fd0:	74 27                	je     8049ff9 <cbvprintf+0x6a4>
						OUTC(sign);
 8049fd2:	0f be f0             	movsbl %al,%esi
 8049fd5:	52                   	push   %edx
 8049fd6:	8b 45 98             	mov    -0x68(%ebp),%eax
 8049fd9:	52                   	push   %edx
 8049fda:	ff 75 94             	pushl  -0x6c(%ebp)
 8049fdd:	56                   	push   %esi
 8049fde:	ff d0                	call   *%eax
 8049fe0:	83 c4 10             	add    $0x10,%esp
 8049fe3:	85 c0                	test   %eax,%eax
 8049fe5:	0f 88 39 01 00 00    	js     804a124 <cbvprintf+0x7cf>
 8049feb:	ff 45 a4             	incl   -0x5c(%ebp)
						sign = 0;
 8049fee:	31 f6                	xor    %esi,%esi
 8049ff0:	eb 07                	jmp    8049ff9 <cbvprintf+0x6a4>
				char pad = ' ';
 8049ff2:	ba 20 00 00 00       	mov    $0x20,%edx
 8049ff7:	eb 05                	jmp    8049ffe <cbvprintf+0x6a9>
					}
					pad = '0';
 8049ff9:	ba 30 00 00 00       	mov    $0x30,%edx
 8049ffe:	89 7d a0             	mov    %edi,-0x60(%ebp)
 804a001:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804a004:	8b 4d a0             	mov    -0x60(%ebp),%ecx
 804a007:	01 f8                	add    %edi,%eax
 804a009:	2b 45 a0             	sub    -0x60(%ebp),%eax
				}

				while (width-- > 0) {
 804a00c:	ff 4d a0             	decl   -0x60(%ebp)
 804a00f:	85 c9                	test   %ecx,%ecx
 804a011:	7e 1d                	jle    804a030 <cbvprintf+0x6db>
					OUTC(pad);
 804a013:	50                   	push   %eax
 804a014:	50                   	push   %eax
 804a015:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a018:	ff 75 94             	pushl  -0x6c(%ebp)
 804a01b:	52                   	push   %edx
 804a01c:	89 55 88             	mov    %edx,-0x78(%ebp)
 804a01f:	ff d0                	call   *%eax
 804a021:	8b 55 88             	mov    -0x78(%ebp),%edx
 804a024:	83 c4 10             	add    $0x10,%esp
 804a027:	85 c0                	test   %eax,%eax
 804a029:	79 d6                	jns    804a001 <cbvprintf+0x6ac>
 804a02b:	e9 f4 00 00 00       	jmp    804a124 <cbvprintf+0x7cf>
 804a030:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804a033:	eb 03                	jmp    804a038 <cbvprintf+0x6e3>
			width -= (int)nj_len;
 804a035:	89 7d a0             	mov    %edi,-0x60(%ebp)
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
 804a038:	89 f0                	mov    %esi,%eax
 804a03a:	84 c0                	test   %al,%al
 804a03c:	74 1c                	je     804a05a <cbvprintf+0x705>
			OUTC(sign);
 804a03e:	0f be f0             	movsbl %al,%esi
 804a041:	57                   	push   %edi
 804a042:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a045:	57                   	push   %edi
 804a046:	ff 75 94             	pushl  -0x6c(%ebp)
 804a049:	56                   	push   %esi
 804a04a:	ff d0                	call   *%eax
 804a04c:	83 c4 10             	add    $0x10,%esp
 804a04f:	85 c0                	test   %eax,%eax
 804a051:	0f 88 cd 00 00 00    	js     804a124 <cbvprintf+0x7cf>
 804a057:	ff 45 a4             	incl   -0x5c(%ebp)
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
 804a05a:	8a 45 c2             	mov    -0x3e(%ebp),%al
 804a05d:	a8 10                	test   $0x10,%al
 804a05f:	75 04                	jne    804a065 <cbvprintf+0x710>
 804a061:	a8 08                	test   $0x8,%al
 804a063:	74 1a                	je     804a07f <cbvprintf+0x72a>
				OUTC('0');
 804a065:	56                   	push   %esi
 804a066:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a069:	56                   	push   %esi
 804a06a:	ff 75 94             	pushl  -0x6c(%ebp)
 804a06d:	6a 30                	push   $0x30
 804a06f:	ff d0                	call   *%eax
 804a071:	83 c4 10             	add    $0x10,%esp
 804a074:	85 c0                	test   %eax,%eax
 804a076:	0f 88 a8 00 00 00    	js     804a124 <cbvprintf+0x7cf>
 804a07c:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			if (conv->altform_0c) {
 804a07f:	f6 45 c2 10          	testb  $0x10,-0x3e(%ebp)
 804a083:	74 1d                	je     804a0a2 <cbvprintf+0x74d>
				OUTC(conv->specifier);
 804a085:	0f b6 45 c3          	movzbl -0x3d(%ebp),%eax
 804a089:	51                   	push   %ecx
 804a08a:	51                   	push   %ecx
 804a08b:	ff 75 94             	pushl  -0x6c(%ebp)
 804a08e:	50                   	push   %eax
 804a08f:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a092:	ff d0                	call   *%eax
 804a094:	83 c4 10             	add    $0x10,%esp
 804a097:	85 c0                	test   %eax,%eax
 804a099:	0f 88 85 00 00 00    	js     804a124 <cbvprintf+0x7cf>
 804a09f:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			pad_len = conv->pad0_value;
 804a0a2:	8b 7d c4             	mov    -0x3c(%ebp),%edi
			while (pad_len-- > 0) {
 804a0a5:	8b 75 a4             	mov    -0x5c(%ebp),%esi
 804a0a8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804a0ab:	01 f8                	add    %edi,%eax
 804a0ad:	29 f0                	sub    %esi,%eax
 804a0af:	85 c0                	test   %eax,%eax
 804a0b1:	7e 16                	jle    804a0c9 <cbvprintf+0x774>
				OUTC('0');
 804a0b3:	52                   	push   %edx
 804a0b4:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a0b7:	52                   	push   %edx
 804a0b8:	ff 75 94             	pushl  -0x6c(%ebp)
 804a0bb:	6a 30                	push   $0x30
 804a0bd:	ff d0                	call   *%eax
 804a0bf:	83 c4 10             	add    $0x10,%esp
 804a0c2:	85 c0                	test   %eax,%eax
 804a0c4:	78 5e                	js     804a124 <cbvprintf+0x7cf>
 804a0c6:	46                   	inc    %esi
 804a0c7:	eb df                	jmp    804a0a8 <cbvprintf+0x753>
			}

			OUTS(bps, bpe);
 804a0c9:	83 ec 0c             	sub    $0xc,%esp
 804a0cc:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
 804a0cf:	8b 55 94             	mov    -0x6c(%ebp),%edx
 804a0d2:	ff 75 8c             	pushl  -0x74(%ebp)
 804a0d5:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a0d8:	e8 1b f7 ff ff       	call   80497f8 <outs>
 804a0dd:	83 c4 10             	add    $0x10,%esp
 804a0e0:	85 c0                	test   %eax,%eax
 804a0e2:	78 40                	js     804a124 <cbvprintf+0x7cf>
 804a0e4:	01 c6                	add    %eax,%esi
 804a0e6:	89 75 a4             	mov    %esi,-0x5c(%ebp)
		}

		/* Finish left justification */
		while (width > 0) {
 804a0e9:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804a0ec:	01 f0                	add    %esi,%eax
 804a0ee:	2b 45 a4             	sub    -0x5c(%ebp),%eax
 804a0f1:	85 c0                	test   %eax,%eax
 804a0f3:	7e 18                	jle    804a10d <cbvprintf+0x7b8>
			OUTC(' ');
 804a0f5:	50                   	push   %eax
 804a0f6:	50                   	push   %eax
 804a0f7:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a0fa:	ff 75 94             	pushl  -0x6c(%ebp)
 804a0fd:	6a 20                	push   $0x20
 804a0ff:	ff d0                	call   *%eax
 804a101:	83 c4 10             	add    $0x10,%esp
 804a104:	85 c0                	test   %eax,%eax
 804a106:	78 1c                	js     804a124 <cbvprintf+0x7cf>
 804a108:	ff 45 a4             	incl   -0x5c(%ebp)
 804a10b:	eb dc                	jmp    804a0e9 <cbvprintf+0x794>
			OUTS(bps, bpe);
 804a10d:	8b 45 90             	mov    -0x70(%ebp),%eax
 804a110:	89 45 9c             	mov    %eax,-0x64(%ebp)
 804a113:	e9 71 f8 ff ff       	jmp    8049989 <cbvprintf+0x34>
			--width;
		}
	}

	return count;
 804a118:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804a11b:	eb 07                	jmp    804a124 <cbvprintf+0x7cf>
					(uint_value_type)va_arg(ap, size_t);
 804a11d:	89 d3                	mov    %edx,%ebx
 804a11f:	e9 73 fc ff ff       	jmp    8049d97 <cbvprintf+0x442>
#undef OUTS
#undef OUTC
}
 804a124:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
 804a127:	65 33 1d 14 00 00 00 	xor    %gs:0x14,%ebx
 804a12e:	74 05                	je     804a135 <cbvprintf+0x7e0>
 804a130:	e8 5b f2 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804a135:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a138:	5b                   	pop    %ebx
 804a139:	5e                   	pop    %esi
 804a13a:	5f                   	pop    %edi
 804a13b:	5d                   	pop    %ebp
 804a13c:	c3                   	ret    

0804a13d <_ConfigAbsSyms>:

/* file is auto-generated, do not modify ! */

#include <zephyr/toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
 804a13d:	f3 0f 1e fb          	endbr32 
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_LEGACY_INCLUDE_PATH, 1);

GEN_ABS_SYM_END
 804a141:	c3                   	ret    

0804a142 <__cxa_atexit>:
 * do not need to be deleted
 *
 * @retval 0 on success.
 */
int __cxa_atexit(void (*destructor)(void *), void *objptr, void *dso)
{
 804a142:	f3 0f 1e fb          	endbr32 
	ARG_UNUSED(destructor);
	ARG_UNUSED(objptr);
	ARG_UNUSED(dso);
	return 0;
}
 804a146:	31 c0                	xor    %eax,%eax
 804a148:	c3                   	ret    

0804a149 <sys_trace_isr_enter>:

#include <zephyr/init.h>
#include <string.h>
#include <zephyr/kernel.h>

void sys_trace_isr_enter(void) {}
 804a149:	f3 0f 1e fb          	endbr32 
 804a14d:	c3                   	ret    

0804a14e <sys_trace_isr_exit>:
 804a14e:	f3 0f 1e fb          	endbr32 
 804a152:	c3                   	ret    

0804a153 <sys_trace_idle>:
 804a153:	f3 0f 1e fb          	endbr32 
 804a157:	c3                   	ret    

0804a158 <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
 804a158:	f3 0f 1e fb          	endbr32 
 804a15c:	55                   	push   %ebp
 804a15d:	89 e5                	mov    %esp,%ebp
 804a15f:	83 ec 08             	sub    $0x8,%esp
	sys_trace_idle();
 804a162:	e8 ec ff ff ff       	call   804a153 <sys_trace_idle>
	posix_irq_full_unlock();
 804a167:	e8 19 12 00 00       	call   804b385 <posix_irq_full_unlock>
	posix_halt_cpu();
}
 804a16c:	c9                   	leave  
	posix_halt_cpu();
 804a16d:	e9 6a 06 00 00       	jmp    804a7dc <posix_halt_cpu>

0804a172 <arch_irq_enable>:
	posix_irq_offload(routine, parameter);
}
#endif

void arch_irq_enable(unsigned int irq)
{
 804a172:	f3 0f 1e fb          	endbr32 
	posix_irq_enable(irq);
 804a176:	e9 20 12 00 00       	jmp    804b39b <posix_irq_enable>

0804a17b <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
 804a17b:	85 c0                	test   %eax,%eax
 804a17d:	74 16                	je     804a195 <pc_safe_call+0x1a>
{
 804a17f:	55                   	push   %ebp
 804a180:	89 e5                	mov    %esp,%ebp
 804a182:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804a185:	52                   	push   %edx
 804a186:	68 cb e1 04 08       	push   $0x804e1cb
 804a18b:	e8 88 16 00 00       	call   804b818 <posix_print_error_and_exit>
 804a190:	83 c4 10             	add    $0x10,%esp
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
 804a193:	c9                   	leave  
 804a194:	c3                   	ret    
 804a195:	c3                   	ret    

0804a196 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
 804a196:	55                   	push   %ebp
 804a197:	89 e5                	mov    %esp,%ebp
 804a199:	83 ec 14             	sub    $0x14,%esp
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
 804a19c:	68 2c 24 05 08       	push   $0x805242c
 804a1a1:	e8 2a f1 ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a1a6:	83 c4 10             	add    $0x10,%esp
 804a1a9:	ba e5 e1 04 08       	mov    $0x804e1e5,%edx
 804a1ae:	e8 c8 ff ff ff       	call   804a17b <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
 804a1b3:	e8 a8 f1 ff ff       	call   8049360 <pthread_self@plt>
 804a1b8:	83 ec 0c             	sub    $0xc,%esp
 804a1bb:	50                   	push   %eax
 804a1bc:	e8 4f f3 ff ff       	call   8049510 <pthread_detach@plt>
 804a1c1:	83 c4 10             	add    $0x10,%esp
}
 804a1c4:	c9                   	leave  
 804a1c5:	c3                   	ret    

0804a1c6 <abort_tail>:
{
 804a1c6:	55                   	push   %ebp
	threads_table[this_th_nbr].running = false;
 804a1c7:	6b c0 14             	imul   $0x14,%eax,%eax
{
 804a1ca:	89 e5                	mov    %esp,%ebp
 804a1cc:	83 ec 08             	sub    $0x8,%esp
	threads_table[this_th_nbr].running = false;
 804a1cf:	03 05 48 24 05 08    	add    0x8052448,%eax
 804a1d5:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	threads_table[this_th_nbr].state = ABORTED;
 804a1d9:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
	posix_preexit_cleanup();
 804a1df:	e8 b2 ff ff ff       	call   804a196 <posix_preexit_cleanup>
	pthread_exit(NULL);
 804a1e4:	83 ec 0c             	sub    $0xc,%esp
 804a1e7:	6a 00                	push   $0x0
 804a1e9:	e8 92 f2 ff ff       	call   8049480 <pthread_exit@plt>

0804a1ee <posix_wait_until_allowed>:
{
 804a1ee:	55                   	push   %ebp
 804a1ef:	89 e5                	mov    %esp,%ebp
 804a1f1:	56                   	push   %esi
	threads_table[this_th_nbr].running = false;
 804a1f2:	6b f0 14             	imul   $0x14,%eax,%esi
{
 804a1f5:	53                   	push   %ebx
 804a1f6:	89 c3                	mov    %eax,%ebx
	threads_table[this_th_nbr].running = false;
 804a1f8:	a1 48 24 05 08       	mov    0x8052448,%eax
 804a1fd:	c6 44 30 04 00       	movb   $0x0,0x4(%eax,%esi,1)
	while (this_th_nbr != currently_allowed_thread) {
 804a202:	39 1d 28 24 05 08    	cmp    %ebx,0x8052428
 804a208:	74 2a                	je     804a234 <posix_wait_until_allowed+0x46>
		pthread_cond_wait(&cond_threads, &mtx_threads);
 804a20a:	50                   	push   %eax
 804a20b:	50                   	push   %eax
 804a20c:	68 2c 24 05 08       	push   $0x805242c
 804a211:	68 e0 1f 05 08       	push   $0x8051fe0
 804a216:	e8 55 f1 ff ff       	call   8049370 <pthread_cond_wait@plt>
		if (threads_table &&
 804a21b:	a1 48 24 05 08       	mov    0x8052448,%eax
		pthread_cond_wait(&cond_threads, &mtx_threads);
 804a220:	83 c4 10             	add    $0x10,%esp
		if (threads_table &&
 804a223:	85 c0                	test   %eax,%eax
 804a225:	74 db                	je     804a202 <posix_wait_until_allowed+0x14>
 804a227:	83 3c 30 02          	cmpl   $0x2,(%eax,%esi,1)
 804a22b:	75 d5                	jne    804a202 <posix_wait_until_allowed+0x14>
			abort_tail(this_th_nbr);
 804a22d:	89 d8                	mov    %ebx,%eax
 804a22f:	e8 92 ff ff ff       	call   804a1c6 <abort_tail>
	threads_table[this_th_nbr].running = true;
 804a234:	a1 48 24 05 08       	mov    0x8052448,%eax
 804a239:	c6 44 30 04 01       	movb   $0x1,0x4(%eax,%esi,1)
}
 804a23e:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804a241:	5b                   	pop    %ebx
 804a242:	5e                   	pop    %esi
 804a243:	5d                   	pop    %ebp
 804a244:	c3                   	ret    

0804a245 <posix_cleanup_handler>:

/**
 * Handler called when any thread is cancelled or exits
 */
static void posix_cleanup_handler(void *arg)
{
 804a245:	f3 0f 1e fb          	endbr32 
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
 804a249:	80 3d 9d 24 05 08 00 	cmpb   $0x0,0x805249d
 804a250:	74 2b                	je     804a27d <posix_cleanup_handler+0x38>
{
 804a252:	55                   	push   %ebp
 804a253:	89 e5                	mov    %esp,%ebp
 804a255:	83 ec 14             	sub    $0x14,%esp
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
 804a258:	68 2c 24 05 08       	push   $0x805242c
 804a25d:	e8 6e f0 ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a262:	83 c4 10             	add    $0x10,%esp
 804a265:	ba e5 e1 04 08       	mov    $0x804e1e5,%edx
 804a26a:	e8 0c ff ff ff       	call   804a17b <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
 804a26f:	e8 ec f0 ff ff       	call   8049360 <pthread_self@plt>
 804a274:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804a277:	c9                   	leave  
	pthread_detach(pthread_self());
 804a278:	e9 93 f2 ff ff       	jmp    8049510 <pthread_detach@plt>
 804a27d:	c3                   	ret    

0804a27e <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
 804a27e:	f3 0f 1e fb          	endbr32 
 804a282:	55                   	push   %ebp
 804a283:	89 e5                	mov    %esp,%ebp
 804a285:	83 ec 54             	sub    $0x54,%esp
 804a288:	8b 45 08             	mov    0x8(%ebp),%eax
 804a28b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 804a28e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a294:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a297:	31 c0                	xor    %eax,%eax

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804a299:	68 2c 24 05 08       	push   $0x805242c
 804a29e:	e8 fd f0 ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a2a3:	83 c4 10             	add    $0x10,%esp
 804a2a6:	ba 08 e2 04 08       	mov    $0x804e208,%edx
 804a2ab:	e8 cb fe ff ff       	call   804a17b <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
 804a2b0:	83 3d 48 24 05 08 00 	cmpl   $0x0,0x8052448
 804a2b7:	75 17                	jne    804a2d0 <posix_thread_starter+0x52>
		posix_cleanup_handler(arg);
 804a2b9:	83 ec 0c             	sub    $0xc,%esp
 804a2bc:	ff 75 c4             	pushl  -0x3c(%ebp)
 804a2bf:	e8 81 ff ff ff       	call   804a245 <posix_cleanup_handler>
		pthread_exit(NULL);
 804a2c4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a2cb:	e8 b0 f1 ff ff       	call   8049480 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
 804a2d0:	50                   	push   %eax
 804a2d1:	50                   	push   %eax
 804a2d2:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804a2d5:	6a 00                	push   $0x0
 804a2d7:	50                   	push   %eax
 804a2d8:	e8 c3 f1 ff ff       	call   80494a0 <__sigsetjmp@plt>
 804a2dd:	f3 0f 1e fb          	endbr32 
 804a2e1:	83 c4 10             	add    $0x10,%esp
 804a2e4:	85 c0                	test   %eax,%eax
 804a2e6:	74 16                	je     804a2fe <posix_thread_starter+0x80>
 804a2e8:	83 ec 0c             	sub    $0xc,%esp
 804a2eb:	ff 75 c4             	pushl  -0x3c(%ebp)
 804a2ee:	e8 52 ff ff ff       	call   804a245 <posix_cleanup_handler>
 804a2f3:	83 c4 10             	add    $0x10,%esp
 804a2f6:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804a2f9:	e8 c2 f1 ff ff       	call   80494c0 <__pthread_unwind_next@plt>
 804a2fe:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804a301:	e8 3a f0 ff ff       	call   8049340 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
 804a306:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804a309:	e8 e0 fe ff ff       	call   804a1ee <posix_wait_until_allowed>

	posix_new_thread_pre_start();
 804a30e:	e8 9e 03 00 00       	call   804a6b1 <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
 804a313:	6b 45 c4 14          	imul   $0x14,-0x3c(%ebp),%eax
 804a317:	03 05 48 24 05 08    	add    0x8052448,%eax
 804a31d:	8b 40 10             	mov    0x10(%eax),%eax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
 804a320:	ff 70 0c             	pushl  0xc(%eax)
 804a323:	ff 70 08             	pushl  0x8(%eax)
 804a326:	ff 70 04             	pushl  0x4(%eax)
 804a329:	ff 30                	pushl  (%eax)
 804a32b:	e8 8a f4 ff ff       	call   80497ba <z_thread_entry>

0804a330 <posix_swap>:
{
 804a330:	f3 0f 1e fb          	endbr32 
 804a334:	55                   	push   %ebp
 804a335:	89 e5                	mov    %esp,%ebp
 804a337:	53                   	push   %ebx
 804a338:	83 ec 10             	sub    $0x10,%esp
	currently_allowed_thread = next_allowed_th;
 804a33b:	8b 45 08             	mov    0x8(%ebp),%eax
{
 804a33e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a341:	68 e0 1f 05 08       	push   $0x8051fe0
	currently_allowed_thread = next_allowed_th;
 804a346:	a3 28 24 05 08       	mov    %eax,0x8052428
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a34b:	e8 d0 ef ff ff       	call   8049320 <pthread_cond_broadcast@plt>
 804a350:	83 c4 10             	add    $0x10,%esp
 804a353:	ba 29 e2 04 08       	mov    $0x804e229,%edx
 804a358:	e8 1e fe ff ff       	call   804a17b <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
 804a35d:	6b c3 14             	imul   $0x14,%ebx,%eax
 804a360:	03 05 48 24 05 08    	add    0x8052448,%eax
 804a366:	83 38 02             	cmpl   $0x2,(%eax)
		abort_tail(this_th_nbr);
 804a369:	89 d8                	mov    %ebx,%eax
	if (threads_table[this_th_nbr].state == ABORTING) {
 804a36b:	75 05                	jne    804a372 <posix_swap+0x42>
		abort_tail(this_th_nbr);
 804a36d:	e8 54 fe ff ff       	call   804a1c6 <abort_tail>
}
 804a372:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804a375:	c9                   	leave  
		posix_wait_until_allowed(this_th_nbr);
 804a376:	e9 73 fe ff ff       	jmp    804a1ee <posix_wait_until_allowed>

0804a37b <posix_main_thread_start>:
{
 804a37b:	f3 0f 1e fb          	endbr32 
 804a37f:	55                   	push   %ebp
 804a380:	89 e5                	mov    %esp,%ebp
 804a382:	83 ec 14             	sub    $0x14,%esp
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a385:	68 e0 1f 05 08       	push   $0x8051fe0
	currently_allowed_thread = next_allowed_th;
 804a38a:	8b 45 08             	mov    0x8(%ebp),%eax
 804a38d:	a3 28 24 05 08       	mov    %eax,0x8052428
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a392:	e8 89 ef ff ff       	call   8049320 <pthread_cond_broadcast@plt>
 804a397:	83 c4 10             	add    $0x10,%esp
 804a39a:	ba 29 e2 04 08       	mov    $0x804e229,%edx
 804a39f:	e8 d7 fd ff ff       	call   804a17b <pc_safe_call>
	posix_preexit_cleanup();
 804a3a4:	e8 ed fd ff ff       	call   804a196 <posix_preexit_cleanup>
	pthread_exit(NULL);
 804a3a9:	83 ec 0c             	sub    $0xc,%esp
 804a3ac:	6a 00                	push   $0x0
 804a3ae:	e8 cd f0 ff ff       	call   8049480 <pthread_exit@plt>

0804a3b3 <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
 804a3b3:	f3 0f 1e fb          	endbr32 
 804a3b7:	55                   	push   %ebp
	for (int i = 0; i < threads_table_size; i++) {
 804a3b8:	31 d2                	xor    %edx,%edx
{
 804a3ba:	89 e5                	mov    %esp,%ebp
 804a3bc:	57                   	push   %edi
 804a3bd:	56                   	push   %esi
 804a3be:	53                   	push   %ebx
 804a3bf:	83 ec 0c             	sub    $0xc,%esp
 804a3c2:	8b 75 08             	mov    0x8(%ebp),%esi
	for (int i = 0; i < threads_table_size; i++) {
 804a3c5:	a1 4c 24 05 08       	mov    0x805244c,%eax
		if ((threads_table[i].state == NOTUSED)
 804a3ca:	8b 0d 48 24 05 08    	mov    0x8052448,%ecx
	for (int i = 0; i < threads_table_size; i++) {
 804a3d0:	39 c2                	cmp    %eax,%edx
 804a3d2:	7d 0c                	jge    804a3e0 <posix_new_thread+0x2d>
		if ((threads_table[i].state == NOTUSED)
 804a3d4:	6b da 14             	imul   $0x14,%edx,%ebx
 804a3d7:	83 3c 19 00          	cmpl   $0x0,(%ecx,%ebx,1)
 804a3db:	74 50                	je     804a42d <posix_new_thread+0x7a>
	for (int i = 0; i < threads_table_size; i++) {
 804a3dd:	42                   	inc    %edx
 804a3de:	eb f0                	jmp    804a3d0 <posix_new_thread+0x1d>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
 804a3e0:	83 c0 40             	add    $0x40,%eax
	threads_table = realloc(threads_table,
 804a3e3:	52                   	push   %edx
 804a3e4:	6b c0 14             	imul   $0x14,%eax,%eax
 804a3e7:	52                   	push   %edx
 804a3e8:	50                   	push   %eax
 804a3e9:	51                   	push   %ecx
 804a3ea:	e8 d1 ef ff ff       	call   80493c0 <realloc@plt>
 804a3ef:	83 c4 10             	add    $0x10,%esp
 804a3f2:	a3 48 24 05 08       	mov    %eax,0x8052448
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
 804a3f7:	85 c0                	test   %eax,%eax
 804a3f9:	75 10                	jne    804a40b <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
 804a3fb:	83 ec 0c             	sub    $0xc,%esp
 804a3fe:	68 4f e2 04 08       	push   $0x804e24f
 804a403:	e8 10 14 00 00       	call   804b818 <posix_print_error_and_exit>
 804a408:	83 c4 10             	add    $0x10,%esp
	(void)memset(&threads_table[threads_table_size], 0,
 804a40b:	8b 15 4c 24 05 08    	mov    0x805244c,%edx
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
 804a411:	31 c0                	xor    %eax,%eax
 804a413:	b9 40 01 00 00       	mov    $0x140,%ecx
 804a418:	6b da 14             	imul   $0x14,%edx,%ebx
 804a41b:	03 1d 48 24 05 08    	add    0x8052448,%ebx
 804a421:	89 df                	mov    %ebx,%edi
 804a423:	f3 ab                	rep stos %eax,%es:(%edi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
 804a425:	8d 42 40             	lea    0x40(%edx),%eax
 804a428:	a3 4c 24 05 08       	mov    %eax,0x805244c
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a42d:	8b 0d 44 24 05 08    	mov    0x8052444,%ecx
	threads_table[t_slot].state = USED;
 804a433:	6b c2 14             	imul   $0x14,%edx,%eax
 804a436:	03 05 48 24 05 08    	add    0x8052448,%eax
	threads_table[t_slot].t_status = ptr;
 804a43c:	89 70 10             	mov    %esi,0x10(%eax)
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a43f:	83 c0 08             	add    $0x8,%eax
	threads_table[t_slot].state = USED;
 804a442:	c7 40 f8 01 00 00 00 	movl   $0x1,-0x8(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a449:	8d 59 01             	lea    0x1(%ecx),%ebx
	threads_table[t_slot].running = false;
 804a44c:	c6 40 fc 00          	movb   $0x0,-0x4(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a450:	89 48 04             	mov    %ecx,0x4(%eax)
	ptr->thread_idx = t_slot;
 804a453:	89 56 10             	mov    %edx,0x10(%esi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a456:	52                   	push   %edx
 804a457:	68 7e a2 04 08       	push   $0x804a27e
 804a45c:	6a 00                	push   $0x0
 804a45e:	50                   	push   %eax
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a45f:	89 1d 44 24 05 08    	mov    %ebx,0x8052444
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a465:	e8 86 f0 ff ff       	call   80494f0 <pthread_create@plt>
 804a46a:	83 c4 10             	add    $0x10,%esp
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
 804a46d:	8d 65 f4             	lea    -0xc(%ebp),%esp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a470:	ba 77 e2 04 08       	mov    $0x804e277,%edx
}
 804a475:	5b                   	pop    %ebx
 804a476:	5e                   	pop    %esi
 804a477:	5f                   	pop    %edi
 804a478:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a479:	e9 fd fc ff ff       	jmp    804a17b <pc_safe_call>

0804a47e <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
 804a47e:	f3 0f 1e fb          	endbr32 
 804a482:	55                   	push   %ebp
 804a483:	89 e5                	mov    %esp,%ebp
 804a485:	83 ec 10             	sub    $0x10,%esp
	thread_create_count = 0;
 804a488:	c7 05 44 24 05 08 00 	movl   $0x0,0x8052444
 804a48f:	00 00 00 

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
 804a492:	6a 14                	push   $0x14
 804a494:	6a 40                	push   $0x40
	currently_allowed_thread = -1;
 804a496:	c7 05 28 24 05 08 ff 	movl   $0xffffffff,0x8052428
 804a49d:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
 804a4a0:	e8 ab f0 ff ff       	call   8049550 <calloc@plt>
 804a4a5:	83 c4 10             	add    $0x10,%esp
 804a4a8:	a3 48 24 05 08       	mov    %eax,0x8052448
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
 804a4ad:	85 c0                	test   %eax,%eax
 804a4af:	75 10                	jne    804a4c1 <posix_init_multithreading+0x43>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
 804a4b1:	83 ec 0c             	sub    $0xc,%esp
 804a4b4:	68 4f e2 04 08       	push   $0x804e24f
 804a4b9:	e8 5a 13 00 00       	call   804b818 <posix_print_error_and_exit>
 804a4be:	83 c4 10             	add    $0x10,%esp
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;
 804a4c1:	c7 05 4c 24 05 08 40 	movl   $0x40,0x805244c
 804a4c8:	00 00 00 


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804a4cb:	83 ec 0c             	sub    $0xc,%esp
 804a4ce:	68 2c 24 05 08       	push   $0x805242c
 804a4d3:	e8 c8 ee ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a4d8:	83 c4 10             	add    $0x10,%esp
 804a4db:	ba 08 e2 04 08       	mov    $0x804e208,%edx
}
 804a4e0:	c9                   	leave  
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804a4e1:	e9 95 fc ff ff       	jmp    804a17b <pc_safe_call>

0804a4e6 <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
 804a4e6:	f3 0f 1e fb          	endbr32 

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
 804a4ea:	83 3d 48 24 05 08 00 	cmpl   $0x0,0x8052448
 804a4f1:	74 65                	je     804a558 <posix_core_clean_up+0x72>
{
 804a4f3:	55                   	push   %ebp
 804a4f4:	89 e5                	mov    %esp,%ebp
 804a4f6:	53                   	push   %ebx
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;

	for (int i = 0; i < threads_table_size; i++) {
 804a4f7:	31 db                	xor    %ebx,%ebx
{
 804a4f9:	52                   	push   %edx
	terminate = true;
 804a4fa:	c6 05 9d 24 05 08 01 	movb   $0x1,0x805249d
	for (int i = 0; i < threads_table_size; i++) {
 804a501:	a1 48 24 05 08       	mov    0x8052448,%eax
 804a506:	39 1d 4c 24 05 08    	cmp    %ebx,0x805244c
 804a50c:	7e 2f                	jle    804a53d <posix_core_clean_up+0x57>
		if (threads_table[i].state != USED) {
 804a50e:	6b d3 14             	imul   $0x14,%ebx,%edx
 804a511:	01 d0                	add    %edx,%eax
 804a513:	83 38 01             	cmpl   $0x1,(%eax)
 804a516:	75 22                	jne    804a53a <posix_core_clean_up+0x54>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
 804a518:	83 ec 0c             	sub    $0xc,%esp
 804a51b:	ff 70 08             	pushl  0x8(%eax)
 804a51e:	e8 2d ef ff ff       	call   8049450 <pthread_cancel@plt>
 804a523:	83 c4 10             	add    $0x10,%esp
 804a526:	85 c0                	test   %eax,%eax
 804a528:	74 10                	je     804a53a <posix_core_clean_up+0x54>
			posix_print_warning(
 804a52a:	50                   	push   %eax
 804a52b:	50                   	push   %eax
 804a52c:	53                   	push   %ebx
 804a52d:	68 db e2 04 08       	push   $0x804e2db
 804a532:	e8 10 13 00 00       	call   804b847 <posix_print_warning>
 804a537:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < threads_table_size; i++) {
 804a53a:	43                   	inc    %ebx
 804a53b:	eb c4                	jmp    804a501 <posix_core_clean_up+0x1b>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
 804a53d:	83 ec 0c             	sub    $0xc,%esp
 804a540:	50                   	push   %eax
 804a541:	e8 ea ed ff ff       	call   8049330 <free@plt>
	threads_table = NULL;
}
 804a546:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	free(threads_table);
 804a549:	83 c4 10             	add    $0x10,%esp
	threads_table = NULL;
 804a54c:	c7 05 48 24 05 08 00 	movl   $0x0,0x8052448
 804a553:	00 00 00 
}
 804a556:	c9                   	leave  
 804a557:	c3                   	ret    
 804a558:	c3                   	ret    

0804a559 <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
 804a559:	f3 0f 1e fb          	endbr32 
 804a55d:	55                   	push   %ebp
 804a55e:	89 e5                	mov    %esp,%ebp
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
 804a560:	6b 45 08 14          	imul   $0x14,0x8(%ebp),%eax
 804a564:	03 05 48 24 05 08    	add    0x8052448,%eax
 804a56a:	83 38 01             	cmpl   $0x1,(%eax)
 804a56d:	75 06                	jne    804a575 <posix_abort_thread+0x1c>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
 804a56f:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
 804a575:	5d                   	pop    %ebp
 804a576:	c3                   	ret    

0804a577 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
 804a577:	f3 0f 1e fb          	endbr32 
 804a57b:	55                   	push   %ebp
 804a57c:	89 e5                	mov    %esp,%ebp
 804a57e:	57                   	push   %edi
 804a57f:	56                   	push   %esi
 804a580:	53                   	push   %ebx
 804a581:	83 ec 1c             	sub    $0x1c,%esp
 804a584:	8b 75 08             	mov    0x8(%ebp),%esi
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
 804a587:	8b 5e 34             	mov    0x34(%esi),%ebx
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
 804a58a:	8b 7b 10             	mov    0x10(%ebx),%edi
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
 804a58d:	e8 d4 0d 00 00       	call   804b366 <posix_irq_lock>
 804a592:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	key = irq_lock();

	if (_current == thread) {
 804a595:	39 35 68 23 05 08    	cmp    %esi,0x8052368
 804a59b:	75 2e                	jne    804a5cb <z_impl_k_thread_abort+0x54>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
 804a59d:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
 804a5a1:	75 09                	jne    804a5ac <z_impl_k_thread_abort+0x35>
			tstatus->aborted = 1;
 804a5a3:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
 804a5aa:	eb 10                	jmp    804a5bc <z_impl_k_thread_abort+0x45>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
 804a5ac:	50                   	push   %eax
 804a5ad:	50                   	push   %eax
 804a5ae:	57                   	push   %edi
 804a5af:	68 0f e3 04 08       	push   $0x804e30f
 804a5b4:	e8 8e 12 00 00       	call   804b847 <posix_print_warning>
 804a5b9:	83 c4 10             	add    $0x10,%esp
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
 804a5bc:	6b c7 14             	imul   $0x14,%edi,%eax
 804a5bf:	03 05 48 24 05 08    	add    0x8052448,%eax
 804a5c5:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
 804a5cb:	83 ec 0c             	sub    $0xc,%esp
 804a5ce:	56                   	push   %esi
 804a5cf:	e8 31 25 00 00       	call   804cb05 <z_thread_abort>
 804a5d4:	83 c4 10             	add    $0x10,%esp

	if (tstatus->aborted == 0) {
 804a5d7:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
 804a5db:	75 13                	jne    804a5f0 <z_impl_k_thread_abort+0x79>
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
		posix_abort_thread(thread_idx);
 804a5dd:	83 ec 0c             	sub    $0xc,%esp
		tstatus->aborted = 1;
 804a5e0:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		posix_abort_thread(thread_idx);
 804a5e7:	57                   	push   %edi
 804a5e8:	e8 6c ff ff ff       	call   804a559 <posix_abort_thread>
 804a5ed:	83 c4 10             	add    $0x10,%esp
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
 804a5f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a5f3:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804a5f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a5f9:	5b                   	pop    %ebx
 804a5fa:	5e                   	pop    %esi
 804a5fb:	5f                   	pop    %edi
 804a5fc:	5d                   	pop    %ebp
	z_reschedule_irqlock(key);
 804a5fd:	e9 93 21 00 00       	jmp    804c795 <z_reschedule_irqlock>

0804a602 <arch_swap>:
#include "irq.h"
#include "kswap.h"
#include <zephyr/pm/pm.h>

int arch_swap(unsigned int key)
{
 804a602:	f3 0f 1e fb          	endbr32 
 804a606:	55                   	push   %ebp
 804a607:	89 e5                	mov    %esp,%ebp
 804a609:	83 ec 10             	sub    $0x10,%esp
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
 804a60c:	a1 68 23 05 08       	mov    0x8052368,%eax
 804a611:	8b 55 08             	mov    0x8(%ebp),%edx
	_current->callee_saved.retval = -EAGAIN;
 804a614:	c7 40 30 f5 ff ff ff 	movl   $0xfffffff5,0x30(%eax)
	_current->callee_saved.key = key;
 804a61b:	89 50 2c             	mov    %edx,0x2c(%eax)
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
 804a61e:	8b 15 78 23 05 08    	mov    0x8052378,%edx

	posix_thread_status_t *this_thread_ptr  =
 804a624:	8b 40 34             	mov    0x34(%eax),%eax
	posix_thread_status_t *ready_thread_ptr =
 804a627:	8b 4a 34             	mov    0x34(%edx),%ecx
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
 804a62a:	89 15 68 23 05 08    	mov    %edx,0x8052368
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
 804a630:	ff 70 10             	pushl  0x10(%eax)
 804a633:	ff 71 10             	pushl  0x10(%ecx)
 804a636:	e8 f5 fc ff ff       	call   804a330 <posix_swap>
 804a63b:	58                   	pop    %eax
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
 804a63c:	a1 68 23 05 08       	mov    0x8052368,%eax
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
 804a641:	ff 70 2c             	pushl  0x2c(%eax)
 804a644:	e8 33 0d 00 00       	call   804b37c <posix_irq_unlock>

	return _current->callee_saved.retval;
 804a649:	a1 68 23 05 08       	mov    0x8052368,%eax
 804a64e:	83 c4 10             	add    $0x10,%esp
 804a651:	8b 40 30             	mov    0x30(%eax),%eax
}
 804a654:	c9                   	leave  
 804a655:	c3                   	ret    

0804a656 <arch_switch_to_main_thread>:
 * Note that we will never come back to this thread: posix_main_thread_start()
 * does never return.
 */
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
 804a656:	f3 0f 1e fb          	endbr32 
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
 804a65a:	a1 78 23 05 08       	mov    0x8052378,%eax
{
 804a65f:	55                   	push   %ebp
	posix_thread_status_t *ready_thread_ptr =
 804a660:	8b 50 34             	mov    0x34(%eax),%edx

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
 804a663:	a3 68 23 05 08       	mov    %eax,0x8052368
{
 804a668:	89 e5                	mov    %esp,%ebp

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
 804a66a:	8b 42 10             	mov    0x10(%edx),%eax
 804a66d:	89 45 08             	mov    %eax,0x8(%ebp)
} /* LCOV_EXCL_LINE */
 804a670:	5d                   	pop    %ebp
	posix_main_thread_start(ready_thread_ptr->thread_idx);
 804a671:	e9 05 fd ff ff       	jmp    804a37b <posix_main_thread_start>

0804a676 <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
 804a676:	f3 0f 1e fb          	endbr32 
 804a67a:	55                   	push   %ebp
 804a67b:	89 e5                	mov    %esp,%ebp
 804a67d:	8b 45 10             	mov    0x10(%ebp),%eax
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
 804a680:	8b 4d 14             	mov    0x14(%ebp),%ecx
 804a683:	89 48 e8             	mov    %ecx,-0x18(%eax)
	thread_status->arg1 = p1;
 804a686:	8b 4d 18             	mov    0x18(%ebp),%ecx
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
 804a689:	8d 50 e8             	lea    -0x18(%eax),%edx
	thread_status->arg2 = p2;
	thread_status->arg3 = p3;
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
 804a68c:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	thread_status->arg1 = p1;
 804a693:	89 48 ec             	mov    %ecx,-0x14(%eax)
	thread_status->arg2 = p2;
 804a696:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
 804a699:	89 48 f0             	mov    %ecx,-0x10(%eax)
	thread_status->arg3 = p3;
 804a69c:	8b 4d 20             	mov    0x20(%ebp),%ecx
 804a69f:	89 48 f4             	mov    %ecx,-0xc(%eax)
#endif

	thread->callee_saved.thread_status = thread_status;
 804a6a2:	8b 45 08             	mov    0x8(%ebp),%eax
 804a6a5:	89 50 34             	mov    %edx,0x34(%eax)

	posix_new_thread(thread_status);
 804a6a8:	89 55 08             	mov    %edx,0x8(%ebp)
}
 804a6ab:	5d                   	pop    %ebp
	posix_new_thread(thread_status);
 804a6ac:	e9 02 fd ff ff       	jmp    804a3b3 <posix_new_thread>

0804a6b1 <posix_new_thread_pre_start>:

void posix_new_thread_pre_start(void)
{
 804a6b1:	f3 0f 1e fb          	endbr32 
	posix_irq_full_unlock();
 804a6b5:	e9 cb 0c 00 00       	jmp    804b385 <posix_irq_full_unlock>

0804a6ba <pc_safe_call>:
	if (unlikely(test)) {
 804a6ba:	85 c0                	test   %eax,%eax
 804a6bc:	74 16                	je     804a6d4 <pc_safe_call+0x1a>
{
 804a6be:	55                   	push   %ebp
 804a6bf:	89 e5                	mov    %esp,%ebp
 804a6c1:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804a6c4:	52                   	push   %edx
 804a6c5:	68 cb e1 04 08       	push   $0x804e1cb
 804a6ca:	e8 49 11 00 00       	call   804b818 <posix_print_error_and_exit>
 804a6cf:	83 c4 10             	add    $0x10,%esp
}
 804a6d2:	c9                   	leave  
 804a6d3:	c3                   	ret    
 804a6d4:	c3                   	ret    

0804a6d5 <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
 804a6d5:	f3 0f 1e fb          	endbr32 
 804a6d9:	55                   	push   %ebp
 804a6da:	89 e5                	mov    %esp,%ebp
 804a6dc:	83 ec 14             	sub    $0x14,%esp
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a6df:	68 50 24 05 08       	push   $0x8052450
 804a6e4:	e8 b7 ec ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a6e9:	ba 8b e3 04 08       	mov    $0x804e38b,%edx
 804a6ee:	83 c4 10             	add    $0x10,%esp
 804a6f1:	e8 c4 ff ff ff       	call   804a6ba <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a6f6:	83 ec 0c             	sub    $0xc,%esp
 804a6f9:	68 50 24 05 08       	push   $0x8052450
 804a6fe:	e8 cd eb ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a703:	83 c4 10             	add    $0x10,%esp
 804a706:	ba a8 e3 04 08       	mov    $0x804e3a8,%edx
 804a70b:	e8 aa ff ff ff       	call   804a6ba <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
 804a710:	e8 69 fd ff ff       	call   804a47e <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
 804a715:	e8 22 1d 00 00       	call   804c43c <z_cstart>

0804a71a <posix_is_cpu_running>:
{
 804a71a:	f3 0f 1e fb          	endbr32 
	return !cpu_halted;
 804a71e:	a0 90 12 05 08       	mov    0x8051290,%al
 804a723:	83 f0 01             	xor    $0x1,%eax
 804a726:	0f b6 c0             	movzbl %al,%eax
}
 804a729:	c3                   	ret    

0804a72a <posix_change_cpu_state_and_wait>:
{
 804a72a:	f3 0f 1e fb          	endbr32 
 804a72e:	55                   	push   %ebp
 804a72f:	89 e5                	mov    %esp,%ebp
 804a731:	56                   	push   %esi
 804a732:	53                   	push   %ebx
 804a733:	8b 75 08             	mov    0x8(%ebp),%esi
 804a736:	89 f3                	mov    %esi,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a738:	83 ec 0c             	sub    $0xc,%esp
 804a73b:	68 50 24 05 08       	push   $0x8052450
 804a740:	e8 5b ec ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a745:	ba 8b e3 04 08       	mov    $0x804e38b,%edx
 804a74a:	83 c4 10             	add    $0x10,%esp
 804a74d:	e8 68 ff ff ff       	call   804a6ba <pc_safe_call>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804a752:	83 ec 0c             	sub    $0xc,%esp
	cpu_halted = halted;
 804a755:	88 1d 90 12 05 08    	mov    %bl,0x8051290
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804a75b:	68 20 20 05 08       	push   $0x8052020
 804a760:	e8 bb eb ff ff       	call   8049320 <pthread_cond_broadcast@plt>
 804a765:	83 c4 10             	add    $0x10,%esp
 804a768:	ba c7 e3 04 08       	mov    $0x804e3c7,%edx
 804a76d:	e8 48 ff ff ff       	call   804a6ba <pc_safe_call>
	while (cpu_halted == halted) {
 804a772:	38 1d 90 12 05 08    	cmp    %bl,0x8051290
 804a778:	75 16                	jne    804a790 <posix_change_cpu_state_and_wait+0x66>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
 804a77a:	50                   	push   %eax
 804a77b:	50                   	push   %eax
 804a77c:	68 50 24 05 08       	push   $0x8052450
 804a781:	68 20 20 05 08       	push   $0x8052020
 804a786:	e8 e5 eb ff ff       	call   8049370 <pthread_cond_wait@plt>
 804a78b:	83 c4 10             	add    $0x10,%esp
 804a78e:	eb e2                	jmp    804a772 <posix_change_cpu_state_and_wait+0x48>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a790:	83 ec 0c             	sub    $0xc,%esp
 804a793:	68 50 24 05 08       	push   $0x8052450
 804a798:	e8 33 eb ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a79d:	83 c4 10             	add    $0x10,%esp
}
 804a7a0:	8d 65 f8             	lea    -0x8(%ebp),%esp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a7a3:	ba a8 e3 04 08       	mov    $0x804e3a8,%edx
}
 804a7a8:	5b                   	pop    %ebx
 804a7a9:	5e                   	pop    %esi
 804a7aa:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a7ab:	e9 0a ff ff ff       	jmp    804a6ba <pc_safe_call>

0804a7b0 <posix_interrupt_raised>:
{
 804a7b0:	f3 0f 1e fb          	endbr32 
 804a7b4:	55                   	push   %ebp
 804a7b5:	89 e5                	mov    %esp,%ebp
 804a7b7:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(false);
 804a7ba:	6a 00                	push   $0x0
 804a7bc:	e8 69 ff ff ff       	call   804a72a <posix_change_cpu_state_and_wait>
 804a7c1:	83 c4 10             	add    $0x10,%esp
	if (soc_terminate) {
 804a7c4:	80 3d 9e 24 05 08 00 	cmpb   $0x0,0x805249e
 804a7cb:	74 0d                	je     804a7da <posix_interrupt_raised+0x2a>
		posix_exit(0);
 804a7cd:	83 ec 0c             	sub    $0xc,%esp
 804a7d0:	6a 00                	push   $0x0
 804a7d2:	e8 04 0f 00 00       	call   804b6db <posix_exit>
 804a7d7:	83 c4 10             	add    $0x10,%esp
}
 804a7da:	c9                   	leave  
 804a7db:	c3                   	ret    

0804a7dc <posix_halt_cpu>:
{
 804a7dc:	f3 0f 1e fb          	endbr32 
 804a7e0:	55                   	push   %ebp
 804a7e1:	89 e5                	mov    %esp,%ebp
 804a7e3:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(true);
 804a7e6:	6a 01                	push   $0x1
 804a7e8:	e8 3d ff ff ff       	call   804a72a <posix_change_cpu_state_and_wait>
 804a7ed:	83 c4 10             	add    $0x10,%esp
}
 804a7f0:	c9                   	leave  
	posix_irq_handler();
 804a7f1:	e9 1e 0a 00 00       	jmp    804b214 <posix_irq_handler>

0804a7f6 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
 804a7f6:	f3 0f 1e fb          	endbr32 
 804a7fa:	55                   	push   %ebp
 804a7fb:	89 e5                	mov    %esp,%ebp
 804a7fd:	83 ec 24             	sub    $0x24,%esp
 804a800:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a806:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a809:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a80b:	68 50 24 05 08       	push   $0x8052450
 804a810:	e8 8b eb ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a815:	83 c4 10             	add    $0x10,%esp
 804a818:	ba 8b e3 04 08       	mov    $0x804e38b,%edx
 804a81d:	e8 98 fe ff ff       	call   804a6ba <pc_safe_call>
	cpu_halted = false;

	pthread_t zephyr_thread;

	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
 804a822:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804a825:	6a 00                	push   $0x0
 804a827:	68 d5 a6 04 08       	push   $0x804a6d5
 804a82c:	6a 00                	push   $0x0
 804a82e:	50                   	push   %eax
	cpu_halted = false;
 804a82f:	c6 05 90 12 05 08 00 	movb   $0x0,0x8051290
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
 804a836:	e8 b5 ec ff ff       	call   80494f0 <pthread_create@plt>
 804a83b:	83 c4 10             	add    $0x10,%esp
 804a83e:	ba e9 e3 04 08       	mov    $0x804e3e9,%edx
 804a843:	e8 72 fe ff ff       	call   804a6ba <pc_safe_call>

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
 804a848:	80 3d 90 12 05 08 00 	cmpb   $0x0,0x8051290
 804a84f:	75 16                	jne    804a867 <posix_boot_cpu+0x71>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
 804a851:	50                   	push   %eax
 804a852:	50                   	push   %eax
 804a853:	68 50 24 05 08       	push   $0x8052450
 804a858:	68 20 20 05 08       	push   $0x8052020
 804a85d:	e8 0e eb ff ff       	call   8049370 <pthread_cond_wait@plt>
 804a862:	83 c4 10             	add    $0x10,%esp
 804a865:	eb e1                	jmp    804a848 <posix_boot_cpu+0x52>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a867:	83 ec 0c             	sub    $0xc,%esp
 804a86a:	68 50 24 05 08       	push   $0x8052450
 804a86f:	e8 5c ea ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a874:	83 c4 10             	add    $0x10,%esp
 804a877:	ba a8 e3 04 08       	mov    $0x804e3a8,%edx
 804a87c:	e8 39 fe ff ff       	call   804a6ba <pc_safe_call>

	if (soc_terminate) {
 804a881:	80 3d 9e 24 05 08 00 	cmpb   $0x0,0x805249e
 804a888:	74 0d                	je     804a897 <posix_boot_cpu+0xa1>
		posix_exit(0);
 804a88a:	83 ec 0c             	sub    $0xc,%esp
 804a88d:	6a 00                	push   $0x0
 804a88f:	e8 47 0e 00 00       	call   804b6db <posix_exit>
 804a894:	83 c4 10             	add    $0x10,%esp
	}
}
 804a897:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a89a:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804a8a1:	74 05                	je     804a8a8 <posix_boot_cpu+0xb2>
 804a8a3:	e8 e8 ea ff ff       	call   8049390 <__stack_chk_fail@plt>
 804a8a8:	c9                   	leave  
 804a8a9:	c3                   	ret    

0804a8aa <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
 804a8aa:	f3 0f 1e fb          	endbr32 
 804a8ae:	55                   	push   %ebp
 804a8af:	89 e5                	mov    %esp,%ebp
 804a8b1:	56                   	push   %esi
 804a8b2:	8b 75 08             	mov    0x8(%ebp),%esi
 804a8b5:	53                   	push   %ebx
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
 804a8b6:	8b 1c b5 00 e1 04 08 	mov    0x804e100(,%esi,4),%ebx
 804a8bd:	39 1c b5 04 e1 04 08 	cmp    %ebx,0x804e104(,%esi,4)
 804a8c4:	76 0d                	jbe    804a8d3 <run_native_tasks+0x29>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
 804a8c6:	8b 03                	mov    (%ebx),%eax
 804a8c8:	85 c0                	test   %eax,%eax
 804a8ca:	74 02                	je     804a8ce <run_native_tasks+0x24>
			(*fptr)();
 804a8cc:	ff d0                	call   *%eax
		fptr++) {
 804a8ce:	83 c3 04             	add    $0x4,%ebx
 804a8d1:	eb ea                	jmp    804a8bd <run_native_tasks+0x13>
		}
	}
}
 804a8d3:	5b                   	pop    %ebx
 804a8d4:	5e                   	pop    %esi
 804a8d5:	5d                   	pop    %ebp
 804a8d6:	c3                   	ret    

0804a8d7 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
 804a8d7:	f3 0f 1e fb          	endbr32 
 804a8db:	55                   	push   %ebp
 804a8dc:	89 e5                	mov    %esp,%ebp
 804a8de:	83 ec 08             	sub    $0x8,%esp
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
 804a8e1:	80 3d 90 12 05 08 00 	cmpb   $0x0,0x8051290
 804a8e8:	74 14                	je     804a8fe <posix_soc_clean_up+0x27>

		posix_core_clean_up();
 804a8ea:	e8 f7 fb ff ff       	call   804a4e6 <posix_core_clean_up>
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
 804a8ef:	83 ec 0c             	sub    $0xc,%esp
 804a8f2:	6a 04                	push   $0x4
 804a8f4:	e8 b1 ff ff ff       	call   804a8aa <run_native_tasks>
 804a8f9:	83 c4 10             	add    $0x10,%esp
 804a8fc:	eb 74                	jmp    804a972 <posix_soc_clean_up+0x9b>

	} else if (soc_terminate == false) {
 804a8fe:	80 3d 9e 24 05 08 00 	cmpb   $0x0,0x805249e
 804a905:	75 6b                	jne    804a972 <posix_soc_clean_up+0x9b>

		soc_terminate = true;

		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a907:	83 ec 0c             	sub    $0xc,%esp
		soc_terminate = true;
 804a90a:	c6 05 9e 24 05 08 01 	movb   $0x1,0x805249e
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a911:	68 50 24 05 08       	push   $0x8052450
 804a916:	e8 85 ea ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a91b:	ba 8b e3 04 08       	mov    $0x804e38b,%edx
 804a920:	83 c4 10             	add    $0x10,%esp
 804a923:	e8 92 fd ff ff       	call   804a6ba <pc_safe_call>

		cpu_halted = true;

		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804a928:	83 ec 0c             	sub    $0xc,%esp
		cpu_halted = true;
 804a92b:	c6 05 90 12 05 08 01 	movb   $0x1,0x8051290
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804a932:	68 20 20 05 08       	push   $0x8052020
 804a937:	e8 e4 e9 ff ff       	call   8049320 <pthread_cond_broadcast@plt>
 804a93c:	ba c7 e3 04 08       	mov    $0x804e3c7,%edx
 804a941:	83 c4 10             	add    $0x10,%esp
 804a944:	e8 71 fd ff ff       	call   804a6ba <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a949:	83 ec 0c             	sub    $0xc,%esp
 804a94c:	68 50 24 05 08       	push   $0x8052450
 804a951:	e8 7a e9 ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a956:	83 c4 10             	add    $0x10,%esp
 804a959:	ba a8 e3 04 08       	mov    $0x804e3a8,%edx
 804a95e:	e8 57 fd ff ff       	call   804a6ba <pc_safe_call>

		while (1) {
			sleep(1);
 804a963:	83 ec 0c             	sub    $0xc,%esp
 804a966:	6a 01                	push   $0x1
 804a968:	e8 13 ea ff ff       	call   8049380 <sleep@plt>
 804a96d:	83 c4 10             	add    $0x10,%esp
		while (1) {
 804a970:	eb f1                	jmp    804a963 <posix_soc_clean_up+0x8c>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
 804a972:	c9                   	leave  
 804a973:	c3                   	ret    

0804a974 <hwm_signal_end_handler>:

/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
 804a974:	f3 0f 1e fb          	endbr32 
	signaled_end = 1;
 804a978:	c7 05 68 24 05 08 01 	movl   $0x1,0x8052468
 804a97f:	00 00 00 
}
 804a982:	c3                   	ret    

0804a983 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
 804a983:	f3 0f 1e fb          	endbr32 
 804a987:	55                   	push   %ebp
 804a988:	89 e5                	mov    %esp,%ebp
 804a98a:	53                   	push   %ebx
 804a98b:	81 ec a0 00 00 00    	sub    $0xa0,%esp
 804a991:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a997:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a99a:	31 c0                	xor    %eax,%eax
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
 804a99c:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
	act.sa_handler = hwm_signal_end_handler;
 804a9a2:	c7 85 68 ff ff ff 74 	movl   $0x804a974,-0x98(%ebp)
 804a9a9:	a9 04 08 
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
 804a9ac:	50                   	push   %eax
 804a9ad:	e8 fe ea ff ff       	call   80494b0 <sigemptyset@plt>
 804a9b2:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804a9b5:	85 c0                	test   %eax,%eax
 804a9b7:	74 14                	je     804a9cd <hwm_set_sig_handler+0x4a>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804a9b9:	50                   	push   %eax
 804a9ba:	50                   	push   %eax
 804a9bb:	68 24 e4 04 08       	push   $0x804e424
 804a9c0:	68 cb e1 04 08       	push   $0x804e1cb
 804a9c5:	e8 4e 0e 00 00       	call   804b818 <posix_print_error_and_exit>
 804a9ca:	83 c4 10             	add    $0x10,%esp

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
 804a9cd:	53                   	push   %ebx
 804a9ce:	8d 9d 68 ff ff ff    	lea    -0x98(%ebp),%ebx
 804a9d4:	6a 00                	push   $0x0
 804a9d6:	53                   	push   %ebx
 804a9d7:	6a 0f                	push   $0xf
	act.sa_flags = SA_RESETHAND;
 804a9d9:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
 804a9e0:	e8 1b eb ff ff       	call   8049500 <sigaction@plt>
 804a9e5:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804a9e8:	85 c0                	test   %eax,%eax
 804a9ea:	74 14                	je     804aa00 <hwm_set_sig_handler+0x7d>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804a9ec:	51                   	push   %ecx
 804a9ed:	51                   	push   %ecx
 804a9ee:	68 3e e4 04 08       	push   $0x804e43e
 804a9f3:	68 cb e1 04 08       	push   $0x804e1cb
 804a9f8:	e8 1b 0e 00 00       	call   804b818 <posix_print_error_and_exit>
 804a9fd:	83 c4 10             	add    $0x10,%esp
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
 804aa00:	52                   	push   %edx
 804aa01:	6a 00                	push   $0x0
 804aa03:	53                   	push   %ebx
 804aa04:	6a 02                	push   $0x2
 804aa06:	e8 f5 ea ff ff       	call   8049500 <sigaction@plt>
 804aa0b:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804aa0e:	85 c0                	test   %eax,%eax
 804aa10:	74 14                	je     804aa26 <hwm_set_sig_handler+0xa3>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804aa12:	50                   	push   %eax
 804aa13:	50                   	push   %eax
 804aa14:	68 5d e4 04 08       	push   $0x804e45d
 804aa19:	68 cb e1 04 08       	push   $0x804e1cb
 804aa1e:	e8 f5 0d 00 00       	call   804b818 <posix_print_error_and_exit>
 804aa23:	83 c4 10             	add    $0x10,%esp
}
 804aa26:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aa29:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804aa30:	74 05                	je     804aa37 <hwm_set_sig_handler+0xb4>
 804aa32:	e8 59 e9 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804aa37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804aa3a:	c9                   	leave  
 804aa3b:	c3                   	ret    

0804aa3c <hwm_find_next_timer>:
/**
 * Find in between all timers which is the next one
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
 804aa3c:	f3 0f 1e fb          	endbr32 
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
 804aa40:	8b 15 68 12 05 08    	mov    0x8051268,%edx
 804aa46:	a1 6c 12 05 08       	mov    0x805126c,%eax
{
 804aa4b:	55                   	push   %ebp
	next_timer_time  = *Timer_list[0];
 804aa4c:	8b 0d d4 23 05 08    	mov    0x80523d4,%ecx
	next_timer_index = 0;
 804aa52:	c7 05 74 12 05 08 00 	movl   $0x0,0x8051274
 804aa59:	00 00 00 
{
 804aa5c:	89 e5                	mov    %esp,%ebp
 804aa5e:	53                   	push   %ebx
	next_timer_time  = *Timer_list[0];
 804aa5f:	8b 1d d0 23 05 08    	mov    0x80523d0,%ebx
 804aa65:	89 0d 8c 23 05 08    	mov    %ecx,0x805238c
		if (next_timer_time > *Timer_list[i]) {
 804aa6b:	39 da                	cmp    %ebx,%edx
	next_timer_time  = *Timer_list[0];
 804aa6d:	89 1d 88 23 05 08    	mov    %ebx,0x8052388
		if (next_timer_time > *Timer_list[i]) {
 804aa73:	89 c3                	mov    %eax,%ebx
 804aa75:	19 cb                	sbb    %ecx,%ebx
 804aa77:	73 15                	jae    804aa8e <hwm_find_next_timer+0x52>
			next_timer_index = i;
 804aa79:	c7 05 74 12 05 08 01 	movl   $0x1,0x8051274
 804aa80:	00 00 00 
			next_timer_time = *Timer_list[i];
 804aa83:	89 15 88 23 05 08    	mov    %edx,0x8052388
 804aa89:	a3 8c 23 05 08       	mov    %eax,0x805238c
		if (next_timer_time > *Timer_list[i]) {
 804aa8e:	a1 0c 24 05 08       	mov    0x805240c,%eax
 804aa93:	8b 15 08 24 05 08    	mov    0x8052408,%edx
 804aa99:	3b 15 88 23 05 08    	cmp    0x8052388,%edx
 804aa9f:	89 c1                	mov    %eax,%ecx
 804aaa1:	1b 0d 8c 23 05 08    	sbb    0x805238c,%ecx
 804aaa7:	73 15                	jae    804aabe <hwm_find_next_timer+0x82>
			next_timer_index = i;
 804aaa9:	c7 05 74 12 05 08 02 	movl   $0x2,0x8051274
 804aab0:	00 00 00 
			next_timer_time = *Timer_list[i];
 804aab3:	89 15 88 23 05 08    	mov    %edx,0x8052388
 804aab9:	a3 8c 23 05 08       	mov    %eax,0x805238c
		}
	}
}
 804aabe:	5b                   	pop    %ebx
 804aabf:	5d                   	pop    %ebp
 804aac0:	c3                   	ret    

0804aac1 <hwm_main_loop>:
/**
 * Entry point for the HW models
 * The HW models execute in an infinite loop until terminated
 */
void hwm_main_loop(void)
{
 804aac1:	f3 0f 1e fb          	endbr32 
 804aac5:	55                   	push   %ebp
 804aac6:	89 e5                	mov    %esp,%ebp
 804aac8:	56                   	push   %esi
 804aac9:	53                   	push   %ebx
 804aaca:	83 ec 10             	sub    $0x10,%esp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
 804aacd:	a1 88 23 05 08       	mov    0x8052388,%eax
 804aad2:	8b 15 8c 23 05 08    	mov    0x805238c,%edx
 804aad8:	8b 0d 90 23 05 08    	mov    0x8052390,%ecx
 804aade:	8b 1d 94 23 05 08    	mov    0x8052394,%ebx
 804aae4:	89 d6                	mov    %edx,%esi
 804aae6:	39 c8                	cmp    %ecx,%eax
 804aae8:	19 de                	sbb    %ebx,%esi
 804aaea:	72 0d                	jb     804aaf9 <hwm_main_loop+0x38>
		simu_time = next_timer_time;
 804aaec:	a3 90 23 05 08       	mov    %eax,0x8052390
 804aaf1:	89 15 94 23 05 08    	mov    %edx,0x8052394
 804aaf7:	eb 19                	jmp    804ab12 <hwm_main_loop+0x51>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
 804aaf9:	56                   	push   %esi
 804aafa:	56                   	push   %esi
 804aafb:	ff 35 74 12 05 08    	pushl  0x8051274
 804ab01:	53                   	push   %ebx
 804ab02:	51                   	push   %ecx
 804ab03:	52                   	push   %edx
 804ab04:	50                   	push   %eax
 804ab05:	68 7b e4 04 08       	push   $0x804e47b
 804ab0a:	e8 38 0d 00 00       	call   804b847 <posix_print_warning>
 804ab0f:	83 c4 20             	add    $0x20,%esp
	if (signaled_end || (simu_time > end_of_time)) {
 804ab12:	8b 0d 68 24 05 08    	mov    0x8052468,%ecx
 804ab18:	a1 90 23 05 08       	mov    0x8052390,%eax
 804ab1d:	8b 15 94 23 05 08    	mov    0x8052394,%edx
 804ab23:	85 c9                	test   %ecx,%ecx
 804ab25:	75 10                	jne    804ab37 <hwm_main_loop+0x76>
 804ab27:	8b 0d 5c 12 05 08    	mov    0x805125c,%ecx
 804ab2d:	39 05 58 12 05 08    	cmp    %eax,0x8051258
 804ab33:	19 d1                	sbb    %edx,%ecx
 804ab35:	73 38                	jae    804ab6f <hwm_main_loop+0xae>
				((long double)simu_time)/1.0e6L);
 804ab37:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804ab3a:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804ab3d:	df 6d f0             	fildll -0x10(%ebp)
 804ab40:	85 d2                	test   %edx,%edx
 804ab42:	79 06                	jns    804ab4a <hwm_main_loop+0x89>
 804ab44:	d8 05 18 e1 04 08    	fadds  0x804e118
		posix_print_trace("\nStopped at %.3Lfs\n",
 804ab4a:	d8 35 1c e1 04 08    	fdivs  0x804e11c
 804ab50:	83 ec 0c             	sub    $0xc,%esp
 804ab53:	db 3c 24             	fstpt  (%esp)
 804ab56:	68 b2 e4 04 08       	push   $0x804e4b2
 804ab5b:	e8 0a 0d 00 00       	call   804b86a <posix_print_trace>
		posix_exit(0);
 804ab60:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804ab67:	e8 6f 0b 00 00       	call   804b6db <posix_exit>
 804ab6c:	83 c4 10             	add    $0x10,%esp
	while (1) {
		hwm_sleep_until_next_timer();

		switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
 804ab6f:	a1 74 12 05 08       	mov    0x8051274,%eax
 804ab74:	83 f8 01             	cmp    $0x1,%eax
 804ab77:	74 10                	je     804ab89 <hwm_main_loop+0xc8>
 804ab79:	83 f8 02             	cmp    $0x2,%eax
 804ab7c:	74 12                	je     804ab90 <hwm_main_loop+0xcf>
 804ab7e:	85 c0                	test   %eax,%eax
 804ab80:	75 15                	jne    804ab97 <hwm_main_loop+0xd6>
		case HWTIMER:
			hwtimer_timer_reached();
 804ab82:	e8 92 04 00 00       	call   804b019 <hwtimer_timer_reached>
			break;
 804ab87:	eb 1e                	jmp    804aba7 <hwm_main_loop+0xe6>
		case IRQCNT:
			hw_irq_ctrl_timer_triggered();
 804ab89:	e8 30 0b 00 00       	call   804b6be <hw_irq_ctrl_timer_triggered>
			break;
 804ab8e:	eb 17                	jmp    804aba7 <hwm_main_loop+0xe6>
		case HW_COUNTER:
			hw_counter_triggered();
 804ab90:	e8 dc 15 00 00       	call   804c171 <hw_counter_triggered>
			break;
 804ab95:	eb 10                	jmp    804aba7 <hwm_main_loop+0xe6>
			sdl_handle_events();
			break;
#endif
		default:
			/* LCOV_EXCL_START */
			posix_print_error_and_exit(
 804ab97:	83 ec 0c             	sub    $0xc,%esp
 804ab9a:	68 c6 e4 04 08       	push   $0x804e4c6
 804ab9f:	e8 74 0c 00 00       	call   804b818 <posix_print_error_and_exit>
 804aba4:	83 c4 10             	add    $0x10,%esp
					"next_timer_index corrupted\n");
			break;
			/* LCOV_EXCL_STOP */
		}

		hwm_find_next_timer();
 804aba7:	e8 90 fe ff ff       	call   804aa3c <hwm_find_next_timer>
		hwm_sleep_until_next_timer();
 804abac:	e9 1c ff ff ff       	jmp    804aacd <hwm_main_loop+0xc>

0804abb1 <hwm_set_end_of_time>:

/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
 804abb1:	f3 0f 1e fb          	endbr32 
 804abb5:	55                   	push   %ebp
 804abb6:	89 e5                	mov    %esp,%ebp
	end_of_time = new_end_of_time;
 804abb8:	8b 45 08             	mov    0x8(%ebp),%eax
 804abbb:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804abbe:	5d                   	pop    %ebp
	end_of_time = new_end_of_time;
 804abbf:	a3 58 12 05 08       	mov    %eax,0x8051258
 804abc4:	89 15 5c 12 05 08    	mov    %edx,0x805125c
}
 804abca:	c3                   	ret    

0804abcb <hwm_get_time>:

/**
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
 804abcb:	f3 0f 1e fb          	endbr32 
	return simu_time;
}
 804abcf:	a1 90 23 05 08       	mov    0x8052390,%eax
 804abd4:	8b 15 94 23 05 08    	mov    0x8052394,%edx
 804abda:	c3                   	ret    

0804abdb <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
 804abdb:	f3 0f 1e fb          	endbr32 
 804abdf:	55                   	push   %ebp
 804abe0:	89 e5                	mov    %esp,%ebp
 804abe2:	83 ec 08             	sub    $0x8,%esp
	hwm_set_sig_handler();
 804abe5:	e8 99 fd ff ff       	call   804a983 <hwm_set_sig_handler>
	hwtimer_init();
 804abea:	e8 a4 02 00 00       	call   804ae93 <hwtimer_init>
	hw_counter_init();
 804abef:	e8 21 15 00 00       	call   804c115 <hw_counter_init>
	hw_irq_ctrl_init();
 804abf4:	e8 6b 08 00 00       	call   804b464 <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
 804abf9:	c9                   	leave  
	hwm_find_next_timer();
 804abfa:	e9 3d fe ff ff       	jmp    804aa3c <hwm_find_next_timer>

0804abff <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
 804abff:	f3 0f 1e fb          	endbr32 
 804ac03:	55                   	push   %ebp
 804ac04:	89 e5                	mov    %esp,%ebp
 804ac06:	83 ec 08             	sub    $0x8,%esp
	hwtimer_cleanup();
 804ac09:	e8 c4 03 00 00       	call   804afd2 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
 804ac0e:	c9                   	leave  
	hw_irq_ctrl_cleanup();
 804ac0f:	e9 9a 08 00 00       	jmp    804b4ae <hw_irq_ctrl_cleanup>

0804ac14 <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804ac14:	8b 0d cc 23 05 08    	mov    0x80523cc,%ecx
 804ac1a:	a1 c4 23 05 08       	mov    0x80523c4,%eax
{
 804ac1f:	55                   	push   %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804ac20:	8b 15 c0 23 05 08    	mov    0x80523c0,%edx
 804ac26:	39 15 c8 23 05 08    	cmp    %edx,0x80523c8
{
 804ac2c:	89 e5                	mov    %esp,%ebp
 804ac2e:	53                   	push   %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804ac2f:	89 cb                	mov    %ecx,%ebx
 804ac31:	19 c3                	sbb    %eax,%ebx
 804ac33:	0f 42 15 c8 23 05 08 	cmovb  0x80523c8,%edx
}
 804ac3a:	5b                   	pop    %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804ac3b:	0f 42 c1             	cmovb  %ecx,%eax
}
 804ac3e:	5d                   	pop    %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804ac3f:	89 15 d0 23 05 08    	mov    %edx,0x80523d0
 804ac45:	a3 d4 23 05 08       	mov    %eax,0x80523d4
}
 804ac4a:	c3                   	ret    

0804ac4b <cmd_realtime_found>:
	}
	hwm_set_end_of_time(args.stop_at*1e6);
}

static void cmd_realtime_found(char *argv, int offset)
{
 804ac4b:	f3 0f 1e fb          	endbr32 
	real_time_mode = new_rt;
 804ac4f:	c6 05 91 12 05 08 01 	movb   $0x1,0x8051291
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(true);
}
 804ac56:	c3                   	ret    

0804ac57 <cmd_no_realtime_found>:

static void cmd_no_realtime_found(char *argv, int offset)
{
 804ac57:	f3 0f 1e fb          	endbr32 
	real_time_mode = new_rt;
 804ac5b:	c6 05 91 12 05 08 00 	movb   $0x0,0x8051291
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(false);
}
 804ac62:	c3                   	ret    

0804ac63 <cmd_rtcoffset_found>:

static void cmd_rtcoffset_found(char *argv, int offset)
{
 804ac63:	f3 0f 1e fb          	endbr32 
 804ac67:	55                   	push   %ebp
 804ac68:	89 e5                	mov    %esp,%ebp
 804ac6a:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
 804ac6d:	d9 05 1c e1 04 08    	flds   0x804e11c
 804ac73:	d9 7d fe             	fnstcw -0x2(%ebp)
 804ac76:	dc 0d 68 20 05 08    	fmull  0x8052068
 804ac7c:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
 804ac80:	80 cc 0c             	or     $0xc,%ah
 804ac83:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
 804ac87:	d9 6d fc             	fldcw  -0x4(%ebp)
 804ac8a:	df 3d a8 23 05 08    	fistpll 0x80523a8
 804ac90:	d9 6d fe             	fldcw  -0x2(%ebp)
}
 804ac93:	c9                   	leave  
 804ac94:	c3                   	ret    

0804ac95 <cmd_rtcreset_found>:
	}
	hwtimer_set_rt_ratio(args.rt_ratio);
}

static void cmd_rtcreset_found(char *argv, int offset)
{
 804ac95:	f3 0f 1e fb          	endbr32 
	reset_rtc = true;
 804ac99:	c6 05 9f 24 05 08 01 	movb   $0x1,0x805249f
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_reset_rtc();
}
 804aca0:	c3                   	ret    

0804aca1 <native_add_time_options>:

static void native_add_time_options(void)
{
 804aca1:	f3 0f 1e fb          	endbr32 
 804aca5:	55                   	push   %ebp
 804aca6:	89 e5                	mov    %esp,%ebp
 804aca8:	83 ec 14             	sub    $0x14,%esp
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
 804acab:	68 c0 10 05 08       	push   $0x80510c0
 804acb0:	e8 f2 12 00 00       	call   804bfa7 <native_add_command_line_opts>
 804acb5:	83 c4 10             	add    $0x10,%esp
}
 804acb8:	c9                   	leave  
 804acb9:	c3                   	ret    

0804acba <cmd_rt_ratio_found>:
{
 804acba:	f3 0f 1e fb          	endbr32 
	if ((args.rt_ratio <= 0)) {
 804acbe:	dd 05 78 20 05 08    	fldl   0x8052078
 804acc4:	d9 ee                	fldz   
 804acc6:	df f1                	fcomip %st(1),%st
 804acc8:	dd d8                	fstp   %st(0)
 804acca:	72 21                	jb     804aced <cmd_rt_ratio_found+0x33>
{
 804accc:	55                   	push   %ebp
 804accd:	89 e5                	mov    %esp,%ebp
 804accf:	83 ec 14             	sub    $0x14,%esp
		posix_print_error_and_exit("The ratio needs to be > 0. "
 804acd2:	68 e2 e4 04 08       	push   $0x804e4e2
 804acd7:	e8 3c 0b 00 00       	call   804b818 <posix_print_error_and_exit>
	clock_ratio = ratio;
 804acdc:	dd 05 78 20 05 08    	fldl   0x8052078
		posix_print_error_and_exit("The ratio needs to be > 0. "
 804ace2:	83 c4 10             	add    $0x10,%esp
	clock_ratio = ratio;
 804ace5:	dd 1d 60 12 05 08    	fstpl  0x8051260
}
 804aceb:	c9                   	leave  
 804acec:	c3                   	ret    
	clock_ratio = ratio;
 804aced:	dd 05 78 20 05 08    	fldl   0x8052078
 804acf3:	dd 1d 60 12 05 08    	fstpl  0x8051260
 804acf9:	c3                   	ret    

0804acfa <cmd_rt_drift_found>:
{
 804acfa:	f3 0f 1e fb          	endbr32 
 804acfe:	55                   	push   %ebp
	if (!(args.rt_drift > -1)) {
 804acff:	d9 e8                	fld1   
 804ad01:	d9 e0                	fchs   
{
 804ad03:	89 e5                	mov    %esp,%ebp
 804ad05:	83 ec 18             	sub    $0x18,%esp
	if (!(args.rt_drift > -1)) {
 804ad08:	dd 05 70 20 05 08    	fldl   0x8052070
 804ad0e:	df f1                	fcomip %st(1),%st
 804ad10:	dd d8                	fstp   %st(0)
 804ad12:	77 10                	ja     804ad24 <cmd_rt_drift_found+0x2a>
		posix_print_error_and_exit("The drift needs to be > -1. "
 804ad14:	83 ec 0c             	sub    $0xc,%esp
 804ad17:	68 1e e5 04 08       	push   $0x804e51e
 804ad1c:	e8 f7 0a 00 00       	call   804b818 <posix_print_error_and_exit>
 804ad21:	83 c4 10             	add    $0x10,%esp
	args.rt_ratio = args.rt_drift + 1;
 804ad24:	d9 e8                	fld1   
 804ad26:	dc 05 70 20 05 08    	faddl  0x8052070
 804ad2c:	dd 5d f0             	fstpl  -0x10(%ebp)
 804ad2f:	dd 45 f0             	fldl   -0x10(%ebp)
 804ad32:	dd 15 78 20 05 08    	fstl   0x8052078
	clock_ratio = ratio;
 804ad38:	dd 1d 60 12 05 08    	fstpl  0x8051260
}
 804ad3e:	c9                   	leave  
 804ad3f:	c3                   	ret    

0804ad40 <cmd_stop_at_found>:
{
 804ad40:	f3 0f 1e fb          	endbr32 
 804ad44:	55                   	push   %ebp
	if (args.stop_at < 0) {
 804ad45:	d9 ee                	fldz   
{
 804ad47:	89 e5                	mov    %esp,%ebp
 804ad49:	53                   	push   %ebx
 804ad4a:	83 ec 14             	sub    $0x14,%esp
	if (args.stop_at < 0) {
 804ad4d:	dd 05 60 20 05 08    	fldl   0x8052060
 804ad53:	d9 c9                	fxch   %st(1)
{
 804ad55:	8b 45 08             	mov    0x8(%ebp),%eax
	if (args.stop_at < 0) {
 804ad58:	df f1                	fcomip %st(1),%st
 804ad5a:	dd d8                	fstp   %st(0)
 804ad5c:	76 10                	jbe    804ad6e <cmd_stop_at_found+0x2e>
		posix_print_error_and_exit("Error: stop-at must be positive "
 804ad5e:	52                   	push   %edx
 804ad5f:	52                   	push   %edx
 804ad60:	50                   	push   %eax
 804ad61:	68 5b e5 04 08       	push   $0x804e55b
 804ad66:	e8 ad 0a 00 00       	call   804b818 <posix_print_error_and_exit>
 804ad6b:	83 c4 10             	add    $0x10,%esp
	hwm_set_end_of_time(args.stop_at*1e6);
 804ad6e:	d9 05 1c e1 04 08    	flds   0x804e11c
 804ad74:	dc 0d 60 20 05 08    	fmull  0x8052060
 804ad7a:	d9 05 20 e1 04 08    	flds   0x804e120
 804ad80:	d9 c9                	fxch   %st(1)
 804ad82:	db f1                	fcomi  %st(1),%st
 804ad84:	73 21                	jae    804ada7 <cmd_stop_at_found+0x67>
 804ad86:	dd d9                	fstp   %st(1)
 804ad88:	d9 7d f6             	fnstcw -0xa(%ebp)
 804ad8b:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
 804ad8f:	80 cc 0c             	or     $0xc,%ah
 804ad92:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
 804ad96:	d9 6d f4             	fldcw  -0xc(%ebp)
 804ad99:	df 7d e8             	fistpll -0x18(%ebp)
 804ad9c:	d9 6d f6             	fldcw  -0xa(%ebp)
 804ad9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ada2:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804ada5:	eb 27                	jmp    804adce <cmd_stop_at_found+0x8e>
 804ada7:	d9 7d f6             	fnstcw -0xa(%ebp)
 804adaa:	de e1                	fsubp  %st,%st(1)
 804adac:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
 804adb0:	80 cc 0c             	or     $0xc,%ah
 804adb3:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
 804adb7:	d9 6d f4             	fldcw  -0xc(%ebp)
 804adba:	df 7d e8             	fistpll -0x18(%ebp)
 804adbd:	d9 6d f6             	fldcw  -0xa(%ebp)
 804adc0:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804adc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804adc6:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804adcc:	89 ca                	mov    %ecx,%edx
 804adce:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804add1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	hwm_set_end_of_time(args.stop_at*1e6);
 804add4:	89 55 0c             	mov    %edx,0xc(%ebp)
}
 804add7:	c9                   	leave  
	hwm_set_end_of_time(args.stop_at*1e6);
 804add8:	e9 d4 fd ff ff       	jmp    804abb1 <hwm_set_end_of_time>

0804addd <get_host_us_time>:
{
 804addd:	f3 0f 1e fb          	endbr32 
 804ade1:	55                   	push   %ebp
 804ade2:	89 e5                	mov    %esp,%ebp
 804ade4:	53                   	push   %ebx
 804ade5:	83 ec 2c             	sub    $0x2c,%esp
 804ade8:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804adee:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804adf1:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
 804adf3:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804adf6:	50                   	push   %eax
 804adf7:	6a 04                	push   $0x4
 804adf9:	e8 52 e5 ff ff       	call   8049350 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804adfe:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ae01:	db 45 ec             	fildl  -0x14(%ebp)
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
 804ae04:	83 c4 10             	add    $0x10,%esp
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804ae07:	99                   	cltd   
 804ae08:	85 d2                	test   %edx,%edx
 804ae0a:	79 06                	jns    804ae12 <get_host_us_time+0x35>
 804ae0c:	d8 05 18 e1 04 08    	fadds  0x804e118
 804ae12:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ae15:	d8 0d 1c e1 04 08    	fmuls  0x804e11c
 804ae1b:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804ae20:	99                   	cltd   
 804ae21:	f7 f9                	idiv   %ecx
 804ae23:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804ae26:	da 45 d8             	fiaddl -0x28(%ebp)
 804ae29:	d9 05 20 e1 04 08    	flds   0x804e120
 804ae2f:	d9 c9                	fxch   %st(1)
 804ae31:	db f1                	fcomi  %st(1),%st
 804ae33:	73 21                	jae    804ae56 <get_host_us_time+0x79>
 804ae35:	dd d9                	fstp   %st(1)
 804ae37:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804ae3a:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804ae3e:	80 cc 0c             	or     $0xc,%ah
 804ae41:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804ae45:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804ae48:	df 7d d8             	fistpll -0x28(%ebp)
 804ae4b:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804ae4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804ae51:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804ae54:	eb 27                	jmp    804ae7d <get_host_us_time+0xa0>
 804ae56:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804ae59:	de e1                	fsubp  %st,%st(1)
 804ae5b:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804ae5f:	80 cc 0c             	or     $0xc,%ah
 804ae62:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804ae66:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804ae69:	df 7d d8             	fistpll -0x28(%ebp)
 804ae6c:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804ae6f:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804ae72:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804ae75:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804ae7b:	89 ca                	mov    %ecx,%edx
}
 804ae7d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
 804ae80:	65 33 1d 14 00 00 00 	xor    %gs:0x14,%ebx
 804ae87:	74 05                	je     804ae8e <get_host_us_time+0xb1>
 804ae89:	e8 02 e5 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804ae8e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804ae91:	c9                   	leave  
 804ae92:	c3                   	ret    

0804ae93 <hwtimer_init>:
{
 804ae93:	f3 0f 1e fb          	endbr32 
 804ae97:	55                   	push   %ebp
 804ae98:	89 e5                	mov    %esp,%ebp
 804ae9a:	53                   	push   %ebx
 804ae9b:	83 ec 24             	sub    $0x24,%esp
 804ae9e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804aea4:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804aea7:	31 c0                	xor    %eax,%eax
	silent_ticks = 0;
 804aea9:	c7 05 b0 23 05 08 00 	movl   $0x0,0x80523b0
 804aeb0:	00 00 00 
 804aeb3:	c7 05 b4 23 05 08 00 	movl   $0x0,0x80523b4
 804aeba:	00 00 00 
	hw_timer_tick_timer = NEVER;
 804aebd:	c7 05 c8 23 05 08 ff 	movl   $0xffffffff,0x80523c8
 804aec4:	ff ff ff 
 804aec7:	c7 05 cc 23 05 08 ff 	movl   $0xffffffff,0x80523cc
 804aece:	ff ff ff 
	hw_timer_awake_timer = NEVER;
 804aed1:	c7 05 c0 23 05 08 ff 	movl   $0xffffffff,0x80523c0
 804aed8:	ff ff ff 
 804aedb:	c7 05 c4 23 05 08 ff 	movl   $0xffffffff,0x80523c4
 804aee2:	ff ff ff 
	hwtimer_update_timer();
 804aee5:	e8 2a fd ff ff       	call   804ac14 <hwtimer_update_timer>
	if (real_time_mode) {
 804aeea:	80 3d 91 12 05 08 00 	cmpb   $0x0,0x8051291
 804aef1:	74 24                	je     804af17 <hwtimer_init+0x84>
		boot_time = get_host_us_time();
 804aef3:	e8 e5 fe ff ff       	call   804addd <get_host_us_time>
		last_radj_stime = 0U;
 804aef8:	c7 05 98 23 05 08 00 	movl   $0x0,0x8052398
 804aeff:	00 00 00 
		last_radj_rtime = boot_time;
 804af02:	a3 a0 23 05 08       	mov    %eax,0x80523a0
 804af07:	89 15 a4 23 05 08    	mov    %edx,0x80523a4
		last_radj_stime = 0U;
 804af0d:	c7 05 9c 23 05 08 00 	movl   $0x0,0x805239c
 804af14:	00 00 00 
	if (!reset_rtc) {
 804af17:	80 3d 9f 24 05 08 00 	cmpb   $0x0,0x805249f
 804af1e:	0f 85 98 00 00 00    	jne    804afbc <hwtimer_init+0x129>
		clock_gettime(CLOCK_REALTIME, &tv);
 804af24:	50                   	push   %eax
 804af25:	50                   	push   %eax
 804af26:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804af29:	50                   	push   %eax
 804af2a:	6a 00                	push   $0x0
 804af2c:	e8 1f e4 ff ff       	call   8049350 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804af31:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804af34:	db 45 ec             	fildl  -0x14(%ebp)
		clock_gettime(CLOCK_REALTIME, &tv);
 804af37:	83 c4 10             	add    $0x10,%esp
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804af3a:	99                   	cltd   
 804af3b:	85 d2                	test   %edx,%edx
 804af3d:	79 06                	jns    804af45 <hwtimer_init+0xb2>
 804af3f:	d8 05 18 e1 04 08    	fadds  0x804e118
 804af45:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804af48:	d8 0d 1c e1 04 08    	fmuls  0x804e11c
 804af4e:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804af53:	99                   	cltd   
 804af54:	f7 f9                	idiv   %ecx
 804af56:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804af59:	da 45 d8             	fiaddl -0x28(%ebp)
 804af5c:	d9 05 20 e1 04 08    	flds   0x804e120
 804af62:	d9 c9                	fxch   %st(1)
 804af64:	db f1                	fcomi  %st(1),%st
 804af66:	73 21                	jae    804af89 <hwtimer_init+0xf6>
 804af68:	dd d9                	fstp   %st(1)
 804af6a:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804af6d:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804af71:	80 cc 0c             	or     $0xc,%ah
 804af74:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804af78:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804af7b:	df 7d d8             	fistpll -0x28(%ebp)
 804af7e:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804af81:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804af84:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804af87:	eb 27                	jmp    804afb0 <hwtimer_init+0x11d>
 804af89:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804af8c:	de e1                	fsubp  %st,%st(1)
 804af8e:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804af92:	80 cc 0c             	or     $0xc,%ah
 804af95:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804af99:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804af9c:	df 7d d8             	fistpll -0x28(%ebp)
 804af9f:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804afa2:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804afa5:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804afa8:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804afae:	89 ca                	mov    %ecx,%edx
		rtc_offset += realhosttime;
 804afb0:	01 05 a8 23 05 08    	add    %eax,0x80523a8
 804afb6:	11 15 ac 23 05 08    	adc    %edx,0x80523ac
}
 804afbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804afbf:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804afc6:	74 05                	je     804afcd <hwtimer_init+0x13a>
 804afc8:	e8 c3 e3 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804afcd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804afd0:	c9                   	leave  
 804afd1:	c3                   	ret    

0804afd2 <hwtimer_cleanup>:
{
 804afd2:	f3 0f 1e fb          	endbr32 
}
 804afd6:	c3                   	ret    

0804afd7 <hwtimer_enable>:
{
 804afd7:	f3 0f 1e fb          	endbr32 
 804afdb:	55                   	push   %ebp
 804afdc:	89 e5                	mov    %esp,%ebp
 804afde:	83 ec 08             	sub    $0x8,%esp
	tick_p = period;
 804afe1:	8b 45 08             	mov    0x8(%ebp),%eax
 804afe4:	8b 55 0c             	mov    0xc(%ebp),%edx
 804afe7:	a3 b8 23 05 08       	mov    %eax,0x80523b8
 804afec:	89 15 bc 23 05 08    	mov    %edx,0x80523bc
	hw_timer_tick_timer = hwm_get_time() + tick_p;
 804aff2:	e8 d4 fb ff ff       	call   804abcb <hwm_get_time>
 804aff7:	03 05 b8 23 05 08    	add    0x80523b8,%eax
 804affd:	13 15 bc 23 05 08    	adc    0x80523bc,%edx
 804b003:	a3 c8 23 05 08       	mov    %eax,0x80523c8
 804b008:	89 15 cc 23 05 08    	mov    %edx,0x80523cc
	hwtimer_update_timer();
 804b00e:	e8 01 fc ff ff       	call   804ac14 <hwtimer_update_timer>
}
 804b013:	c9                   	leave  
	hwm_find_next_timer();
 804b014:	e9 23 fa ff ff       	jmp    804aa3c <hwm_find_next_timer>

0804b019 <hwtimer_timer_reached>:
{
 804b019:	f3 0f 1e fb          	endbr32 
 804b01d:	55                   	push   %ebp
 804b01e:	89 e5                	mov    %esp,%ebp
 804b020:	56                   	push   %esi
 804b021:	53                   	push   %ebx
 804b022:	83 ec 30             	sub    $0x30,%esp
	uint64_t Now = hw_timer_timer;
 804b025:	8b 1d d0 23 05 08    	mov    0x80523d0,%ebx
 804b02b:	8b 35 d4 23 05 08    	mov    0x80523d4,%esi
{
 804b031:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804b037:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b03a:	31 c0                	xor    %eax,%eax
	if (hw_timer_awake_timer == Now) {
 804b03c:	39 35 c4 23 05 08    	cmp    %esi,0x80523c4
 804b042:	75 31                	jne    804b075 <hwtimer_timer_reached+0x5c>
 804b044:	39 1d c0 23 05 08    	cmp    %ebx,0x80523c0
 804b04a:	75 29                	jne    804b075 <hwtimer_timer_reached+0x5c>
	hw_timer_awake_timer = NEVER;
 804b04c:	c7 05 c0 23 05 08 ff 	movl   $0xffffffff,0x80523c0
 804b053:	ff ff ff 
 804b056:	c7 05 c4 23 05 08 ff 	movl   $0xffffffff,0x80523c4
 804b05d:	ff ff ff 
	hwtimer_update_timer();
 804b060:	e8 af fb ff ff       	call   804ac14 <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
 804b065:	83 ec 0c             	sub    $0xc,%esp
 804b068:	68 ff ff 00 00       	push   $0xffff
 804b06d:	e8 a2 05 00 00       	call   804b614 <hw_irq_ctrl_set_irq>
 804b072:	83 c4 10             	add    $0x10,%esp
	if (hw_timer_tick_timer == Now) {
 804b075:	8b 15 cc 23 05 08    	mov    0x80523cc,%edx
 804b07b:	a1 c8 23 05 08       	mov    0x80523c8,%eax
 804b080:	39 f2                	cmp    %esi,%edx
 804b082:	0f 85 5a 01 00 00    	jne    804b1e2 <hwtimer_timer_reached+0x1c9>
 804b088:	39 d8                	cmp    %ebx,%eax
 804b08a:	0f 85 52 01 00 00    	jne    804b1e2 <hwtimer_timer_reached+0x1c9>
	if (real_time_mode) {
 804b090:	80 3d 91 12 05 08 00 	cmpb   $0x0,0x8051291
 804b097:	0f 84 f6 00 00 00    	je     804b193 <hwtimer_timer_reached+0x17a>
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
 804b09d:	2b 05 98 23 05 08    	sub    0x8052398,%eax
 804b0a3:	1b 15 9c 23 05 08    	sbb    0x805239c,%edx
				    / clock_ratio
 804b0a9:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804b0ac:	89 55 cc             	mov    %edx,-0x34(%ebp)
 804b0af:	df 6d c8             	fildll -0x38(%ebp)
 804b0b2:	85 d2                	test   %edx,%edx
 804b0b4:	79 06                	jns    804b0bc <hwtimer_timer_reached+0xa3>
 804b0b6:	d8 05 18 e1 04 08    	fadds  0x804e118
 804b0bc:	dc 35 60 12 05 08    	fdivl  0x8051260
				    + last_radj_rtime;
 804b0c2:	83 3d a4 23 05 08 00 	cmpl   $0x0,0x80523a4
 804b0c9:	df 2d a0 23 05 08    	fildll 0x80523a0
 804b0cf:	79 06                	jns    804b0d7 <hwtimer_timer_reached+0xbe>
 804b0d1:	d8 05 18 e1 04 08    	fadds  0x804e118
 804b0d7:	de c1                	faddp  %st,%st(1)
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
 804b0d9:	d9 05 20 e1 04 08    	flds   0x804e120
 804b0df:	d9 c9                	fxch   %st(1)
 804b0e1:	db f1                	fcomi  %st(1),%st
 804b0e3:	73 1b                	jae    804b100 <hwtimer_timer_reached+0xe7>
 804b0e5:	dd d9                	fstp   %st(1)
 804b0e7:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804b0ea:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804b0ee:	80 cc 0c             	or     $0xc,%ah
 804b0f1:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804b0f5:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b0f8:	df 7d c8             	fistpll -0x38(%ebp)
 804b0fb:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804b0fe:	eb 24                	jmp    804b124 <hwtimer_timer_reached+0x10b>
 804b100:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804b103:	de e1                	fsubp  %st,%st(1)
 804b105:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804b109:	80 cc 0c             	or     $0xc,%ah
 804b10c:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804b110:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b113:	df 7d c8             	fistpll -0x38(%ebp)
 804b116:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804b119:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b11c:	05 00 00 00 80       	add    $0x80000000,%eax
 804b121:	89 45 cc             	mov    %eax,-0x34(%ebp)
		uint64_t real_time = get_host_us_time();
 804b124:	e8 b4 fc ff ff       	call   804addd <get_host_us_time>
		int64_t diff = expected_rt - real_time;
 804b129:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 804b12c:	8b 5d cc             	mov    -0x34(%ebp),%ebx
 804b12f:	29 c1                	sub    %eax,%ecx
 804b131:	19 d3                	sbb    %edx,%ebx
 804b133:	89 4d c8             	mov    %ecx,-0x38(%ebp)
		if (diff > 0) { /* we need to slow down */
 804b136:	31 c0                	xor    %eax,%eax
 804b138:	3b 45 c8             	cmp    -0x38(%ebp),%eax
		int64_t diff = expected_rt - real_time;
 804b13b:	89 5d cc             	mov    %ebx,-0x34(%ebp)
		if (diff > 0) { /* we need to slow down */
 804b13e:	1b 45 cc             	sbb    -0x34(%ebp),%eax
 804b141:	7d 50                	jge    804b193 <hwtimer_timer_reached+0x17a>
			requested_time.tv_sec  = diff / 1e6;
 804b143:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804b146:	df 6d c8             	fildll -0x38(%ebp)
 804b149:	d9 05 1c e1 04 08    	flds   0x804e11c
 804b14f:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804b153:	d9 c1                	fld    %st(1)
 804b155:	d8 f1                	fdiv   %st(1),%st
 804b157:	80 cc 0c             	or     $0xc,%ah
 804b15a:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804b15e:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b161:	db 5d c8             	fistpl -0x38(%ebp)
 804b164:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804b167:	8b 45 c8             	mov    -0x38(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
 804b16a:	da 4d c8             	fimull -0x38(%ebp)
			requested_time.tv_sec  = diff / 1e6;
 804b16d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			(void) nanosleep(&requested_time, &remaining);
 804b170:	50                   	push   %eax
 804b171:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
 804b172:	de e9                	fsubrp %st,%st(1)
			(void) nanosleep(&requested_time, &remaining);
 804b174:	8d 45 ec             	lea    -0x14(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
 804b177:	d8 0d 24 e1 04 08    	fmuls  0x804e124
			(void) nanosleep(&requested_time, &remaining);
 804b17d:	50                   	push   %eax
 804b17e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804b181:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
 804b182:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b185:	db 5d e8             	fistpl -0x18(%ebp)
 804b188:	d9 6d d6             	fldcw  -0x2a(%ebp)
			(void) nanosleep(&requested_time, &remaining);
 804b18b:	e8 40 e3 ff ff       	call   80494d0 <nanosleep@plt>
 804b190:	83 c4 10             	add    $0x10,%esp
	hw_timer_tick_timer += tick_p;
 804b193:	a1 b8 23 05 08       	mov    0x80523b8,%eax
 804b198:	8b 15 bc 23 05 08    	mov    0x80523bc,%edx
 804b19e:	01 05 c8 23 05 08    	add    %eax,0x80523c8
 804b1a4:	11 15 cc 23 05 08    	adc    %edx,0x80523cc
	hwtimer_update_timer();
 804b1aa:	e8 65 fa ff ff       	call   804ac14 <hwtimer_update_timer>
	if (silent_ticks > 0) {
 804b1af:	a1 b0 23 05 08       	mov    0x80523b0,%eax
 804b1b4:	31 c9                	xor    %ecx,%ecx
 804b1b6:	8b 15 b4 23 05 08    	mov    0x80523b4,%edx
 804b1bc:	39 c1                	cmp    %eax,%ecx
 804b1be:	19 d1                	sbb    %edx,%ecx
 804b1c0:	7d 13                	jge    804b1d5 <hwtimer_timer_reached+0x1bc>
		silent_ticks -= 1;
 804b1c2:	83 c0 ff             	add    $0xffffffff,%eax
 804b1c5:	83 d2 ff             	adc    $0xffffffff,%edx
 804b1c8:	a3 b0 23 05 08       	mov    %eax,0x80523b0
 804b1cd:	89 15 b4 23 05 08    	mov    %edx,0x80523b4
 804b1d3:	eb 0d                	jmp    804b1e2 <hwtimer_timer_reached+0x1c9>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
 804b1d5:	83 ec 0c             	sub    $0xc,%esp
 804b1d8:	6a 00                	push   $0x0
 804b1da:	e8 35 04 00 00       	call   804b614 <hw_irq_ctrl_set_irq>
 804b1df:	83 c4 10             	add    $0x10,%esp
}
 804b1e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b1e5:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804b1ec:	74 05                	je     804b1f3 <hwtimer_timer_reached+0x1da>
 804b1ee:	e8 9d e1 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804b1f3:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804b1f6:	5b                   	pop    %ebx
 804b1f7:	5e                   	pop    %esi
 804b1f8:	5d                   	pop    %ebp
 804b1f9:	c3                   	ret    

0804b1fa <hwtimer_set_silent_ticks>:
{
 804b1fa:	f3 0f 1e fb          	endbr32 
 804b1fe:	55                   	push   %ebp
 804b1ff:	89 e5                	mov    %esp,%ebp
	silent_ticks = sys_ticks;
 804b201:	8b 45 08             	mov    0x8(%ebp),%eax
 804b204:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804b207:	5d                   	pop    %ebp
	silent_ticks = sys_ticks;
 804b208:	a3 b0 23 05 08       	mov    %eax,0x80523b0
 804b20d:	89 15 b4 23 05 08    	mov    %edx,0x80523b4
}
 804b213:	c3                   	ret    

0804b214 <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
 804b214:	f3 0f 1e fb          	endbr32 
 804b218:	55                   	push   %ebp
 804b219:	89 e5                	mov    %esp,%ebp
 804b21b:	57                   	push   %edi
 804b21c:	56                   	push   %esi
 804b21d:	53                   	push   %ebx
 804b21e:	83 ec 0c             	sub    $0xc,%esp
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
 804b221:	e8 67 03 00 00       	call   804b58d <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
 804b226:	85 c0                	test   %eax,%eax
 804b228:	0f 85 f9 00 00 00    	jne    804b327 <posix_irq_handler+0x113>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
 804b22e:	a1 60 23 05 08       	mov    0x8052360,%eax
 804b233:	85 c0                	test   %eax,%eax
 804b235:	75 0a                	jne    804b241 <posix_irq_handler+0x2d>
		may_swap = 0;
 804b237:	c7 05 6c 24 05 08 00 	movl   $0x0,0x805246c
 804b23e:	00 00 00 
	}

	_kernel.cpus[0].nested++;
 804b241:	40                   	inc    %eax
 804b242:	a3 60 23 05 08       	mov    %eax,0x8052360

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
 804b247:	e8 a9 02 00 00       	call   804b4f5 <hw_irq_ctrl_get_highest_prio_irq>
 804b24c:	89 c3                	mov    %eax,%ebx
 804b24e:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b251:	0f 84 9b 00 00 00    	je     804b2f2 <posix_irq_handler+0xde>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
 804b257:	e8 68 02 00 00       	call   804b4c4 <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804b25c:	83 ec 0c             	sub    $0xc,%esp
		int last_running_irq = currently_running_irq;
 804b25f:	8b 3d 78 12 05 08    	mov    0x8051278,%edi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804b265:	53                   	push   %ebx
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
 804b266:	89 c6                	mov    %eax,%esi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804b268:	e8 76 02 00 00       	call   804b4e3 <hw_irq_ctrl_get_prio>
 804b26d:	0f b6 c0             	movzbl %al,%eax
 804b270:	89 04 24             	mov    %eax,(%esp)
 804b273:	e8 3b 02 00 00       	call   804b4b3 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
 804b278:	89 1c 24             	mov    %ebx,(%esp)
 804b27b:	e8 53 03 00 00       	call   804b5d3 <hw_irq_ctrl_clear_irq>
 804b280:	83 c4 10             	add    $0x10,%esp

		currently_running_irq = irq_nbr;
 804b283:	89 1d 78 12 05 08    	mov    %ebx,0x8051278
	sys_trace_isr_enter();
 804b289:	e8 bb ee ff ff       	call   804a149 <sys_trace_isr_enter>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
 804b28e:	89 d8                	mov    %ebx,%eax
 804b290:	c1 e0 04             	shl    $0x4,%eax
 804b293:	05 80 20 05 08       	add    $0x8052080,%eax
 804b298:	8b 50 08             	mov    0x8(%eax),%edx
 804b29b:	85 d2                	test   %edx,%edx
 804b29d:	75 12                	jne    804b2b1 <posix_irq_handler+0x9d>
		posix_print_error_and_exit("Received irq %i without a "
 804b29f:	50                   	push   %eax
 804b2a0:	50                   	push   %eax
 804b2a1:	53                   	push   %ebx
 804b2a2:	68 5a e9 04 08       	push   $0x804e95a
 804b2a7:	e8 6c 05 00 00       	call   804b818 <posix_print_error_and_exit>
 804b2ac:	83 c4 10             	add    $0x10,%esp
 804b2af:	eb 25                	jmp    804b2d6 <posix_irq_handler+0xc2>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
 804b2b1:	f6 40 04 01          	testb  $0x1,0x4(%eax)
 804b2b5:	74 0a                	je     804b2c1 <posix_irq_handler+0xad>
			*may_swap |= ((direct_irq_f_ptr)
 804b2b7:	ff d2                	call   *%edx
 804b2b9:	09 05 6c 24 05 08    	or     %eax,0x805246c
 804b2bf:	eb 15                	jmp    804b2d6 <posix_irq_handler+0xc2>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
 804b2c1:	83 ec 0c             	sub    $0xc,%esp
 804b2c4:	ff 70 0c             	pushl  0xc(%eax)
 804b2c7:	ff d2                	call   *%edx
			*may_swap = 1;
 804b2c9:	c7 05 6c 24 05 08 01 	movl   $0x1,0x805246c
 804b2d0:	00 00 00 
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
 804b2d3:	83 c4 10             	add    $0x10,%esp
	sys_trace_isr_exit();
 804b2d6:	e8 73 ee ff ff       	call   804a14e <sys_trace_isr_exit>
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
 804b2db:	83 ec 0c             	sub    $0xc,%esp
		currently_running_irq = last_running_irq;
 804b2de:	89 3d 78 12 05 08    	mov    %edi,0x8051278
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
 804b2e4:	56                   	push   %esi
 804b2e5:	e8 c9 01 00 00       	call   804b4b3 <hw_irq_ctrl_set_cur_prio>
 804b2ea:	83 c4 10             	add    $0x10,%esp
 804b2ed:	e9 55 ff ff ff       	jmp    804b247 <posix_irq_handler+0x33>
	}

	_kernel.cpus[0].nested--;
 804b2f2:	ff 0d 60 23 05 08    	decl   0x8052360
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
 804b2f8:	83 3d 6c 24 05 08 00 	cmpl   $0x0,0x805246c
 804b2ff:	74 26                	je     804b327 <posix_irq_handler+0x113>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
 804b301:	e8 be 01 00 00       	call   804b4c4 <hw_irq_ctrl_get_cur_prio>
 804b306:	3d 00 01 00 00       	cmp    $0x100,%eax
 804b30b:	75 1a                	jne    804b327 <posix_irq_handler+0x113>
		&& (_kernel.ready_q.cache != _current)) {
 804b30d:	a1 68 23 05 08       	mov    0x8052368,%eax
 804b312:	39 05 78 23 05 08    	cmp    %eax,0x8052378
 804b318:	74 0d                	je     804b327 <posix_irq_handler+0x113>

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
 804b31a:	83 ec 0c             	sub    $0xc,%esp
 804b31d:	6a 00                	push   $0x0
 804b31f:	e8 de f2 ff ff       	call   804a602 <arch_swap>
 804b324:	83 c4 10             	add    $0x10,%esp

		(void)z_swap_irqlock(irq_lock);
	}
}
 804b327:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b32a:	5b                   	pop    %ebx
 804b32b:	5e                   	pop    %esi
 804b32c:	5f                   	pop    %edi
 804b32d:	5d                   	pop    %ebp
 804b32e:	c3                   	ret    

0804b32f <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
 804b32f:	f3 0f 1e fb          	endbr32 
 804b333:	55                   	push   %ebp
 804b334:	89 e5                	mov    %esp,%ebp
 804b336:	83 ec 08             	sub    $0x8,%esp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
 804b339:	e8 b7 01 00 00       	call   804b4f5 <hw_irq_ctrl_get_highest_prio_irq>
 804b33e:	40                   	inc    %eax
 804b33f:	74 23                	je     804b364 <posix_irq_handler_im_from_sw+0x35>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
 804b341:	e8 d4 f3 ff ff       	call   804a71a <posix_is_cpu_running>
 804b346:	85 c0                	test   %eax,%eax
 804b348:	75 14                	jne    804b35e <posix_irq_handler_im_from_sw+0x2f>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
 804b34a:	50                   	push   %eax
 804b34b:	50                   	push   %eax
 804b34c:	68 2c e1 04 08       	push   $0x804e12c
 804b351:	68 88 e9 04 08       	push   $0x804e988
 804b356:	e8 bd 04 00 00       	call   804b818 <posix_print_error_and_exit>
 804b35b:	83 c4 10             	add    $0x10,%esp
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
 804b35e:	c9                   	leave  
		posix_irq_handler();
 804b35f:	e9 b0 fe ff ff       	jmp    804b214 <posix_irq_handler>
}
 804b364:	c9                   	leave  
 804b365:	c3                   	ret    

0804b366 <posix_irq_lock>:
 * @return An architecture-dependent lock-out key representing the
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
 804b366:	f3 0f 1e fb          	endbr32 
 804b36a:	55                   	push   %ebp
 804b36b:	89 e5                	mov    %esp,%ebp
 804b36d:	83 ec 14             	sub    $0x14,%esp
	return hw_irq_ctrl_change_lock(true);
 804b370:	6a 01                	push   $0x1
 804b372:	e8 22 02 00 00       	call   804b599 <hw_irq_ctrl_change_lock>
 804b377:	83 c4 10             	add    $0x10,%esp
}
 804b37a:	c9                   	leave  
 804b37b:	c3                   	ret    

0804b37c <posix_irq_unlock>:
 * board_irq_lock().
 *
 * This routine can be called from either interrupt, task or fiber level.
 */
void posix_irq_unlock(unsigned int key)
{
 804b37c:	f3 0f 1e fb          	endbr32 
	hw_irq_ctrl_change_lock(key);
 804b380:	e9 14 02 00 00       	jmp    804b599 <hw_irq_ctrl_change_lock>

0804b385 <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
 804b385:	f3 0f 1e fb          	endbr32 
 804b389:	55                   	push   %ebp
 804b38a:	89 e5                	mov    %esp,%ebp
 804b38c:	83 ec 14             	sub    $0x14,%esp
	hw_irq_ctrl_change_lock(false);
 804b38f:	6a 00                	push   $0x0
 804b391:	e8 03 02 00 00       	call   804b599 <hw_irq_ctrl_change_lock>
 804b396:	83 c4 10             	add    $0x10,%esp
}
 804b399:	c9                   	leave  
 804b39a:	c3                   	ret    

0804b39b <posix_irq_enable>:

void posix_irq_enable(unsigned int irq)
{
 804b39b:	f3 0f 1e fb          	endbr32 
	hw_irq_ctrl_enable_irq(irq);
 804b39f:	e9 cf 02 00 00       	jmp    804b673 <hw_irq_ctrl_enable_irq>

0804b3a4 <posix_isr_declare>:
 * @param isr_param_p ISR parameter
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
 804b3a4:	f3 0f 1e fb          	endbr32 
 804b3a8:	55                   	push   %ebp
 804b3a9:	89 e5                	mov    %esp,%ebp
 804b3ab:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_vector_table[irq_p].irq   = irq_p;
 804b3ae:	89 ca                	mov    %ecx,%edx
 804b3b0:	c1 e2 04             	shl    $0x4,%edx
 804b3b3:	8d 82 80 20 05 08    	lea    0x8052080(%edx),%eax
 804b3b9:	89 8a 80 20 05 08    	mov    %ecx,0x8052080(%edx)
	irq_vector_table[irq_p].func  = isr_p;
 804b3bf:	8b 55 10             	mov    0x10(%ebp),%edx
 804b3c2:	89 50 08             	mov    %edx,0x8(%eax)
	irq_vector_table[irq_p].param = isr_param_p;
 804b3c5:	8b 55 14             	mov    0x14(%ebp),%edx
 804b3c8:	89 50 0c             	mov    %edx,0xc(%eax)
	irq_vector_table[irq_p].flags = flags;
 804b3cb:	8b 55 0c             	mov    0xc(%ebp),%edx
 804b3ce:	89 50 04             	mov    %edx,0x4(%eax)
}
 804b3d1:	5d                   	pop    %ebp
 804b3d2:	c3                   	ret    

0804b3d3 <posix_irq_priority_set>:
 * @brief Set an interrupt's priority
 *
 * Lower values take priority over higher values.
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
 804b3d3:	f3 0f 1e fb          	endbr32 
	hw_irq_ctrl_prio_set(irq, prio);
 804b3d7:	e9 f2 00 00 00       	jmp    804b4ce <hw_irq_ctrl_prio_set>

0804b3dc <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
 804b3dc:	80 3d a1 24 05 08 00 	cmpb   $0x0,0x80524a1
 804b3e3:	74 09                	je     804b3ee <irq_raising_from_hw_now+0x12>
 804b3e5:	80 3d a0 24 05 08 00 	cmpb   $0x0,0x80524a0
 804b3ec:	74 0c                	je     804b3fa <irq_raising_from_hw_now+0x1e>
		lock_ignore = false;
 804b3ee:	c6 05 a0 24 05 08 00 	movb   $0x0,0x80524a0
		posix_interrupt_raised();
 804b3f5:	e9 b6 f3 ff ff       	jmp    804a7b0 <posix_interrupt_raised>
	}
}
 804b3fa:	c3                   	ret    

0804b3fb <hw_irq_ctrl_irq_raise_prefix>:
{
 804b3fb:	89 c1                	mov    %eax,%ecx
	if (irq < N_IRQS) {
 804b3fd:	83 f8 1f             	cmp    $0x1f,%eax
 804b400:	77 4e                	ja     804b450 <hw_irq_ctrl_irq_raise_prefix+0x55>
{
 804b402:	55                   	push   %ebp
		irq_premask |= ((uint64_t)1<<irq);
 804b403:	31 c0                	xor    %eax,%eax
 804b405:	31 d2                	xor    %edx,%edx
 804b407:	f6 c1 20             	test   $0x20,%cl
 804b40a:	0f 94 c0             	sete   %al
 804b40d:	0f 95 c2             	setne  %dl
 804b410:	d3 e2                	shl    %cl,%edx
 804b412:	d3 e0                	shl    %cl,%eax
 804b414:	09 15 e4 23 05 08    	or     %edx,0x80523e4
{
 804b41a:	89 e5                	mov    %esp,%ebp
 804b41c:	56                   	push   %esi
		if (irq_mask & (1 << irq)) {
 804b41d:	be 01 00 00 00       	mov    $0x1,%esi
 804b422:	d3 e6                	shl    %cl,%esi
{
 804b424:	53                   	push   %ebx
		if (irq_mask & (1 << irq)) {
 804b425:	8b 0d dc 23 05 08    	mov    0x80523dc,%ecx
 804b42b:	89 f3                	mov    %esi,%ebx
 804b42d:	23 35 d8 23 05 08    	and    0x80523d8,%esi
		irq_premask |= ((uint64_t)1<<irq);
 804b433:	09 05 e0 23 05 08    	or     %eax,0x80523e0
		if (irq_mask & (1 << irq)) {
 804b439:	c1 fb 1f             	sar    $0x1f,%ebx
 804b43c:	21 d9                	and    %ebx,%ecx
 804b43e:	09 f1                	or     %esi,%ecx
 804b440:	74 1d                	je     804b45f <hw_irq_ctrl_irq_raise_prefix+0x64>
			irq_status |= ((uint64_t)1<<irq);
 804b442:	09 05 e8 23 05 08    	or     %eax,0x80523e8
 804b448:	09 15 ec 23 05 08    	or     %edx,0x80523ec
 804b44e:	eb 0f                	jmp    804b45f <hw_irq_ctrl_irq_raise_prefix+0x64>
	} else if (irq == PHONY_HARD_IRQ) {
 804b450:	3d ff ff 00 00       	cmp    $0xffff,%eax
 804b455:	75 0c                	jne    804b463 <hw_irq_ctrl_irq_raise_prefix+0x68>
		lock_ignore = true;
 804b457:	c6 05 a0 24 05 08 01 	movb   $0x1,0x80524a0
}
 804b45e:	c3                   	ret    
 804b45f:	5b                   	pop    %ebx
 804b460:	5e                   	pop    %esi
 804b461:	5d                   	pop    %ebp
 804b462:	c3                   	ret    
 804b463:	c3                   	ret    

0804b464 <hw_irq_ctrl_init>:
{
 804b464:	f3 0f 1e fb          	endbr32 
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
 804b468:	c7 05 d8 23 05 08 00 	movl   $0x0,0x80523d8
 804b46f:	00 00 00 
	for (int i = 0 ; i < N_IRQS; i++) {
 804b472:	31 c0                	xor    %eax,%eax
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
 804b474:	c7 05 dc 23 05 08 00 	movl   $0x0,0x80523dc
 804b47b:	00 00 00 
	irq_premask = 0U;
 804b47e:	c7 05 e0 23 05 08 00 	movl   $0x0,0x80523e0
 804b485:	00 00 00 
 804b488:	c7 05 e4 23 05 08 00 	movl   $0x0,0x80523e4
 804b48f:	00 00 00 
	irqs_locked = false;
 804b492:	c6 05 a1 24 05 08 00 	movb   $0x0,0x80524a1
	lock_ignore = false;
 804b499:	c6 05 a0 24 05 08 00 	movb   $0x0,0x80524a0
		irq_prio[i] = 255U;
 804b4a0:	c6 80 80 22 05 08 ff 	movb   $0xff,0x8052280(%eax)
	for (int i = 0 ; i < N_IRQS; i++) {
 804b4a7:	40                   	inc    %eax
 804b4a8:	83 f8 20             	cmp    $0x20,%eax
 804b4ab:	75 f3                	jne    804b4a0 <hw_irq_ctrl_init+0x3c>
}
 804b4ad:	c3                   	ret    

0804b4ae <hw_irq_ctrl_cleanup>:
{
 804b4ae:	f3 0f 1e fb          	endbr32 
}
 804b4b2:	c3                   	ret    

0804b4b3 <hw_irq_ctrl_set_cur_prio>:
{
 804b4b3:	f3 0f 1e fb          	endbr32 
 804b4b7:	55                   	push   %ebp
 804b4b8:	89 e5                	mov    %esp,%ebp
	currently_running_prio = new;
 804b4ba:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804b4bd:	5d                   	pop    %ebp
	currently_running_prio = new;
 804b4be:	a3 7c 12 05 08       	mov    %eax,0x805127c
}
 804b4c3:	c3                   	ret    

0804b4c4 <hw_irq_ctrl_get_cur_prio>:
{
 804b4c4:	f3 0f 1e fb          	endbr32 
}
 804b4c8:	a1 7c 12 05 08       	mov    0x805127c,%eax
 804b4cd:	c3                   	ret    

0804b4ce <hw_irq_ctrl_prio_set>:
{
 804b4ce:	f3 0f 1e fb          	endbr32 
 804b4d2:	55                   	push   %ebp
 804b4d3:	89 e5                	mov    %esp,%ebp
	irq_prio[irq] = prio;
 804b4d5:	8b 45 08             	mov    0x8(%ebp),%eax
 804b4d8:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804b4db:	5d                   	pop    %ebp
	irq_prio[irq] = prio;
 804b4dc:	88 90 80 22 05 08    	mov    %dl,0x8052280(%eax)
}
 804b4e2:	c3                   	ret    

0804b4e3 <hw_irq_ctrl_get_prio>:
{
 804b4e3:	f3 0f 1e fb          	endbr32 
 804b4e7:	55                   	push   %ebp
 804b4e8:	89 e5                	mov    %esp,%ebp
	return irq_prio[irq];
 804b4ea:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804b4ed:	5d                   	pop    %ebp
	return irq_prio[irq];
 804b4ee:	8a 80 80 22 05 08    	mov    0x8052280(%eax),%al
}
 804b4f4:	c3                   	ret    

0804b4f5 <hw_irq_ctrl_get_highest_prio_irq>:
{
 804b4f5:	f3 0f 1e fb          	endbr32 
		return -1;
 804b4f9:	83 ca ff             	or     $0xffffffff,%edx
	if (irqs_locked) {
 804b4fc:	80 3d a1 24 05 08 00 	cmpb   $0x0,0x80524a1
 804b503:	0f 85 81 00 00 00    	jne    804b58a <hw_irq_ctrl_get_highest_prio_irq+0x95>
{
 804b509:	55                   	push   %ebp
 804b50a:	89 e5                	mov    %esp,%ebp
 804b50c:	57                   	push   %edi
 804b50d:	56                   	push   %esi
 804b50e:	53                   	push   %ebx
	int winner_prio = 256;
 804b50f:	bb 00 01 00 00       	mov    $0x100,%ebx
{
 804b514:	83 ec 14             	sub    $0x14,%esp
	return irq_status;
 804b517:	8b 3d ec 23 05 08    	mov    0x80523ec,%edi
 804b51d:	a1 e8 23 05 08       	mov    0x80523e8,%eax
 804b522:	89 7d e8             	mov    %edi,-0x18(%ebp)
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
 804b525:	8b 3d 7c 12 05 08    	mov    0x805127c,%edi
 804b52b:	89 7d ec             	mov    %edi,-0x14(%ebp)
	while (irq_status != 0U) {
 804b52e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 804b531:	09 c1                	or     %eax,%ecx
 804b533:	74 4b                	je     804b580 <hw_irq_ctrl_get_highest_prio_irq+0x8b>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
 804b535:	0f bc c8             	bsf    %eax,%ecx
		int irq_nbr = find_lsb_set(irq_status) - 1;
 804b538:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804b53d:	be 01 00 00 00       	mov    $0x1,%esi
		int irq_nbr = find_lsb_set(irq_status) - 1;
 804b542:	0f 44 cf             	cmove  %edi,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804b545:	31 ff                	xor    %edi,%edi
 804b547:	0f a5 f7             	shld   %cl,%esi,%edi
 804b54a:	d3 e6                	shl    %cl,%esi
 804b54c:	f6 c1 20             	test   $0x20,%cl
 804b54f:	74 04                	je     804b555 <hw_irq_ctrl_get_highest_prio_irq+0x60>
 804b551:	89 f7                	mov    %esi,%edi
 804b553:	31 f6                	xor    %esi,%esi
 804b555:	89 75 e0             	mov    %esi,-0x20(%ebp)
 804b558:	8b 75 e0             	mov    -0x20(%ebp),%esi
 804b55b:	89 7d e4             	mov    %edi,-0x1c(%ebp)
 804b55e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 804b561:	f7 d6                	not    %esi
 804b563:	21 f0                	and    %esi,%eax
		if ((winner_prio > (int)irq_prio[irq_nbr])
 804b565:	0f b6 b1 80 22 05 08 	movzbl 0x8052280(%ecx),%esi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804b56c:	f7 d7                	not    %edi
 804b56e:	21 7d e8             	and    %edi,-0x18(%ebp)
		if ((winner_prio > (int)irq_prio[irq_nbr])
 804b571:	39 de                	cmp    %ebx,%esi
 804b573:	7d b9                	jge    804b52e <hw_irq_ctrl_get_highest_prio_irq+0x39>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
 804b575:	3b 75 ec             	cmp    -0x14(%ebp),%esi
 804b578:	0f 4c de             	cmovl  %esi,%ebx
 804b57b:	0f 4c d1             	cmovl  %ecx,%edx
 804b57e:	eb ae                	jmp    804b52e <hw_irq_ctrl_get_highest_prio_irq+0x39>
}
 804b580:	83 c4 14             	add    $0x14,%esp
 804b583:	89 d0                	mov    %edx,%eax
 804b585:	5b                   	pop    %ebx
 804b586:	5e                   	pop    %esi
 804b587:	5f                   	pop    %edi
 804b588:	5d                   	pop    %ebp
 804b589:	c3                   	ret    
 804b58a:	89 d0                	mov    %edx,%eax
 804b58c:	c3                   	ret    

0804b58d <hw_irq_ctrl_get_current_lock>:
{
 804b58d:	f3 0f 1e fb          	endbr32 
	return irqs_locked;
 804b591:	0f b6 05 a1 24 05 08 	movzbl 0x80524a1,%eax
}
 804b598:	c3                   	ret    

0804b599 <hw_irq_ctrl_change_lock>:
{
 804b599:	f3 0f 1e fb          	endbr32 
 804b59d:	55                   	push   %ebp
 804b59e:	89 e5                	mov    %esp,%ebp
 804b5a0:	53                   	push   %ebx
 804b5a1:	51                   	push   %ecx
 804b5a2:	8b 55 08             	mov    0x8(%ebp),%edx
	uint32_t previous_lock = irqs_locked;
 804b5a5:	0f b6 1d a1 24 05 08 	movzbl 0x80524a1,%ebx
	irqs_locked = new_lock;
 804b5ac:	85 d2                	test   %edx,%edx
 804b5ae:	0f 95 05 a1 24 05 08 	setne  0x80524a1
	if ((previous_lock == true) && (new_lock == false)) {
 804b5b5:	75 16                	jne    804b5cd <hw_irq_ctrl_change_lock+0x34>
 804b5b7:	84 db                	test   %bl,%bl
 804b5b9:	74 12                	je     804b5cd <hw_irq_ctrl_change_lock+0x34>
		if (irq_status != 0U) {
 804b5bb:	a1 ec 23 05 08       	mov    0x80523ec,%eax
 804b5c0:	0b 05 e8 23 05 08    	or     0x80523e8,%eax
 804b5c6:	74 05                	je     804b5cd <hw_irq_ctrl_change_lock+0x34>
			posix_irq_handler_im_from_sw();
 804b5c8:	e8 62 fd ff ff       	call   804b32f <posix_irq_handler_im_from_sw>
}
 804b5cd:	89 d8                	mov    %ebx,%eax
 804b5cf:	5a                   	pop    %edx
 804b5d0:	5b                   	pop    %ebx
 804b5d1:	5d                   	pop    %ebp
 804b5d2:	c3                   	ret    

0804b5d3 <hw_irq_ctrl_clear_irq>:
{
 804b5d3:	f3 0f 1e fb          	endbr32 
 804b5d7:	55                   	push   %ebp
 804b5d8:	89 e5                	mov    %esp,%ebp
 804b5da:	57                   	push   %edi
	irq_status  &= ~((uint64_t)1<<irq);
 804b5db:	8b 4d 08             	mov    0x8(%ebp),%ecx
{
 804b5de:	56                   	push   %esi
	irq_status  &= ~((uint64_t)1<<irq);
 804b5df:	89 cf                	mov    %ecx,%edi
 804b5e1:	c1 ef 05             	shr    $0x5,%edi
 804b5e4:	83 e7 01             	and    $0x1,%edi
 804b5e7:	89 fe                	mov    %edi,%esi
 804b5e9:	d3 e7                	shl    %cl,%edi
 804b5eb:	83 f6 01             	xor    $0x1,%esi
 804b5ee:	89 f8                	mov    %edi,%eax
 804b5f0:	d3 e6                	shl    %cl,%esi
 804b5f2:	f7 d0                	not    %eax
 804b5f4:	21 05 ec 23 05 08    	and    %eax,0x80523ec
 804b5fa:	89 f2                	mov    %esi,%edx
	irq_premask &= ~((uint64_t)1<<irq);
 804b5fc:	21 05 e4 23 05 08    	and    %eax,0x80523e4
}
 804b602:	5e                   	pop    %esi
	irq_status  &= ~((uint64_t)1<<irq);
 804b603:	f7 d2                	not    %edx
}
 804b605:	5f                   	pop    %edi
	irq_status  &= ~((uint64_t)1<<irq);
 804b606:	21 15 e8 23 05 08    	and    %edx,0x80523e8
	irq_premask &= ~((uint64_t)1<<irq);
 804b60c:	21 15 e0 23 05 08    	and    %edx,0x80523e0
}
 804b612:	5d                   	pop    %ebp
 804b613:	c3                   	ret    

0804b614 <hw_irq_ctrl_set_irq>:
{
 804b614:	f3 0f 1e fb          	endbr32 
 804b618:	55                   	push   %ebp
 804b619:	89 e5                	mov    %esp,%ebp
 804b61b:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
 804b61e:	8b 45 08             	mov    0x8(%ebp),%eax
 804b621:	e8 d5 fd ff ff       	call   804b3fb <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
 804b626:	80 3d a1 24 05 08 00 	cmpb   $0x0,0x80524a1
 804b62d:	74 09                	je     804b638 <hw_irq_ctrl_set_irq+0x24>
 804b62f:	80 3d a0 24 05 08 00 	cmpb   $0x0,0x80524a0
 804b636:	74 16                	je     804b64e <hw_irq_ctrl_set_irq+0x3a>
		irq_ctrl_timer = hwm_get_time();
 804b638:	e8 8e f5 ff ff       	call   804abcb <hwm_get_time>
 804b63d:	a3 68 12 05 08       	mov    %eax,0x8051268
 804b642:	89 15 6c 12 05 08    	mov    %edx,0x805126c
}
 804b648:	c9                   	leave  
		hwm_find_next_timer();
 804b649:	e9 ee f3 ff ff       	jmp    804aa3c <hwm_find_next_timer>
}
 804b64e:	c9                   	leave  
 804b64f:	c3                   	ret    

0804b650 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
 804b650:	f3 0f 1e fb          	endbr32 
 804b654:	55                   	push   %ebp
 804b655:	89 e5                	mov    %esp,%ebp
 804b657:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
 804b65a:	8b 45 08             	mov    0x8(%ebp),%eax
 804b65d:	e8 99 fd ff ff       	call   804b3fb <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
 804b662:	80 3d a1 24 05 08 00 	cmpb   $0x0,0x80524a1
 804b669:	75 06                	jne    804b671 <hw_irq_ctrl_raise_im_from_sw+0x21>
		posix_irq_handler_im_from_sw();
	}
}
 804b66b:	c9                   	leave  
		posix_irq_handler_im_from_sw();
 804b66c:	e9 be fc ff ff       	jmp    804b32f <posix_irq_handler_im_from_sw>
}
 804b671:	c9                   	leave  
 804b672:	c3                   	ret    

0804b673 <hw_irq_ctrl_enable_irq>:
{
 804b673:	f3 0f 1e fb          	endbr32 
 804b677:	55                   	push   %ebp
	irq_mask |= ((uint64_t)1<<irq);
 804b678:	31 c0                	xor    %eax,%eax
 804b67a:	31 d2                	xor    %edx,%edx
{
 804b67c:	89 e5                	mov    %esp,%ebp
 804b67e:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_mask |= ((uint64_t)1<<irq);
 804b681:	f6 c1 20             	test   $0x20,%cl
 804b684:	0f 94 c0             	sete   %al
 804b687:	0f 95 c2             	setne  %dl
 804b68a:	d3 e2                	shl    %cl,%edx
 804b68c:	d3 e0                	shl    %cl,%eax
 804b68e:	09 15 dc 23 05 08    	or     %edx,0x80523dc
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
 804b694:	8b 15 e4 23 05 08    	mov    0x80523e4,%edx
	irq_mask |= ((uint64_t)1<<irq);
 804b69a:	09 05 d8 23 05 08    	or     %eax,0x80523d8
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
 804b6a0:	a1 e0 23 05 08       	mov    0x80523e0,%eax
 804b6a5:	0f ad d0             	shrd   %cl,%edx,%eax
 804b6a8:	d3 ea                	shr    %cl,%edx
 804b6aa:	f6 c1 20             	test   $0x20,%cl
 804b6ad:	74 02                	je     804b6b1 <hw_irq_ctrl_enable_irq+0x3e>
 804b6af:	89 d0                	mov    %edx,%eax
 804b6b1:	83 e0 01             	and    $0x1,%eax
 804b6b4:	74 06                	je     804b6bc <hw_irq_ctrl_enable_irq+0x49>
}
 804b6b6:	5d                   	pop    %ebp
		hw_irq_ctrl_raise_im_from_sw(irq);
 804b6b7:	e9 94 ff ff ff       	jmp    804b650 <hw_irq_ctrl_raise_im_from_sw>
}
 804b6bc:	5d                   	pop    %ebp
 804b6bd:	c3                   	ret    

0804b6be <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
 804b6be:	f3 0f 1e fb          	endbr32 
	irq_ctrl_timer = NEVER;
 804b6c2:	c7 05 68 12 05 08 ff 	movl   $0xffffffff,0x8051268
 804b6c9:	ff ff ff 
 804b6cc:	c7 05 6c 12 05 08 ff 	movl   $0xffffffff,0x805126c
 804b6d3:	ff ff ff 
	irq_raising_from_hw_now();
 804b6d6:	e9 01 fd ff ff       	jmp    804b3dc <irq_raising_from_hw_now>

0804b6db <posix_exit>:
#include <stdlib.h>
#include <zephyr/sys/util.h>
#include "cmdline.h"

void posix_exit(int exit_code)
{
 804b6db:	f3 0f 1e fb          	endbr32 
 804b6df:	55                   	push   %ebp
 804b6e0:	89 e5                	mov    %esp,%ebp
 804b6e2:	83 ec 08             	sub    $0x8,%esp
 804b6e5:	8b 45 08             	mov    0x8(%ebp),%eax
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
 804b6e8:	39 05 70 24 05 08    	cmp    %eax,0x8052470
 804b6ee:	0f 4d 05 70 24 05 08 	cmovge 0x8052470,%eax
 804b6f5:	a3 70 24 05 08       	mov    %eax,0x8052470
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
 804b6fa:	e8 d8 f1 ff ff       	call   804a8d7 <posix_soc_clean_up>
	hwm_cleanup();
 804b6ff:	e8 fb f4 ff ff       	call   804abff <hwm_cleanup>
	native_cleanup_cmd_line();
 804b704:	e8 75 08 00 00       	call   804bf7e <native_cleanup_cmd_line>
	exit(max_exit_code);
 804b709:	83 ec 0c             	sub    $0xc,%esp
 804b70c:	ff 35 70 24 05 08    	pushl  0x8052470
 804b712:	e8 b9 dc ff ff       	call   80493d0 <exit@plt>

0804b717 <main>:
/**
 * This is the actual main for the Linux process,
 * the Zephyr application main is renamed something else thru a define.
 */
int main(int argc, char *argv[])
{
 804b717:	f3 0f 1e fb          	endbr32 
 804b71b:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 804b71f:	83 e4 f0             	and    $0xfffffff0,%esp
 804b722:	ff 71 fc             	pushl  -0x4(%ecx)
 804b725:	55                   	push   %ebp
 804b726:	89 e5                	mov    %esp,%ebp
 804b728:	56                   	push   %esi
 804b729:	53                   	push   %ebx
 804b72a:	51                   	push   %ecx
 804b72b:	83 ec 18             	sub    $0x18,%esp
 804b72e:	8b 71 04             	mov    0x4(%ecx),%esi
 804b731:	8b 19                	mov    (%ecx),%ebx
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
 804b733:	6a 00                	push   $0x0
 804b735:	e8 70 f1 ff ff       	call   804a8aa <run_native_tasks>
 804b73a:	58                   	pop    %eax
 804b73b:	5a                   	pop    %edx

	native_handle_cmd_line(argc, argv);
 804b73c:	56                   	push   %esi
 804b73d:	53                   	push   %ebx
 804b73e:	e8 1a 09 00 00       	call   804c05d <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
 804b743:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804b74a:	e8 5b f1 ff ff       	call   804a8aa <run_native_tasks>
 804b74f:	83 c4 10             	add    $0x10,%esp

	hwm_init();
 804b752:	e8 84 f4 ff ff       	call   804abdb <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
 804b757:	83 ec 0c             	sub    $0xc,%esp
 804b75a:	6a 02                	push   $0x2
 804b75c:	e8 49 f1 ff ff       	call   804a8aa <run_native_tasks>
 804b761:	83 c4 10             	add    $0x10,%esp

	posix_boot_cpu();
 804b764:	e8 8d f0 ff ff       	call   804a7f6 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
 804b769:	83 ec 0c             	sub    $0xc,%esp
 804b76c:	6a 03                	push   $0x3
 804b76e:	e8 37 f1 ff ff       	call   804a8aa <run_native_tasks>
 804b773:	83 c4 10             	add    $0x10,%esp

	hwm_main_loop();
 804b776:	e8 46 f3 ff ff       	call   804aac1 <hwm_main_loop>

	/* This line should be unreachable */
	return 1; /* LCOV_EXCL_LINE */
}
 804b77b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b77e:	b8 01 00 00 00       	mov    $0x1,%eax
 804b783:	59                   	pop    %ecx
 804b784:	5b                   	pop    %ebx
 804b785:	5e                   	pop    %esi
 804b786:	5d                   	pop    %ebp
 804b787:	8d 61 fc             	lea    -0x4(%ecx),%esp
 804b78a:	c3                   	ret    

0804b78b <trace_disable_color>:
 * Indexed 0:stdout, 1:stderr
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
 804b78b:	f3 0f 1e fb          	endbr32 
	is_a_tty[0] = 0;
 804b78f:	c7 05 80 12 05 08 00 	movl   $0x0,0x8051280
 804b796:	00 00 00 
	is_a_tty[1] = 0;
 804b799:	c7 05 84 12 05 08 00 	movl   $0x0,0x8051284
 804b7a0:	00 00 00 
}
 804b7a3:	c3                   	ret    

0804b7a4 <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
 804b7a4:	f3 0f 1e fb          	endbr32 
	is_a_tty[0] = -1;
 804b7a8:	c7 05 80 12 05 08 ff 	movl   $0xffffffff,0x8051280
 804b7af:	ff ff ff 
	is_a_tty[1] = -1;
 804b7b2:	c7 05 84 12 05 08 ff 	movl   $0xffffffff,0x8051284
 804b7b9:	ff ff ff 

}
 804b7bc:	c3                   	ret    

0804b7bd <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
 804b7bd:	f3 0f 1e fb          	endbr32 
	is_a_tty[0] = 1;
 804b7c1:	c7 05 80 12 05 08 01 	movl   $0x1,0x8051280
 804b7c8:	00 00 00 
	is_a_tty[1] = 1;
 804b7cb:	c7 05 84 12 05 08 01 	movl   $0x1,0x8051284
 804b7d2:	00 00 00 
}
 804b7d5:	c3                   	ret    

0804b7d6 <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
 804b7d6:	f3 0f 1e fb          	endbr32 
 804b7da:	55                   	push   %ebp
 804b7db:	89 e5                	mov    %esp,%ebp
 804b7dd:	83 ec 08             	sub    $0x8,%esp
	if (is_a_tty[0] == -1) {
 804b7e0:	83 3d 80 12 05 08 ff 	cmpl   $0xffffffff,0x8051280
 804b7e7:	75 12                	jne    804b7fb <decide_about_color+0x25>
		is_a_tty[0] = isatty(STDOUT_FILENO);
 804b7e9:	83 ec 0c             	sub    $0xc,%esp
 804b7ec:	6a 01                	push   $0x1
 804b7ee:	e8 2d dd ff ff       	call   8049520 <isatty@plt>
 804b7f3:	83 c4 10             	add    $0x10,%esp
 804b7f6:	a3 80 12 05 08       	mov    %eax,0x8051280
	}
	if (is_a_tty[1] == -1) {
 804b7fb:	83 3d 84 12 05 08 ff 	cmpl   $0xffffffff,0x8051284
 804b802:	75 12                	jne    804b816 <decide_about_color+0x40>
		is_a_tty[1] = isatty(STDERR_FILENO);
 804b804:	83 ec 0c             	sub    $0xc,%esp
 804b807:	6a 02                	push   $0x2
 804b809:	e8 12 dd ff ff       	call   8049520 <isatty@plt>
 804b80e:	83 c4 10             	add    $0x10,%esp
 804b811:	a3 84 12 05 08       	mov    %eax,0x8051284
	}
}
 804b816:	c9                   	leave  
 804b817:	c3                   	ret    

0804b818 <posix_print_error_and_exit>:
{
 804b818:	f3 0f 1e fb          	endbr32 
 804b81c:	55                   	push   %ebp
 804b81d:	89 e5                	mov    %esp,%ebp
 804b81f:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804b822:	8d 45 0c             	lea    0xc(%ebp),%eax

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
 804b825:	50                   	push   %eax
 804b826:	ff 75 08             	pushl  0x8(%ebp)
 804b829:	6a 01                	push   $0x1
 804b82b:	ff 35 c0 1f 05 08    	pushl  0x8051fc0
 804b831:	e8 da da ff ff       	call   8049310 <__vfprintf_chk@plt>
	posix_exit(1);
 804b836:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804b83d:	e8 99 fe ff ff       	call   804b6db <posix_exit>
 804b842:	83 c4 10             	add    $0x10,%esp
}
 804b845:	c9                   	leave  
 804b846:	c3                   	ret    

0804b847 <posix_print_warning>:
{
 804b847:	f3 0f 1e fb          	endbr32 
 804b84b:	55                   	push   %ebp
 804b84c:	89 e5                	mov    %esp,%ebp
 804b84e:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804b851:	8d 45 0c             	lea    0xc(%ebp),%eax
 804b854:	50                   	push   %eax
 804b855:	ff 75 08             	pushl  0x8(%ebp)
 804b858:	6a 01                	push   $0x1
 804b85a:	ff 35 c0 1f 05 08    	pushl  0x8051fc0
 804b860:	e8 ab da ff ff       	call   8049310 <__vfprintf_chk@plt>
 804b865:	83 c4 10             	add    $0x10,%esp
}
 804b868:	c9                   	leave  
 804b869:	c3                   	ret    

0804b86a <posix_print_trace>:
{
 804b86a:	f3 0f 1e fb          	endbr32 
 804b86e:	55                   	push   %ebp
 804b86f:	89 e5                	mov    %esp,%ebp
 804b871:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804b874:	8d 45 0c             	lea    0xc(%ebp),%eax
 804b877:	50                   	push   %eax
 804b878:	ff 75 08             	pushl  0x8(%ebp)
 804b87b:	6a 01                	push   $0x1
 804b87d:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804b883:	e8 88 da ff ff       	call   8049310 <__vfprintf_chk@plt>
 804b888:	83 c4 10             	add    $0x10,%esp
}
 804b88b:	c9                   	leave  
 804b88c:	c3                   	ret    

0804b88d <native_add_tracing_options>:

NATIVE_TASK(decide_about_color, PRE_BOOT_2, 0);

void native_add_tracing_options(void)
{
 804b88d:	f3 0f 1e fb          	endbr32 
 804b891:	55                   	push   %ebp
 804b892:	89 e5                	mov    %esp,%ebp
 804b894:	83 ec 14             	sub    $0x14,%esp
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
 804b897:	68 a0 11 05 08       	push   $0x80511a0
 804b89c:	e8 06 07 00 00       	call   804bfa7 <native_add_command_line_opts>
 804b8a1:	83 c4 10             	add    $0x10,%esp
}
 804b8a4:	c9                   	leave  
 804b8a5:	c3                   	ret    

0804b8a6 <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
 804b8a6:	55                   	push   %ebp
 804b8a7:	89 e5                	mov    %esp,%ebp
 804b8a9:	57                   	push   %edi
 804b8aa:	89 d7                	mov    %edx,%edi
 804b8ac:	56                   	push   %esi
 804b8ad:	be 46 00 00 00       	mov    $0x46,%esi
 804b8b2:	53                   	push   %ebx
 804b8b3:	89 c3                	mov    %eax,%ebx
 804b8b5:	83 ec 1c             	sub    $0x1c,%esp

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
 804b8b8:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
 804b8bc:	75 09                	jne    804b8c7 <cmd_gen_switch_syntax.constprop.0+0x21>
		*buf++ = '[';
 804b8be:	c6 00 5b             	movb   $0x5b,(%eax)
 804b8c1:	43                   	inc    %ebx
		size--;
 804b8c2:	be 45 00 00 00       	mov    $0x45,%esi
	}

	if (args_s_el->is_switch == true) {
 804b8c7:	80 7f 02 00          	cmpb   $0x0,0x2(%edi)
 804b8cb:	8b 47 04             	mov    0x4(%edi),%eax
 804b8ce:	74 0a                	je     804b8da <cmd_gen_switch_syntax.constprop.0+0x34>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
 804b8d0:	52                   	push   %edx
 804b8d1:	52                   	push   %edx
 804b8d2:	50                   	push   %eax
 804b8d3:	68 75 ea 04 08       	push   $0x804ea75
 804b8d8:	eb 1b                	jmp    804b8f5 <cmd_gen_switch_syntax.constprop.0+0x4f>
		ret = snprintf(buf, size, "-%s", args_s_el->option);
	} else {
		if (args_s_el->type != 'l') {
 804b8da:	80 7f 0c 6c          	cmpb   $0x6c,0xc(%edi)
 804b8de:	8b 57 08             	mov    0x8(%edi),%edx
 804b8e1:	74 0a                	je     804b8ed <cmd_gen_switch_syntax.constprop.0+0x47>
 804b8e3:	51                   	push   %ecx
 804b8e4:	52                   	push   %edx
 804b8e5:	50                   	push   %eax
 804b8e6:	68 79 ea 04 08       	push   $0x804ea79
 804b8eb:	eb 08                	jmp    804b8f5 <cmd_gen_switch_syntax.constprop.0+0x4f>
 804b8ed:	51                   	push   %ecx
 804b8ee:	52                   	push   %edx
 804b8ef:	50                   	push   %eax
 804b8f0:	68 82 ea 04 08       	push   $0x804ea82
 804b8f5:	6a ff                	push   $0xffffffff
 804b8f7:	6a 01                	push   $0x1
 804b8f9:	56                   	push   %esi
 804b8fa:	53                   	push   %ebx
 804b8fb:	e8 e0 d9 ff ff       	call   80492e0 <__snprintf_chk@plt>
 804b900:	83 c4 20             	add    $0x20,%esp
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
 804b903:	85 c0                	test   %eax,%eax
 804b905:	79 1e                	jns    804b925 <cmd_gen_switch_syntax.constprop.0+0x7f>
 804b907:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		posix_print_error_and_exit("Unexpected error in %s %i\n",
 804b90a:	50                   	push   %eax
 804b90b:	68 07 01 00 00       	push   $0x107
 804b910:	68 8e ea 04 08       	push   $0x804ea8e
 804b915:	68 cc ea 04 08       	push   $0x804eacc
 804b91a:	e8 f9 fe ff ff       	call   804b818 <posix_print_error_and_exit>
 804b91f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b922:	83 c4 10             	add    $0x10,%esp
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
 804b925:	29 c6                	sub    %eax,%esi
 804b927:	78 20                	js     804b949 <cmd_gen_switch_syntax.constprop.0+0xa3>
		 * If we run out of space we can just stop,
		 * this is not critical
		 */
		return;
	}
	buf += ret;
 804b929:	01 d8                	add    %ebx,%eax
	size -= ret;

	if (args_s_el->is_mandatory == false) {
 804b92b:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
 804b92f:	75 08                	jne    804b939 <cmd_gen_switch_syntax.constprop.0+0x93>
 804b931:	51                   	push   %ecx
 804b932:	68 e7 ea 04 08       	push   $0x804eae7
 804b937:	eb 06                	jmp    804b93f <cmd_gen_switch_syntax.constprop.0+0x99>
 804b939:	52                   	push   %edx
 804b93a:	68 e8 ea 04 08       	push   $0x804eae8
 804b93f:	56                   	push   %esi
 804b940:	50                   	push   %eax
 804b941:	e8 ea da ff ff       	call   8049430 <snprintf@plt>
 804b946:	83 c4 10             	add    $0x10,%esp
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
 804b949:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b94c:	5b                   	pop    %ebx
 804b94d:	5e                   	pop    %esi
 804b94e:	5f                   	pop    %edi
 804b94f:	5d                   	pop    %ebp
 804b950:	c3                   	ret    

0804b951 <cmd_is_option>:
{
 804b951:	f3 0f 1e fb          	endbr32 
 804b955:	55                   	push   %ebp
 804b956:	89 e5                	mov    %esp,%ebp
 804b958:	57                   	push   %edi
 804b959:	56                   	push   %esi
 804b95a:	53                   	push   %ebx
 804b95b:	83 ec 0c             	sub    $0xc,%esp
	if (arg[of] == '-') {
 804b95e:	8b 45 08             	mov    0x8(%ebp),%eax
{
 804b961:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804b964:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if (arg[of] == '-') {
 804b967:	80 38 2d             	cmpb   $0x2d,(%eax)
	int of = 0;
 804b96a:	0f 94 c0             	sete   %al
 804b96d:	0f b6 c0             	movzbl %al,%eax
 804b970:	89 c6                	mov    %eax,%esi
	if (arg[of] == '-') {
 804b972:	8b 45 08             	mov    0x8(%ebp),%eax
 804b975:	80 3c 30 2d          	cmpb   $0x2d,(%eax,%esi,1)
 804b979:	75 01                	jne    804b97c <cmd_is_option+0x2b>
		of++;
 804b97b:	46                   	inc    %esi
	if (!with_value) {
 804b97c:	85 db                	test   %ebx,%ebx
 804b97e:	75 24                	jne    804b9a4 <cmd_is_option+0x53>
		if (strcmp(&arg[of], option) != 0) {
 804b980:	52                   	push   %edx
 804b981:	52                   	push   %edx
 804b982:	8b 55 08             	mov    0x8(%ebp),%edx
 804b985:	57                   	push   %edi
 804b986:	01 f2                	add    %esi,%edx
 804b988:	52                   	push   %edx
 804b989:	e8 72 d9 ff ff       	call   8049300 <strcmp@plt>
 804b98e:	83 c4 10             	add    $0x10,%esp
 804b991:	85 c0                	test   %eax,%eax
 804b993:	75 57                	jne    804b9ec <cmd_is_option+0x9b>
	size_t to_match_len = strlen(option);
 804b995:	83 c9 ff             	or     $0xffffffff,%ecx
 804b998:	f2 ae                	repnz scas %es:(%edi),%al
 804b99a:	89 cf                	mov    %ecx,%edi
 804b99c:	f7 d7                	not    %edi
			return of + to_match_len;
 804b99e:	8d 5c 3e ff          	lea    -0x1(%esi,%edi,1),%ebx
 804b9a2:	eb 48                	jmp    804b9ec <cmd_is_option+0x9b>
 804b9a4:	89 f3                	mov    %esi,%ebx
 804b9a6:	29 f7                	sub    %esi,%edi
	while (!(arg[of] == 0 && *option == 0)) {
 804b9a8:	8b 45 08             	mov    0x8(%ebp),%eax
 804b9ab:	8a 0c 1f             	mov    (%edi,%ebx,1),%cl
 804b9ae:	8a 04 18             	mov    (%eax,%ebx,1),%al
 804b9b1:	89 c2                	mov    %eax,%edx
 804b9b3:	08 ca                	or     %cl,%dl
 804b9b5:	74 1f                	je     804b9d6 <cmd_is_option+0x85>
		if (*option == 0) {
 804b9b7:	84 c9                	test   %cl,%cl
 804b9b9:	75 14                	jne    804b9cf <cmd_is_option+0x7e>
			if ((arg[of] == ':') || (arg[of] == '=')) {
 804b9bb:	3c 3a                	cmp    $0x3a,%al
 804b9bd:	74 04                	je     804b9c3 <cmd_is_option+0x72>
 804b9bf:	3c 3d                	cmp    $0x3d,%al
 804b9c1:	75 27                	jne    804b9ea <cmd_is_option+0x99>
	if (arg[of] == 0) { /* we need a value to follow */
 804b9c3:	8b 45 08             	mov    0x8(%ebp),%eax
				of++;
 804b9c6:	43                   	inc    %ebx
	if (arg[of] == 0) { /* we need a value to follow */
 804b9c7:	80 3c 18 00          	cmpb   $0x0,(%eax,%ebx,1)
 804b9cb:	75 1f                	jne    804b9ec <cmd_is_option+0x9b>
 804b9cd:	eb 07                	jmp    804b9d6 <cmd_is_option+0x85>
		if (arg[of] != *option) {
 804b9cf:	38 c8                	cmp    %cl,%al
 804b9d1:	75 17                	jne    804b9ea <cmd_is_option+0x99>
		of++;
 804b9d3:	43                   	inc    %ebx
		option++;
 804b9d4:	eb d2                	jmp    804b9a8 <cmd_is_option+0x57>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
 804b9d6:	50                   	push   %eax
 804b9d7:	50                   	push   %eax
 804b9d8:	ff 75 08             	pushl  0x8(%ebp)
 804b9db:	68 ea ea 04 08       	push   $0x804eaea
 804b9e0:	e8 33 fe ff ff       	call   804b818 <posix_print_error_and_exit>
 804b9e5:	83 c4 10             	add    $0x10,%esp
 804b9e8:	eb 02                	jmp    804b9ec <cmd_is_option+0x9b>
			return 0;
 804b9ea:	31 db                	xor    %ebx,%ebx
}
 804b9ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b9ef:	89 d8                	mov    %ebx,%eax
 804b9f1:	5b                   	pop    %ebx
 804b9f2:	5e                   	pop    %esi
 804b9f3:	5f                   	pop    %edi
 804b9f4:	5d                   	pop    %ebp
 804b9f5:	c3                   	ret    

0804b9f6 <cmd_is_help_option>:
{
 804b9f6:	f3 0f 1e fb          	endbr32 
 804b9fa:	55                   	push   %ebp
 804b9fb:	89 e5                	mov    %esp,%ebp
 804b9fd:	53                   	push   %ebx
 804b9fe:	53                   	push   %ebx
 804b9ff:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (arg[0] == '-') {
 804ba02:	80 3b 2d             	cmpb   $0x2d,(%ebx)
 804ba05:	75 0c                	jne    804ba13 <cmd_is_help_option+0x1d>
	if (arg[0] == '-') {
 804ba07:	80 7b 01 2d          	cmpb   $0x2d,0x1(%ebx)
 804ba0b:	74 03                	je     804ba10 <cmd_is_help_option+0x1a>
		arg++;
 804ba0d:	43                   	inc    %ebx
 804ba0e:	eb 03                	jmp    804ba13 <cmd_is_help_option+0x1d>
		arg++;
 804ba10:	83 c3 02             	add    $0x2,%ebx
	if ((strcasecmp(arg, "?") == 0) ||
 804ba13:	51                   	push   %ecx
 804ba14:	51                   	push   %ecx
 804ba15:	68 44 eb 04 08       	push   $0x804eb44
 804ba1a:	53                   	push   %ebx
 804ba1b:	e8 f0 d9 ff ff       	call   8049410 <strcasecmp@plt>
 804ba20:	83 c4 10             	add    $0x10,%esp
 804ba23:	89 c2                	mov    %eax,%edx
		return 1;
 804ba25:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
 804ba2a:	85 d2                	test   %edx,%edx
 804ba2c:	74 33                	je     804ba61 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "h") == 0) ||
 804ba2e:	52                   	push   %edx
 804ba2f:	52                   	push   %edx
 804ba30:	68 46 eb 04 08       	push   $0x804eb46
 804ba35:	53                   	push   %ebx
 804ba36:	e8 d5 d9 ff ff       	call   8049410 <strcasecmp@plt>
 804ba3b:	83 c4 10             	add    $0x10,%esp
 804ba3e:	89 c2                	mov    %eax,%edx
		return 1;
 804ba40:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
 804ba45:	85 d2                	test   %edx,%edx
 804ba47:	74 18                	je     804ba61 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "help") == 0)) {
 804ba49:	50                   	push   %eax
 804ba4a:	50                   	push   %eax
 804ba4b:	68 e8 eb 04 08       	push   $0x804ebe8
 804ba50:	53                   	push   %ebx
 804ba51:	e8 ba d9 ff ff       	call   8049410 <strcasecmp@plt>
 804ba56:	83 c4 10             	add    $0x10,%esp
	    (strcasecmp(arg, "h") == 0) ||
 804ba59:	85 c0                	test   %eax,%eax
 804ba5b:	0f 94 c0             	sete   %al
 804ba5e:	0f b6 c0             	movzbl %al,%eax
}
 804ba61:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804ba64:	c9                   	leave  
 804ba65:	c3                   	ret    

0804ba66 <cmd_read_option_value>:
{
 804ba66:	f3 0f 1e fb          	endbr32 
 804ba6a:	55                   	push   %ebp
 804ba6b:	89 e5                	mov    %esp,%ebp
 804ba6d:	57                   	push   %edi
 804ba6e:	56                   	push   %esi
 804ba6f:	53                   	push   %ebx
 804ba70:	83 ec 1c             	sub    $0x1c,%esp
 804ba73:	8b 45 10             	mov    0x10(%ebp),%eax
 804ba76:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804ba79:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
 804ba80:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804ba83:	31 d2                	xor    %edx,%edx
 804ba85:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804ba88:	8b 75 14             	mov    0x14(%ebp),%esi
	char *endptr = NULL;
 804ba8b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	switch (type) {
 804ba92:	3c 64                	cmp    $0x64,%al
 804ba94:	0f 84 19 01 00 00    	je     804bbb3 <cmd_read_option_value+0x14d>
 804ba9a:	7f 26                	jg     804bac2 <cmd_read_option_value+0x5c>
 804ba9c:	3c 55                	cmp    $0x55,%al
 804ba9e:	0f 84 ef 00 00 00    	je     804bb93 <cmd_read_option_value+0x12d>
 804baa4:	3c 62                	cmp    $0x62,%al
 804baa6:	74 44                	je     804baec <cmd_read_option_value+0x86>
 804baa8:	3c 49                	cmp    $0x49,%al
 804baaa:	0f 85 16 01 00 00    	jne    804bbc6 <cmd_read_option_value+0x160>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
 804bab0:	50                   	push   %eax
 804bab1:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bab4:	6a 00                	push   $0x0
 804bab6:	50                   	push   %eax
 804bab7:	53                   	push   %ebx
 804bab8:	e8 f3 d8 ff ff       	call   80493b0 <strtoll@plt>
 804babd:	e9 e7 00 00 00       	jmp    804bba9 <cmd_read_option_value+0x143>
	switch (type) {
 804bac2:	3c 73                	cmp    $0x73,%al
 804bac4:	0f 84 a7 00 00 00    	je     804bb71 <cmd_read_option_value+0x10b>
 804baca:	3c 75                	cmp    $0x75,%al
 804bacc:	0f 84 b2 00 00 00    	je     804bb84 <cmd_read_option_value+0x11e>
 804bad2:	3c 69                	cmp    $0x69,%al
 804bad4:	0f 85 ec 00 00 00    	jne    804bbc6 <cmd_read_option_value+0x160>
		*(int32_t *)dest = strtol(str, &endptr, 0);
 804bada:	50                   	push   %eax
 804badb:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bade:	6a 00                	push   $0x0
 804bae0:	50                   	push   %eax
 804bae1:	53                   	push   %ebx
 804bae2:	e8 49 da ff ff       	call   8049530 <strtol@plt>
 804bae7:	e9 b6 00 00 00       	jmp    804bba2 <cmd_read_option_value+0x13c>
		if (strcasecmp(str, "false") == 0) {
 804baec:	50                   	push   %eax
 804baed:	50                   	push   %eax
 804baee:	68 48 eb 04 08       	push   $0x804eb48
 804baf3:	53                   	push   %ebx
 804baf4:	e8 17 d9 ff ff       	call   8049410 <strcasecmp@plt>
 804baf9:	83 c4 10             	add    $0x10,%esp
 804bafc:	85 c0                	test   %eax,%eax
 804bafe:	75 08                	jne    804bb08 <cmd_read_option_value+0xa2>
			*(bool *)dest = false;
 804bb00:	c6 07 00             	movb   $0x0,(%edi)
			endptr = (char *)str + 5;
 804bb03:	8d 43 05             	lea    0x5(%ebx),%eax
 804bb06:	eb 1a                	jmp    804bb22 <cmd_read_option_value+0xbc>
		} else if (strcmp(str, "0") == 0) {
 804bb08:	50                   	push   %eax
 804bb09:	50                   	push   %eax
 804bb0a:	68 4e eb 04 08       	push   $0x804eb4e
 804bb0f:	53                   	push   %ebx
 804bb10:	e8 eb d7 ff ff       	call   8049300 <strcmp@plt>
 804bb15:	83 c4 10             	add    $0x10,%esp
 804bb18:	85 c0                	test   %eax,%eax
 804bb1a:	75 0e                	jne    804bb2a <cmd_read_option_value+0xc4>
			*(bool *)dest = false;
 804bb1c:	c6 07 00             	movb   $0x0,(%edi)
			endptr = (char *)str + 1;
 804bb1f:	8d 43 01             	lea    0x1(%ebx),%eax
 804bb22:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (!error && endptr && *endptr != 0) {
 804bb25:	e9 af 00 00 00       	jmp    804bbd9 <cmd_read_option_value+0x173>
		} else if (strcasecmp(str, "true") == 0) {
 804bb2a:	51                   	push   %ecx
 804bb2b:	51                   	push   %ecx
 804bb2c:	68 50 eb 04 08       	push   $0x804eb50
 804bb31:	53                   	push   %ebx
 804bb32:	e8 d9 d8 ff ff       	call   8049410 <strcasecmp@plt>
 804bb37:	83 c4 10             	add    $0x10,%esp
 804bb3a:	85 c0                	test   %eax,%eax
 804bb3c:	75 08                	jne    804bb46 <cmd_read_option_value+0xe0>
			*(bool *)dest = true;
 804bb3e:	c6 07 01             	movb   $0x1,(%edi)
			endptr = (char *)str + 4;
 804bb41:	8d 43 04             	lea    0x4(%ebx),%eax
 804bb44:	eb dc                	jmp    804bb22 <cmd_read_option_value+0xbc>
		} else if (strcmp(str, "1") == 0) {
 804bb46:	52                   	push   %edx
 804bb47:	52                   	push   %edx
 804bb48:	68 55 eb 04 08       	push   $0x804eb55
 804bb4d:	53                   	push   %ebx
 804bb4e:	e8 ad d7 ff ff       	call   8049300 <strcmp@plt>
 804bb53:	83 c4 10             	add    $0x10,%esp
 804bb56:	85 c0                	test   %eax,%eax
 804bb58:	74 12                	je     804bb6c <cmd_read_option_value+0x106>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
 804bb5a:	50                   	push   %eax
 804bb5b:	53                   	push   %ebx
 804bb5c:	56                   	push   %esi
 804bb5d:	68 57 eb 04 08       	push   $0x804eb57
 804bb62:	e8 b1 fc ff ff       	call   804b818 <posix_print_error_and_exit>
 804bb67:	83 c4 10             	add    $0x10,%esp
 804bb6a:	eb 7d                	jmp    804bbe9 <cmd_read_option_value+0x183>
			*(bool *)dest = true;
 804bb6c:	c6 07 01             	movb   $0x1,(%edi)
			endptr = (char *)str + 1;
 804bb6f:	eb ae                	jmp    804bb1f <cmd_read_option_value+0xb9>
		*(char **)dest = (char *)str;
 804bb71:	89 1f                	mov    %ebx,(%edi)
		endptr = (char *)str + strlen(str);
 804bb73:	31 c0                	xor    %eax,%eax
 804bb75:	83 c9 ff             	or     $0xffffffff,%ecx
 804bb78:	89 df                	mov    %ebx,%edi
 804bb7a:	f2 ae                	repnz scas %es:(%edi),%al
 804bb7c:	f7 d1                	not    %ecx
 804bb7e:	8d 44 0b ff          	lea    -0x1(%ebx,%ecx,1),%eax
 804bb82:	eb 9e                	jmp    804bb22 <cmd_read_option_value+0xbc>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
 804bb84:	50                   	push   %eax
 804bb85:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bb88:	6a 00                	push   $0x0
 804bb8a:	50                   	push   %eax
 804bb8b:	53                   	push   %ebx
 804bb8c:	e8 5f d8 ff ff       	call   80493f0 <strtoul@plt>
 804bb91:	eb 0f                	jmp    804bba2 <cmd_read_option_value+0x13c>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
 804bb93:	50                   	push   %eax
 804bb94:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bb97:	6a 00                	push   $0x0
 804bb99:	50                   	push   %eax
 804bb9a:	53                   	push   %ebx
 804bb9b:	e8 c0 d8 ff ff       	call   8049460 <strtoull@plt>
 804bba0:	eb 07                	jmp    804bba9 <cmd_read_option_value+0x143>
		*(int32_t *)dest = strtol(str, &endptr, 0);
 804bba2:	89 07                	mov    %eax,(%edi)
 804bba4:	83 c4 10             	add    $0x10,%esp
 804bba7:	eb 30                	jmp    804bbd9 <cmd_read_option_value+0x173>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
 804bba9:	89 07                	mov    %eax,(%edi)
 804bbab:	83 c4 10             	add    $0x10,%esp
 804bbae:	89 57 04             	mov    %edx,0x4(%edi)
	if (!error && endptr && *endptr != 0) {
 804bbb1:	eb 26                	jmp    804bbd9 <cmd_read_option_value+0x173>
		*(double *)dest = strtod(str, &endptr);
 804bbb3:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bbb6:	51                   	push   %ecx
 804bbb7:	51                   	push   %ecx
 804bbb8:	50                   	push   %eax
 804bbb9:	53                   	push   %ebx
 804bbba:	e8 b1 d8 ff ff       	call   8049470 <strtod@plt>
 804bbbf:	83 c4 10             	add    $0x10,%esp
 804bbc2:	dd 1f                	fstpl  (%edi)
	if (!error && endptr && *endptr != 0) {
 804bbc4:	eb 13                	jmp    804bbd9 <cmd_read_option_value+0x173>
	switch (type) {
 804bbc6:	0f be c0             	movsbl %al,%eax
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
 804bbc9:	52                   	push   %edx
 804bbca:	52                   	push   %edx
 804bbcb:	50                   	push   %eax
 804bbcc:	68 99 eb 04 08       	push   $0x804eb99
 804bbd1:	e8 42 fc ff ff       	call   804b818 <posix_print_error_and_exit>
 804bbd6:	83 c4 10             	add    $0x10,%esp
	if (!error && endptr && *endptr != 0) {
 804bbd9:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bbdc:	85 c0                	test   %eax,%eax
 804bbde:	74 09                	je     804bbe9 <cmd_read_option_value+0x183>
 804bbe0:	80 38 00             	cmpb   $0x0,(%eax)
 804bbe3:	0f 85 71 ff ff ff    	jne    804bb5a <cmd_read_option_value+0xf4>
}
 804bbe9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bbec:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804bbf3:	74 05                	je     804bbfa <cmd_read_option_value+0x194>
 804bbf5:	e8 96 d7 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804bbfa:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bbfd:	5b                   	pop    %ebx
 804bbfe:	5e                   	pop    %esi
 804bbff:	5f                   	pop    %edi
 804bc00:	5d                   	pop    %ebp
 804bc01:	c3                   	ret    

0804bc02 <cmd_args_set_defaults>:
{
 804bc02:	f3 0f 1e fb          	endbr32 
 804bc06:	55                   	push   %ebp
 804bc07:	89 e5                	mov    %esp,%ebp
 804bc09:	53                   	push   %ebx
 804bc0a:	51                   	push   %ecx
 804bc0b:	8b 45 08             	mov    0x8(%ebp),%eax
 804bc0e:	8d 58 04             	lea    0x4(%eax),%ebx
	while (args_struct[count].option != NULL) {
 804bc11:	83 3b 00             	cmpl   $0x0,(%ebx)
 804bc14:	0f 84 8c 00 00 00    	je     804bca6 <cmd_args_set_defaults+0xa4>
		if (args_struct[count].dest == NULL) {
 804bc1a:	8b 53 0c             	mov    0xc(%ebx),%edx
 804bc1d:	85 d2                	test   %edx,%edx
 804bc1f:	74 7d                	je     804bc9e <cmd_args_set_defaults+0x9c>
		switch (args_struct[count].type) {
 804bc21:	0f be 43 08          	movsbl 0x8(%ebx),%eax
 804bc25:	3c 64                	cmp    $0x64,%al
 804bc27:	74 5b                	je     804bc84 <cmd_args_set_defaults+0x82>
 804bc29:	7f 26                	jg     804bc51 <cmd_args_set_defaults+0x4f>
 804bc2b:	3c 55                	cmp    $0x55,%al
 804bc2d:	74 46                	je     804bc75 <cmd_args_set_defaults+0x73>
 804bc2f:	7f 17                	jg     804bc48 <cmd_args_set_defaults+0x46>
 804bc31:	84 c0                	test   %al,%al
 804bc33:	74 69                	je     804bc9e <cmd_args_set_defaults+0x9c>
 804bc35:	3c 49                	cmp    $0x49,%al
 804bc37:	75 55                	jne    804bc8e <cmd_args_set_defaults+0x8c>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
 804bc39:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
 804bc3f:	c7 42 04 ff ff ff 7f 	movl   $0x7fffffff,0x4(%edx)
			break;
 804bc46:	eb 56                	jmp    804bc9e <cmd_args_set_defaults+0x9c>
		switch (args_struct[count].type) {
 804bc48:	3c 62                	cmp    $0x62,%al
 804bc4a:	75 42                	jne    804bc8e <cmd_args_set_defaults+0x8c>
			*(bool *)args_struct[count].dest = false;
 804bc4c:	c6 02 00             	movb   $0x0,(%edx)
			break;
 804bc4f:	eb 4d                	jmp    804bc9e <cmd_args_set_defaults+0x9c>
		switch (args_struct[count].type) {
 804bc51:	3c 73                	cmp    $0x73,%al
 804bc53:	74 10                	je     804bc65 <cmd_args_set_defaults+0x63>
 804bc55:	3c 75                	cmp    $0x75,%al
 804bc57:	74 14                	je     804bc6d <cmd_args_set_defaults+0x6b>
 804bc59:	3c 69                	cmp    $0x69,%al
 804bc5b:	75 31                	jne    804bc8e <cmd_args_set_defaults+0x8c>
			*(int32_t *)args_struct[count].dest = INT32_MAX;
 804bc5d:	c7 02 ff ff ff 7f    	movl   $0x7fffffff,(%edx)
			break;
 804bc63:	eb 39                	jmp    804bc9e <cmd_args_set_defaults+0x9c>
			*(char **)args_struct[count].dest = NULL;
 804bc65:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			break;
 804bc6b:	eb 31                	jmp    804bc9e <cmd_args_set_defaults+0x9c>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
 804bc6d:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
			break;
 804bc73:	eb 29                	jmp    804bc9e <cmd_args_set_defaults+0x9c>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
 804bc75:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
 804bc7b:	c7 42 04 ff ff ff ff 	movl   $0xffffffff,0x4(%edx)
			break;
 804bc82:	eb 1a                	jmp    804bc9e <cmd_args_set_defaults+0x9c>
			*(double *)args_struct[count].dest = (double)NAN;
 804bc84:	d9 05 4c e1 04 08    	flds   0x804e14c
 804bc8a:	dd 1a                	fstpl  (%edx)
			break;
 804bc8c:	eb 10                	jmp    804bc9e <cmd_args_set_defaults+0x9c>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
 804bc8e:	52                   	push   %edx
 804bc8f:	52                   	push   %edx
 804bc90:	50                   	push   %eax
 804bc91:	68 99 eb 04 08       	push   $0x804eb99
 804bc96:	e8 7d fb ff ff       	call   804b818 <posix_print_error_and_exit>
 804bc9b:	83 c4 10             	add    $0x10,%esp
		count++;
 804bc9e:	83 c3 1c             	add    $0x1c,%ebx
 804bca1:	e9 6b ff ff ff       	jmp    804bc11 <cmd_args_set_defaults+0xf>
}
 804bca6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804bca9:	c9                   	leave  
 804bcaa:	c3                   	ret    

0804bcab <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
 804bcab:	f3 0f 1e fb          	endbr32 
 804bcaf:	55                   	push   %ebp
 804bcb0:	89 e5                	mov    %esp,%ebp
 804bcb2:	57                   	push   %edi
 804bcb3:	56                   	push   %esi
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
 804bcb4:	be 19 00 00 00       	mov    $0x19,%esi
{
 804bcb9:	53                   	push   %ebx
 804bcba:	83 ec 5c             	sub    $0x5c,%esp
 804bcbd:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804bcc0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804bcc6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804bcc9:	31 c0                	xor    %eax,%eax
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
 804bccb:	68 be eb 04 08       	push   $0x804ebbe
 804bcd0:	68 d7 eb 04 08       	push   $0x804ebd7
 804bcd5:	6a 01                	push   $0x1
 804bcd7:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804bcdd:	e8 fe d7 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bce2:	83 c4 10             	add    $0x10,%esp

	fprintf(stdout, "%s ", _HELP_SWITCH);

	while (args_struct[count].option != NULL) {
 804bce5:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
 804bce9:	74 67                	je     804bd52 <cmd_print_switches_help+0xa7>
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804bceb:	8d 45 9e             	lea    -0x62(%ebp),%eax
 804bcee:	89 da                	mov    %ebx,%edx
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
 804bcf0:	8d 7d 9e             	lea    -0x62(%ebp),%edi
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804bcf3:	e8 ae fb ff ff       	call   804b8a6 <cmd_gen_switch_syntax.constprop.0>
		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
 804bcf8:	31 c0                	xor    %eax,%eax
 804bcfa:	83 c9 ff             	or     $0xffffffff,%ecx
 804bcfd:	f2 ae                	repnz scas %es:(%edi),%al
 804bcff:	f7 d1                	not    %ecx
 804bd01:	8d 44 0e ff          	lea    -0x1(%esi,%ecx,1),%eax
 804bd05:	83 f8 64             	cmp    $0x64,%eax
 804bd08:	76 18                	jbe    804bd22 <cmd_print_switches_help+0x77>
 804bd0a:	52                   	push   %edx
			fprintf(stdout, "\n");
			printed_in_line = 0;
 804bd0b:	31 f6                	xor    %esi,%esi
 804bd0d:	68 57 ec 04 08       	push   $0x804ec57
 804bd12:	6a 01                	push   $0x1
 804bd14:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804bd1a:	e8 c1 d7 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bd1f:	83 c4 10             	add    $0x10,%esp
 804bd22:	8d 45 9e             	lea    -0x62(%ebp),%eax
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
 804bd25:	8d 7d 9e             	lea    -0x62(%ebp),%edi
 804bd28:	83 c3 1c             	add    $0x1c,%ebx
 804bd2b:	50                   	push   %eax
 804bd2c:	68 76 ea 04 08       	push   $0x804ea76
 804bd31:	6a 01                	push   $0x1
 804bd33:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804bd39:	e8 a2 d7 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bd3e:	31 c0                	xor    %eax,%eax
 804bd40:	83 c9 ff             	or     $0xffffffff,%ecx
 804bd43:	83 c4 10             	add    $0x10,%esp
 804bd46:	f2 ae                	repnz scas %es:(%edi),%al
 804bd48:	89 c8                	mov    %ecx,%eax
 804bd4a:	f7 d0                	not    %eax
 804bd4c:	8d 74 06 ff          	lea    -0x1(%esi,%eax,1),%esi
		count++;
 804bd50:	eb 93                	jmp    804bce5 <cmd_print_switches_help+0x3a>
 804bd52:	50                   	push   %eax
 804bd53:	68 57 ec 04 08       	push   $0x804ec57
 804bd58:	6a 01                	push   $0x1
 804bd5a:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804bd60:	e8 7b d7 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bd65:	83 c4 10             	add    $0x10,%esp
	}

	fprintf(stdout, "\n");
}
 804bd68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bd6b:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804bd72:	74 05                	je     804bd79 <cmd_print_switches_help+0xce>
 804bd74:	e8 17 d6 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804bd79:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bd7c:	5b                   	pop    %ebx
 804bd7d:	5e                   	pop    %esi
 804bd7e:	5f                   	pop    %edi
 804bd7f:	5d                   	pop    %ebp
 804bd80:	c3                   	ret    

0804bd81 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
 804bd81:	f3 0f 1e fb          	endbr32 
 804bd85:	55                   	push   %ebp
 804bd86:	89 e5                	mov    %esp,%ebp
 804bd88:	57                   	push   %edi
 804bd89:	56                   	push   %esi
 804bd8a:	53                   	push   %ebx
 804bd8b:	83 ec 78             	sub    $0x78,%esp
 804bd8e:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804bd91:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804bd97:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804bd9a:	31 c0                	xor    %eax,%eax
	int ret;
	int count = 0;
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
 804bd9c:	53                   	push   %ebx
 804bd9d:	e8 09 ff ff ff       	call   804bcab <cmd_print_switches_help>
 804bda2:	5a                   	pop    %edx
 804bda3:	59                   	pop    %ecx
 804bda4:	68 db eb 04 08       	push   $0x804ebdb
 804bda9:	68 be eb 04 08       	push   $0x804ebbe
 804bdae:	6a 1d                	push   $0x1d
 804bdb0:	68 ed eb 04 08       	push   $0x804ebed
 804bdb5:	6a 01                	push   $0x1
 804bdb7:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804bdbd:	e8 1e d7 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bdc2:	83 c4 20             	add    $0x20,%esp

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
 804bdc5:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
 804bdc9:	0f 84 ab 00 00 00    	je     804be7a <cmd_print_long_help+0xf9>
		int printed_right;
		char *toprint;
		int total_to_print;

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804bdcf:	8d 75 9e             	lea    -0x62(%ebp),%esi
 804bdd2:	89 da                	mov    %ebx,%edx
 804bdd4:	89 f0                	mov    %esi,%eax
 804bdd6:	e8 cb fa ff ff       	call   804b8a6 <cmd_gen_switch_syntax.constprop.0>
 804bddb:	83 ec 0c             	sub    $0xc,%esp
 804bdde:	56                   	push   %esi
 804bddf:	6a 1d                	push   $0x1d
 804bde1:	68 f8 eb 04 08       	push   $0x804ebf8
 804bde6:	6a 01                	push   $0x1
 804bde8:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804bdee:	e8 ed d6 ff ff       	call   80494e0 <__fprintf_chk@plt>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
 804bdf3:	8b 73 18             	mov    0x18(%ebx),%esi
		total_to_print = strlen(toprint);
 804bdf6:	83 c9 ff             	or     $0xffffffff,%ecx
 804bdf9:	83 c4 14             	add    $0x14,%esp
 804bdfc:	89 c2                	mov    %eax,%edx
 804bdfe:	31 c0                	xor    %eax,%eax
 804be00:	89 f7                	mov    %esi,%edi
 804be02:	f2 ae                	repnz scas %es:(%edi),%al
 804be04:	56                   	push   %esi
 804be05:	f7 d1                	not    %ecx
 804be07:	8d 41 ff             	lea    -0x1(%ecx),%eax
 804be0a:	89 45 94             	mov    %eax,-0x6c(%ebp)
		ret = fprintf(stdout, "%.*s\n",
 804be0d:	b8 64 00 00 00       	mov    $0x64,%eax
 804be12:	29 d0                	sub    %edx,%eax
 804be14:	50                   	push   %eax
 804be15:	68 ff eb 04 08       	push   $0x804ebff
 804be1a:	6a 01                	push   $0x1
 804be1c:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804be22:	e8 b9 d6 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804be27:	83 c4 20             	add    $0x20,%esp
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
 804be2a:	8d 78 ff             	lea    -0x1(%eax),%edi

		while (printed_right < total_to_print) {
 804be2d:	3b 7d 94             	cmp    -0x6c(%ebp),%edi
 804be30:	7d 40                	jge    804be72 <cmd_print_long_help+0xf1>
 804be32:	83 ec 0c             	sub    $0xc,%esp
 804be35:	68 58 ec 04 08       	push   $0x804ec58
 804be3a:	6a 1e                	push   $0x1e
 804be3c:	68 05 ec 04 08       	push   $0x804ec05
 804be41:	6a 01                	push   $0x1
 804be43:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804be49:	e8 92 d6 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804be4e:	83 c4 14             	add    $0x14,%esp
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
 804be51:	8d 04 3e             	lea    (%esi,%edi,1),%eax
 804be54:	50                   	push   %eax
 804be55:	6a 46                	push   $0x46
 804be57:	68 ff eb 04 08       	push   $0x804ebff
 804be5c:	6a 01                	push   $0x1
 804be5e:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804be64:	e8 77 d6 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804be69:	83 c4 20             	add    $0x20,%esp
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
 804be6c:	8d 7c 07 ff          	lea    -0x1(%edi,%eax,1),%edi
 804be70:	eb bb                	jmp    804be2d <cmd_print_long_help+0xac>
		}
		count++;
 804be72:	83 c3 1c             	add    $0x1c,%ebx
 804be75:	e9 4b ff ff ff       	jmp    804bdc5 <cmd_print_long_help+0x44>
 804be7a:	50                   	push   %eax
 804be7b:	68 57 ec 04 08       	push   $0x804ec57
 804be80:	6a 01                	push   $0x1
 804be82:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804be88:	e8 53 d6 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804be8d:	83 c4 0c             	add    $0xc,%esp
 804be90:	68 09 ec 04 08       	push   $0x804ec09
 804be95:	6a 01                	push   $0x1
 804be97:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804be9d:	e8 3e d6 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bea2:	83 c4 10             	add    $0x10,%esp
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
 804bea5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bea8:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804beaf:	74 05                	je     804beb6 <cmd_print_long_help+0x135>
 804beb1:	e8 da d4 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804beb6:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804beb9:	5b                   	pop    %ebx
 804beba:	5e                   	pop    %esi
 804bebb:	5f                   	pop    %edi
 804bebc:	5d                   	pop    %ebp
 804bebd:	c3                   	ret    

0804bebe <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
 804bebe:	f3 0f 1e fb          	endbr32 
 804bec2:	55                   	push   %ebp
 804bec3:	89 e5                	mov    %esp,%ebp
 804bec5:	57                   	push   %edi
 804bec6:	56                   	push   %esi
 804bec7:	53                   	push   %ebx
 804bec8:	83 ec 18             	sub    $0x18,%esp
 804becb:	8b 7d 08             	mov    0x8(%ebp),%edi
 804bece:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
 804bed1:	57                   	push   %edi
 804bed2:	e8 1f fb ff ff       	call   804b9f6 <cmd_is_help_option>
 804bed7:	83 c4 10             	add    $0x10,%esp
 804beda:	85 c0                	test   %eax,%eax
 804bedc:	74 22                	je     804bf00 <cmd_parse_one_arg+0x42>
		cmd_print_long_help(args_struct);
 804bede:	83 ec 0c             	sub    $0xc,%esp
 804bee1:	53                   	push   %ebx
 804bee2:	e8 9a fe ff ff       	call   804bd81 <cmd_print_long_help>
		posix_exit(0);
 804bee7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804beee:	e8 e8 f7 ff ff       	call   804b6db <posix_exit>
 804bef3:	83 c4 10             	add    $0x10,%esp
 804bef6:	eb 08                	jmp    804bf00 <cmd_parse_one_arg+0x42>
	}

	while (args_struct[count].option != NULL) {
		if (args_struct[count].manual) {
 804bef8:	80 3b 00             	cmpb   $0x0,(%ebx)
 804befb:	74 0c                	je     804bf09 <cmd_parse_one_arg+0x4b>
 804befd:	83 c3 1c             	add    $0x1c,%ebx
	while (args_struct[count].option != NULL) {
 804bf00:	8b 53 04             	mov    0x4(%ebx),%edx
 804bf03:	85 d2                	test   %edx,%edx
 804bf05:	75 f1                	jne    804bef8 <cmd_parse_one_arg+0x3a>
 804bf07:	eb 6b                	jmp    804bf74 <cmd_parse_one_arg+0xb6>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
 804bf09:	51                   	push   %ecx
				    !args_struct[count].is_switch);
 804bf0a:	8a 43 02             	mov    0x2(%ebx),%al
 804bf0d:	83 f0 01             	xor    $0x1,%eax
		ret = cmd_is_option(argv, args_struct[count].option,
 804bf10:	0f b6 c0             	movzbl %al,%eax
 804bf13:	50                   	push   %eax
 804bf14:	52                   	push   %edx
 804bf15:	57                   	push   %edi
 804bf16:	e8 36 fa ff ff       	call   804b951 <cmd_is_option>
 804bf1b:	83 c4 10             	add    $0x10,%esp
 804bf1e:	89 c6                	mov    %eax,%esi
		if (ret) {
 804bf20:	85 c0                	test   %eax,%eax
 804bf22:	74 d9                	je     804befd <cmd_parse_one_arg+0x3f>
	if (arg_element->dest != NULL) {
 804bf24:	8b 53 10             	mov    0x10(%ebx),%edx
 804bf27:	85 d2                	test   %edx,%edx
 804bf29:	74 33                	je     804bf5e <cmd_parse_one_arg+0xa0>
		if (arg_element->is_switch) {
 804bf2b:	80 7b 02 00          	cmpb   $0x0,0x2(%ebx)
 804bf2f:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
 804bf33:	74 18                	je     804bf4d <cmd_parse_one_arg+0x8f>
			if (arg_element->type == 'b') {
 804bf35:	3c 62                	cmp    $0x62,%al
 804bf37:	75 05                	jne    804bf3e <cmd_parse_one_arg+0x80>
				*(bool *)arg_element->dest = true;
 804bf39:	c6 02 01             	movb   $0x1,(%edx)
 804bf3c:	eb 20                	jmp    804bf5e <cmd_parse_one_arg+0xa0>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
 804bf3e:	83 ec 0c             	sub    $0xc,%esp
 804bf41:	68 59 ec 04 08       	push   $0x804ec59
 804bf46:	e8 cd f8 ff ff       	call   804b818 <posix_print_error_and_exit>
 804bf4b:	eb 0e                	jmp    804bf5b <cmd_parse_one_arg+0x9d>
			cmd_read_option_value(&argv[offset],
 804bf4d:	ff 73 04             	pushl  0x4(%ebx)
 804bf50:	50                   	push   %eax
 804bf51:	8d 04 37             	lea    (%edi,%esi,1),%eax
 804bf54:	52                   	push   %edx
 804bf55:	50                   	push   %eax
 804bf56:	e8 0b fb ff ff       	call   804ba66 <cmd_read_option_value>
 804bf5b:	83 c4 10             	add    $0x10,%esp
	if (arg_element->call_when_found) {
 804bf5e:	8b 53 14             	mov    0x14(%ebx),%edx
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
 804bf61:	b0 01                	mov    $0x1,%al
	if (arg_element->call_when_found) {
 804bf63:	85 d2                	test   %edx,%edx
 804bf65:	74 0f                	je     804bf76 <cmd_parse_one_arg+0xb8>
		arg_element->call_when_found(argv, offset);
 804bf67:	50                   	push   %eax
 804bf68:	50                   	push   %eax
 804bf69:	56                   	push   %esi
 804bf6a:	57                   	push   %edi
 804bf6b:	ff d2                	call   *%edx
			return true;
 804bf6d:	b0 01                	mov    $0x1,%al
		arg_element->call_when_found(argv, offset);
 804bf6f:	83 c4 10             	add    $0x10,%esp
 804bf72:	eb 02                	jmp    804bf76 <cmd_parse_one_arg+0xb8>
		}
		count++;
	}
	return false;
 804bf74:	31 c0                	xor    %eax,%eax
}
 804bf76:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bf79:	5b                   	pop    %ebx
 804bf7a:	5e                   	pop    %esi
 804bf7b:	5f                   	pop    %edi
 804bf7c:	5d                   	pop    %ebp
 804bf7d:	c3                   	ret    

0804bf7e <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
 804bf7e:	f3 0f 1e fb          	endbr32 
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
 804bf82:	a1 7c 24 05 08       	mov    0x805247c,%eax
 804bf87:	85 c0                	test   %eax,%eax
 804bf89:	74 1b                	je     804bfa6 <native_cleanup_cmd_line+0x28>
{
 804bf8b:	55                   	push   %ebp
 804bf8c:	89 e5                	mov    %esp,%ebp
 804bf8e:	83 ec 14             	sub    $0x14,%esp
		free(args_struct);
 804bf91:	50                   	push   %eax
 804bf92:	e8 99 d3 ff ff       	call   8049330 <free@plt>
 804bf97:	83 c4 10             	add    $0x10,%esp
		args_struct = NULL;
 804bf9a:	c7 05 7c 24 05 08 00 	movl   $0x0,0x805247c
 804bfa1:	00 00 00 
	}
}
 804bfa4:	c9                   	leave  
 804bfa5:	c3                   	ret    
 804bfa6:	c3                   	ret    

0804bfa7 <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
 804bfa7:	f3 0f 1e fb          	endbr32 
 804bfab:	55                   	push   %ebp
 804bfac:	89 e5                	mov    %esp,%ebp
 804bfae:	57                   	push   %edi
	int count = 0;
 804bfaf:	31 ff                	xor    %edi,%edi
{
 804bfb1:	56                   	push   %esi
 804bfb2:	53                   	push   %ebx
 804bfb3:	83 ec 1c             	sub    $0x1c,%esp
 804bfb6:	8b 75 08             	mov    0x8(%ebp),%esi

	while (args[count].option != NULL) {
 804bfb9:	6b c7 1c             	imul   $0x1c,%edi,%eax
 804bfbc:	89 7d e4             	mov    %edi,-0x1c(%ebp)
 804bfbf:	47                   	inc    %edi
 804bfc0:	83 7c 06 04 00       	cmpl   $0x0,0x4(%esi,%eax,1)
 804bfc5:	75 f2                	jne    804bfb9 <native_add_command_line_opts+0x12>
		count++;
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
 804bfc7:	8b 15 78 24 05 08    	mov    0x8052478,%edx
 804bfcd:	a1 74 24 05 08       	mov    0x8052474,%eax
 804bfd2:	01 fa                	add    %edi,%edx
 804bfd4:	39 c2                	cmp    %eax,%edx
 804bfd6:	7c 43                	jl     804c01b <native_add_command_line_opts+0x74>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
 804bfd8:	83 ff 14             	cmp    $0x14,%edi
 804bfdb:	ba 14 00 00 00       	mov    $0x14,%edx
 804bfe0:	0f 4d d7             	cmovge %edi,%edx
 804bfe3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
		struct args_struct_t *new_args_struct = realloc(args_struct,
 804bfe6:	50                   	push   %eax
 804bfe7:	50                   	push   %eax
 804bfe8:	6b c3 1c             	imul   $0x1c,%ebx,%eax
 804bfeb:	50                   	push   %eax
 804bfec:	ff 35 7c 24 05 08    	pushl  0x805247c
 804bff2:	e8 c9 d3 ff ff       	call   80493c0 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
 804bff7:	89 1d 74 24 05 08    	mov    %ebx,0x8052474
		struct args_struct_t *new_args_struct = realloc(args_struct,
 804bffd:	83 c4 10             	add    $0x10,%esp
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
 804c000:	85 c0                	test   %eax,%eax
 804c002:	75 12                	jne    804c016 <native_add_command_line_opts+0x6f>
			posix_print_error_and_exit("Could not allocate memory");
 804c004:	83 ec 0c             	sub    $0xc,%esp
 804c007:	68 a4 ec 04 08       	push   $0x804eca4
 804c00c:	e8 07 f8 ff ff       	call   804b818 <posix_print_error_and_exit>
 804c011:	83 c4 10             	add    $0x10,%esp
 804c014:	eb 05                	jmp    804c01b <native_add_command_line_opts+0x74>
		} else {
			args_struct = new_args_struct;
 804c016:	a3 7c 24 05 08       	mov    %eax,0x805247c
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
 804c01b:	8b 15 78 24 05 08    	mov    0x8052478,%edx
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
 804c021:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	memcpy(&args_struct[used_args], args,
 804c024:	6b cf 1c             	imul   $0x1c,%edi,%ecx
 804c027:	6b c2 1c             	imul   $0x1c,%edx,%eax
 804c02a:	03 05 7c 24 05 08    	add    0x805247c,%eax
	used_args += count - 1;
 804c030:	01 d3                	add    %edx,%ebx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
 804c032:	89 c7                	mov    %eax,%edi
 804c034:	89 1d 78 24 05 08    	mov    %ebx,0x8052478
 804c03a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
 804c03c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c03f:	5b                   	pop    %ebx
 804c040:	5e                   	pop    %esi
 804c041:	5f                   	pop    %edi
 804c042:	5d                   	pop    %ebp
 804c043:	c3                   	ret    

0804c044 <native_add_testargs_option>:

void native_add_testargs_option(void)
{
 804c044:	f3 0f 1e fb          	endbr32 
 804c048:	55                   	push   %ebp
 804c049:	89 e5                	mov    %esp,%ebp
 804c04b:	83 ec 14             	sub    $0x14,%esp
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
 804c04e:	68 20 12 05 08       	push   $0x8051220
 804c053:	e8 4f ff ff ff       	call   804bfa7 <native_add_command_line_opts>
 804c058:	83 c4 10             	add    $0x10,%esp
}
 804c05b:	c9                   	leave  
 804c05c:	c3                   	ret    

0804c05d <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
 804c05d:	f3 0f 1e fb          	endbr32 
 804c061:	55                   	push   %ebp
 804c062:	89 e5                	mov    %esp,%ebp
 804c064:	57                   	push   %edi
 804c065:	56                   	push   %esi
 804c066:	53                   	push   %ebx
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
 804c067:	bb 01 00 00 00       	mov    $0x1,%ebx
{
 804c06c:	83 ec 0c             	sub    $0xc,%esp
 804c06f:	8b 75 0c             	mov    0xc(%ebp),%esi
	native_add_tracing_options();
 804c072:	e8 16 f8 ff ff       	call   804b88d <native_add_tracing_options>
	native_add_testargs_option();
 804c077:	e8 c8 ff ff ff       	call   804c044 <native_add_testargs_option>
	cmd_args_set_defaults(args_struct);
 804c07c:	83 ec 0c             	sub    $0xc,%esp
	s_argc = argc;
 804c07f:	8b 45 08             	mov    0x8(%ebp),%eax
	cmd_args_set_defaults(args_struct);
 804c082:	ff 35 7c 24 05 08    	pushl  0x805247c
	s_argv = argv;
 804c088:	89 35 84 24 05 08    	mov    %esi,0x8052484
	s_argc = argc;
 804c08e:	a3 8c 24 05 08       	mov    %eax,0x805248c
	cmd_args_set_defaults(args_struct);
 804c093:	e8 6a fb ff ff       	call   804bc02 <cmd_args_set_defaults>
 804c098:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
 804c09b:	3b 5d 08             	cmp    0x8(%ebp),%ebx
 804c09e:	7d 6d                	jge    804c10d <native_handle_cmd_line+0xb0>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
 804c0a0:	57                   	push   %edi
 804c0a1:	8d 7b 01             	lea    0x1(%ebx),%edi
 804c0a4:	6a 00                	push   $0x0
 804c0a6:	68 be ec 04 08       	push   $0x804ecbe
 804c0ab:	ff 34 9e             	pushl  (%esi,%ebx,4)
 804c0ae:	e8 9e f8 ff ff       	call   804b951 <cmd_is_option>
 804c0b3:	83 c4 10             	add    $0x10,%esp
 804c0b6:	85 c0                	test   %eax,%eax
 804c0b8:	74 18                	je     804c0d2 <native_handle_cmd_line+0x75>
			test_argc = argc - i - 1;
 804c0ba:	8b 45 08             	mov    0x8(%ebp),%eax
 804c0bd:	29 d8                	sub    %ebx,%eax
 804c0bf:	89 c3                	mov    %eax,%ebx
			test_argv = &argv[i+1];
 804c0c1:	8d 04 be             	lea    (%esi,%edi,4),%eax
			test_argc = argc - i - 1;
 804c0c4:	4b                   	dec    %ebx
			test_argv = &argv[i+1];
 804c0c5:	a3 80 24 05 08       	mov    %eax,0x8052480
			test_argc = argc - i - 1;
 804c0ca:	89 1d 88 24 05 08    	mov    %ebx,0x8052488
			break;
 804c0d0:	eb 3b                	jmp    804c10d <native_handle_cmd_line+0xb0>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
 804c0d2:	51                   	push   %ecx
 804c0d3:	51                   	push   %ecx
 804c0d4:	ff 35 7c 24 05 08    	pushl  0x805247c
 804c0da:	ff 34 9e             	pushl  (%esi,%ebx,4)
 804c0dd:	e8 dc fd ff ff       	call   804bebe <cmd_parse_one_arg>
 804c0e2:	83 c4 10             	add    $0x10,%esp
 804c0e5:	84 c0                	test   %al,%al
 804c0e7:	75 20                	jne    804c109 <native_handle_cmd_line+0xac>
			cmd_print_switches_help(args_struct);
 804c0e9:	83 ec 0c             	sub    $0xc,%esp
 804c0ec:	ff 35 7c 24 05 08    	pushl  0x805247c
 804c0f2:	e8 b4 fb ff ff       	call   804bcab <cmd_print_switches_help>
 804c0f7:	58                   	pop    %eax
 804c0f8:	5a                   	pop    %edx
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
 804c0f9:	ff 34 9e             	pushl  (%esi,%ebx,4)
 804c0fc:	68 c7 ec 04 08       	push   $0x804ecc7
 804c101:	e8 12 f7 ff ff       	call   804b818 <posix_print_error_and_exit>
 804c106:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
 804c109:	89 fb                	mov    %edi,%ebx
 804c10b:	eb 8e                	jmp    804c09b <native_handle_cmd_line+0x3e>
			print_invalid_opt_error(argv[i]);
		}
	}
}
 804c10d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c110:	5b                   	pop    %ebx
 804c111:	5e                   	pop    %esi
 804c112:	5f                   	pop    %edi
 804c113:	5d                   	pop    %ebp
 804c114:	c3                   	ret    

0804c115 <hw_counter_init>:

/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
 804c115:	f3 0f 1e fb          	endbr32 
	hw_counter_timer = NEVER;
 804c119:	c7 05 08 24 05 08 ff 	movl   $0xffffffff,0x8052408
 804c120:	ff ff ff 
 804c123:	c7 05 0c 24 05 08 ff 	movl   $0xffffffff,0x805240c
 804c12a:	ff ff ff 
	counter_target = NEVER;
 804c12d:	c7 05 f8 23 05 08 ff 	movl   $0xffffffff,0x80523f8
 804c134:	ff ff ff 
 804c137:	c7 05 fc 23 05 08 ff 	movl   $0xffffffff,0x80523fc
 804c13e:	ff ff ff 
	counter_value = 0;
 804c141:	c7 05 00 24 05 08 00 	movl   $0x0,0x8052400
 804c148:	00 00 00 
 804c14b:	c7 05 04 24 05 08 00 	movl   $0x0,0x8052404
 804c152:	00 00 00 
	counter_running = false;
 804c155:	c6 05 a2 24 05 08 00 	movb   $0x0,0x80524a2
	counter_period = NEVER;
 804c15c:	c7 05 f0 23 05 08 ff 	movl   $0xffffffff,0x80523f0
 804c163:	ff ff ff 
 804c166:	c7 05 f4 23 05 08 ff 	movl   $0xffffffff,0x80523f4
 804c16d:	ff ff ff 
}
 804c170:	c3                   	ret    

0804c171 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
 804c171:	f3 0f 1e fb          	endbr32 
	if (!counter_running) {
 804c175:	80 3d a2 24 05 08 00 	cmpb   $0x0,0x80524a2
 804c17c:	75 15                	jne    804c193 <hw_counter_triggered+0x22>
		hw_counter_timer = NEVER;
 804c17e:	c7 05 08 24 05 08 ff 	movl   $0xffffffff,0x8052408
 804c185:	ff ff ff 
 804c188:	c7 05 0c 24 05 08 ff 	movl   $0xffffffff,0x805240c
 804c18f:	ff ff ff 
		return;
 804c192:	c3                   	ret    
{
 804c193:	55                   	push   %ebp
 804c194:	89 e5                	mov    %esp,%ebp
 804c196:	83 ec 08             	sub    $0x8,%esp
	}

	hw_counter_timer = hwm_get_time() + counter_period;
 804c199:	e8 2d ea ff ff       	call   804abcb <hwm_get_time>
 804c19e:	03 05 f0 23 05 08    	add    0x80523f0,%eax
 804c1a4:	13 15 f4 23 05 08    	adc    0x80523f4,%edx
 804c1aa:	a3 08 24 05 08       	mov    %eax,0x8052408
	counter_value = counter_value + 1;
 804c1af:	a1 00 24 05 08       	mov    0x8052400,%eax
	hw_counter_timer = hwm_get_time() + counter_period;
 804c1b4:	89 15 0c 24 05 08    	mov    %edx,0x805240c
	counter_value = counter_value + 1;
 804c1ba:	8b 15 04 24 05 08    	mov    0x8052404,%edx
 804c1c0:	83 c0 01             	add    $0x1,%eax
 804c1c3:	83 d2 00             	adc    $0x0,%edx
 804c1c6:	a3 00 24 05 08       	mov    %eax,0x8052400
 804c1cb:	89 15 04 24 05 08    	mov    %edx,0x8052404

	if (counter_value == counter_target) {
 804c1d1:	3b 15 fc 23 05 08    	cmp    0x80523fc,%edx
 804c1d7:	75 15                	jne    804c1ee <hw_counter_triggered+0x7d>
 804c1d9:	3b 05 f8 23 05 08    	cmp    0x80523f8,%eax
 804c1df:	75 0d                	jne    804c1ee <hw_counter_triggered+0x7d>
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
 804c1e1:	83 ec 0c             	sub    $0xc,%esp
 804c1e4:	6a 02                	push   $0x2
 804c1e6:	e8 29 f4 ff ff       	call   804b614 <hw_irq_ctrl_set_irq>
 804c1eb:	83 c4 10             	add    $0x10,%esp
	}
}
 804c1ee:	c9                   	leave  
 804c1ef:	c3                   	ret    

0804c1f0 <native_posix_console_init>:
	}
}
#endif /* CONFIG_NATIVE_POSIX_STDIN_CONSOLE */

static int native_posix_console_init(const struct device *arg)
{
 804c1f0:	f3 0f 1e fb          	endbr32 
 804c1f4:	55                   	push   %ebp
 804c1f5:	89 e5                	mov    %esp,%ebp
 804c1f7:	83 ec 08             	sub    $0x8,%esp
	setvbuf(stdout, NULL, _IOLBF, 512);
 804c1fa:	68 00 02 00 00       	push   $0x200
 804c1ff:	6a 01                	push   $0x1
 804c201:	6a 00                	push   $0x0
 804c203:	ff 35 c4 1f 05 08    	pushl  0x8051fc4
 804c209:	e8 12 d2 ff ff       	call   8049420 <setvbuf@plt>
 804c20e:	83 c4 10             	add    $0x10,%esp
	setvbuf(stderr, NULL, _IOLBF, 512);
 804c211:	68 00 02 00 00       	push   $0x200
 804c216:	6a 01                	push   $0x1
 804c218:	6a 00                	push   $0x0
 804c21a:	ff 35 c0 1f 05 08    	pushl  0x8051fc0
 804c220:	e8 fb d1 ff ff       	call   8049420 <setvbuf@plt>
	__printk_hook_install(putchar);
 804c225:	c7 04 24 40 94 04 08 	movl   $0x8049440,(%esp)
 804c22c:	e8 17 d5 ff ff       	call   8049748 <__printk_hook_install>
 804c231:	83 c4 10             	add    $0x10,%esp
#if defined(CONFIG_NATIVE_POSIX_STDOUT_CONSOLE)
	native_posix_stdout_init();
#endif

	return 0;
}
 804c234:	31 c0                	xor    %eax,%eax
 804c236:	c9                   	leave  
 804c237:	c3                   	ret    

0804c238 <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
 804c238:	f3 0f 1e fb          	endbr32 
 804c23c:	55                   	push   %ebp
 804c23d:	89 e5                	mov    %esp,%ebp
 804c23f:	57                   	push   %edi
 804c240:	56                   	push   %esi
 804c241:	83 ec 10             	sub    $0x10,%esp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
 804c244:	e8 82 e9 ff ff       	call   804abcb <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
 804c249:	8b 35 10 24 05 08    	mov    0x8052410,%esi
 804c24f:	8b 3d 14 24 05 08    	mov    0x8052414,%edi
 804c255:	89 75 e8             	mov    %esi,-0x18(%ebp)
 804c258:	8b 35 18 24 05 08    	mov    0x8052418,%esi
 804c25e:	89 7d ec             	mov    %edi,-0x14(%ebp)
 804c261:	8b 3d 1c 24 05 08    	mov    0x805241c,%edi
 804c267:	2b 45 e8             	sub    -0x18(%ebp),%eax
 804c26a:	1b 55 ec             	sbb    -0x14(%ebp),%edx
 804c26d:	89 75 f0             	mov    %esi,-0x10(%ebp)
 804c270:	57                   	push   %edi
 804c271:	56                   	push   %esi
 804c272:	52                   	push   %edx
 804c273:	50                   	push   %eax
 804c274:	89 7d f4             	mov    %edi,-0xc(%ebp)
 804c277:	e8 74 d0 ff ff       	call   80492f0 <__udivdi3@plt>

	last_tick_time += elapsed_ticks*tick_period;
 804c27c:	8b 7d f4             	mov    -0xc(%ebp),%edi
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
 804c27f:	83 c4 10             	add    $0x10,%esp
 804c282:	89 c1                	mov    %eax,%ecx
	last_tick_time += elapsed_ticks*tick_period;
 804c284:	99                   	cltd   
 804c285:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c288:	0f af f9             	imul   %ecx,%edi
	sys_clock_announce(elapsed_ticks);
 804c28b:	89 4d 08             	mov    %ecx,0x8(%ebp)
	last_tick_time += elapsed_ticks*tick_period;
 804c28e:	0f af c2             	imul   %edx,%eax
 804c291:	01 c7                	add    %eax,%edi
 804c293:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c296:	f7 e1                	mul    %ecx
 804c298:	01 fa                	add    %edi,%edx
 804c29a:	03 45 e8             	add    -0x18(%ebp),%eax
 804c29d:	13 55 ec             	adc    -0x14(%ebp),%edx
 804c2a0:	a3 10 24 05 08       	mov    %eax,0x8052410
 804c2a5:	89 15 14 24 05 08    	mov    %edx,0x8052414
}
 804c2ab:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804c2ae:	5e                   	pop    %esi
 804c2af:	5f                   	pop    %edi
 804c2b0:	5d                   	pop    %ebp
	sys_clock_announce(elapsed_ticks);
 804c2b1:	e9 c3 0b 00 00       	jmp    804ce79 <sys_clock_announce>

0804c2b6 <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
static int sys_clock_driver_init(const struct device *dev)
{
 804c2b6:	f3 0f 1e fb          	endbr32 
 804c2ba:	55                   	push   %ebp
 804c2bb:	89 e5                	mov    %esp,%ebp
 804c2bd:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(dev);

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
 804c2c0:	c7 05 18 24 05 08 10 	movl   $0x2710,0x8052418
 804c2c7:	27 00 00 
 804c2ca:	c7 05 1c 24 05 08 00 	movl   $0x0,0x805241c
 804c2d1:	00 00 00 

	last_tick_time = hwm_get_time();
 804c2d4:	e8 f2 e8 ff ff       	call   804abcb <hwm_get_time>
 804c2d9:	89 15 14 24 05 08    	mov    %edx,0x8052414
	hwtimer_enable(tick_period);
 804c2df:	52                   	push   %edx
 804c2e0:	52                   	push   %edx
 804c2e1:	ff 35 1c 24 05 08    	pushl  0x805241c
 804c2e7:	ff 35 18 24 05 08    	pushl  0x8052418
	last_tick_time = hwm_get_time();
 804c2ed:	a3 10 24 05 08       	mov    %eax,0x8052410
	hwtimer_enable(tick_period);
 804c2f2:	e8 e0 ec ff ff       	call   804afd7 <hwtimer_enable>
 804c2f7:	83 c4 10             	add    $0x10,%esp

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
 804c2fa:	6a 00                	push   $0x0
 804c2fc:	68 38 c2 04 08       	push   $0x804c238
 804c301:	6a 00                	push   $0x0
 804c303:	6a 00                	push   $0x0
 804c305:	e8 9a f0 ff ff       	call   804b3a4 <posix_isr_declare>
 804c30a:	83 c4 0c             	add    $0xc,%esp
 804c30d:	6a 00                	push   $0x0
 804c30f:	6a 01                	push   $0x1
 804c311:	6a 00                	push   $0x0
 804c313:	e8 bb f0 ff ff       	call   804b3d3 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
 804c318:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804c31f:	e8 4e de ff ff       	call   804a172 <arch_irq_enable>
 804c324:	83 c4 10             	add    $0x10,%esp

	return 0;
}
 804c327:	31 c0                	xor    %eax,%eax
 804c329:	c9                   	leave  
 804c32a:	c3                   	ret    

0804c32b <sys_clock_set_timeout>:
{
 804c32b:	f3 0f 1e fb          	endbr32 
 804c32f:	55                   	push   %ebp
		silent_ticks = INT64_MAX;
 804c330:	83 c9 ff             	or     $0xffffffff,%ecx
{
 804c333:	89 e5                	mov    %esp,%ebp
 804c335:	53                   	push   %ebx
		silent_ticks = INT64_MAX;
 804c336:	bb ff ff ff 7f       	mov    $0x7fffffff,%ebx
{
 804c33b:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ticks == K_TICKS_FOREVER) {
 804c33e:	83 f8 ff             	cmp    $0xffffffff,%eax
 804c341:	74 10                	je     804c353 <sys_clock_set_timeout+0x28>
		silent_ticks = 0;
 804c343:	31 c9                	xor    %ecx,%ecx
 804c345:	31 db                	xor    %ebx,%ebx
	} else if (ticks > 0) {
 804c347:	85 c0                	test   %eax,%eax
 804c349:	7e 08                	jle    804c353 <sys_clock_set_timeout+0x28>
		silent_ticks = ticks - 1;
 804c34b:	48                   	dec    %eax
 804c34c:	89 c3                	mov    %eax,%ebx
 804c34e:	89 c1                	mov    %eax,%ecx
 804c350:	c1 fb 1f             	sar    $0x1f,%ebx
	hwtimer_set_silent_ticks(silent_ticks);
 804c353:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
 804c356:	5b                   	pop    %ebx
	hwtimer_set_silent_ticks(silent_ticks);
 804c357:	89 4d 08             	mov    %ecx,0x8(%ebp)
}
 804c35a:	5d                   	pop    %ebp
	hwtimer_set_silent_ticks(silent_ticks);
 804c35b:	e9 9a ee ff ff       	jmp    804b1fa <hwtimer_set_silent_ticks>

0804c360 <sys_clock_elapsed>:
{
 804c360:	f3 0f 1e fb          	endbr32 
 804c364:	55                   	push   %ebp
 804c365:	89 e5                	mov    %esp,%ebp
 804c367:	83 ec 08             	sub    $0x8,%esp
	return (hwm_get_time() - last_tick_time)/tick_period;
 804c36a:	e8 5c e8 ff ff       	call   804abcb <hwm_get_time>
 804c36f:	2b 05 10 24 05 08    	sub    0x8052410,%eax
 804c375:	1b 15 14 24 05 08    	sbb    0x8052414,%edx
 804c37b:	ff 35 1c 24 05 08    	pushl  0x805241c
 804c381:	ff 35 18 24 05 08    	pushl  0x8052418
 804c387:	52                   	push   %edx
 804c388:	50                   	push   %eax
 804c389:	e8 62 cf ff ff       	call   80492f0 <__udivdi3@plt>
 804c38e:	83 c4 10             	add    $0x10,%esp
}
 804c391:	c9                   	leave  
 804c392:	c3                   	ret    

0804c393 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
 804c393:	f3 0f 1e fb          	endbr32 
 804c397:	55                   	push   %ebp
 804c398:	89 e5                	mov    %esp,%ebp
 804c39a:	83 ec 14             	sub    $0x14,%esp
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
 804c39d:	c6 05 a3 24 05 08 01 	movb   $0x1,0x80524a3

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
 804c3a4:	6a 02                	push   $0x2
 804c3a6:	e8 f9 0b 00 00       	call   804cfa4 <z_sys_init_run_level>
 804c3ab:	83 c4 10             	add    $0x10,%esp
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
 804c3ae:	e8 c9 0b 00 00       	call   804cf7c <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
 804c3b3:	83 ec 0c             	sub    $0xc,%esp
 804c3b6:	6a 03                	push   $0x3
 804c3b8:	e8 e7 0b 00 00       	call   804cfa4 <z_sys_init_run_level>
 804c3bd:	83 c4 10             	add    $0x10,%esp

	z_init_static_threads();
 804c3c0:	e8 cf 01 00 00       	call   804c594 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern void main(void);

	main();
 804c3c5:	e8 30 d3 ff ff       	call   80496fa <zephyr_app_main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
 804c3ca:	80 25 0c 23 05 08 fe 	andb   $0xfe,0x805230c

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 804c3d1:	c9                   	leave  
 804c3d2:	c3                   	ret    

0804c3d3 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
 804c3d3:	f3 0f 1e fb          	endbr32 
 804c3d7:	55                   	push   %ebp
 804c3d8:	89 e5                	mov    %esp,%ebp
 804c3da:	57                   	push   %edi
 804c3db:	56                   	push   %esi
 804c3dc:	53                   	push   %ebx
 804c3dd:	83 ec 14             	sub    $0x14,%esp
 804c3e0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	z_setup_new_thread(thread, stack,
 804c3e3:	6a 00                	push   $0x0
	struct k_thread *thread = &z_idle_threads[i];
 804c3e5:	6b fb 50             	imul   $0x50,%ebx,%edi
	k_thread_stack_t *stack = z_idle_stacks[i];
 804c3e8:	89 d8                	mov    %ebx,%eax
	z_setup_new_thread(thread, stack,
 804c3ea:	6a 01                	push   $0x1
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 804c3ec:	6b f3 18             	imul   $0x18,%ebx,%esi
	k_thread_stack_t *stack = z_idle_stacks[i];
 804c3ef:	c1 e0 08             	shl    $0x8,%eax
	z_setup_new_thread(thread, stack,
 804c3f2:	6a 0f                	push   $0xf
	k_thread_stack_t *stack = z_idle_stacks[i];
 804c3f4:	05 94 1a 05 08       	add    $0x8051a94,%eax
	z_setup_new_thread(thread, stack,
 804c3f9:	6a 00                	push   $0x0
	struct k_thread *thread = &z_idle_threads[i];
 804c3fb:	81 c7 a0 22 05 08    	add    $0x80522a0,%edi
	z_setup_new_thread(thread, stack,
 804c401:	6a 00                	push   $0x0
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 804c403:	81 c6 60 23 05 08    	add    $0x8052360,%esi
	z_setup_new_thread(thread, stack,
 804c409:	56                   	push   %esi
 804c40a:	68 4d c6 04 08       	push   $0x804c64d
 804c40f:	68 00 01 00 00       	push   $0x100
 804c414:	50                   	push   %eax
 804c415:	57                   	push   %edi
 804c416:	e8 f2 00 00 00       	call   804c50d <z_setup_new_thread>
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
 804c41b:	88 5e 14             	mov    %bl,0x14(%esi)
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 804c41e:	c1 e3 0b             	shl    $0xb,%ebx
	z_setup_new_thread(thread, stack,
 804c421:	83 c4 30             	add    $0x30,%esp
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 804c424:	8d 83 94 1a 05 08    	lea    0x8051a94(%ebx),%eax
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
 804c42a:	80 67 0d fb          	andb   $0xfb,0xd(%edi)
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 804c42e:	89 7e 0c             	mov    %edi,0xc(%esi)
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 804c431:	89 46 04             	mov    %eax,0x4(%esi)
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
 804c434:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c437:	5b                   	pop    %ebx
 804c438:	5e                   	pop    %esi
 804c439:	5f                   	pop    %edi
 804c43a:	5d                   	pop    %ebp
 804c43b:	c3                   	ret    

0804c43c <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
 804c43c:	f3 0f 1e fb          	endbr32 
 804c440:	55                   	push   %ebp
 804c441:	89 e5                	mov    %esp,%ebp
 804c443:	53                   	push   %ebx
 804c444:	83 ec 64             	sub    $0x64,%esp
 804c447:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804c44d:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c450:	31 c0                	xor    %eax,%eax
	k_thread_system_pool_assign(dummy_thread);
#else
	dummy_thread->resource_pool = NULL;
#endif

	_current_cpu->current = dummy_thread;
 804c452:	8d 45 a4             	lea    -0x5c(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
 804c455:	66 c7 45 b0 01 01    	movw   $0x101,-0x50(%ebp)
	_current_cpu->current = dummy_thread;
 804c45b:	a3 68 23 05 08       	mov    %eax,0x8052368
	dummy_thread->resource_pool = NULL;
 804c460:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
 804c467:	e8 33 0b 00 00       	call   804cf9f <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
 804c46c:	83 ec 0c             	sub    $0xc,%esp
 804c46f:	6a 00                	push   $0x0
 804c471:	e8 2e 0b 00 00       	call   804cfa4 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
 804c476:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804c47d:	e8 22 0b 00 00       	call   804cfa4 <z_sys_init_run_level>
 804c482:	83 c4 10             	add    $0x10,%esp
	z_sched_init();
 804c485:	e8 45 06 00 00       	call   804cacf <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
 804c48a:	c7 05 78 23 05 08 00 	movl   $0x8052300,0x8052378
 804c491:	23 05 08 
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 804c494:	50                   	push   %eax
 804c495:	50                   	push   %eax
 804c496:	68 83 ed 04 08       	push   $0x804ed83
 804c49b:	6a 01                	push   $0x1
 804c49d:	6a 00                	push   $0x0
 804c49f:	6a 00                	push   $0x0
 804c4a1:	6a 00                	push   $0x0
 804c4a3:	6a 00                	push   $0x0
 804c4a5:	68 93 c3 04 08       	push   $0x804c393
 804c4aa:	68 00 04 00 00       	push   $0x400
 804c4af:	68 94 1b 05 08       	push   $0x8051b94
 804c4b4:	68 00 23 05 08       	push   $0x8052300
 804c4b9:	e8 4f 00 00 00       	call   804c50d <z_setup_new_thread>
 804c4be:	83 c4 24             	add    $0x24,%esp
 804c4c1:	80 25 0d 23 05 08 fb 	andb   $0xfb,0x805230d
	z_ready_thread(&z_main_thread);
 804c4c8:	68 00 23 05 08       	push   $0x8052300
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 804c4cd:	89 c3                	mov    %eax,%ebx
	z_ready_thread(&z_main_thread);
 804c4cf:	e8 1b 05 00 00       	call   804c9ef <z_ready_thread>
	z_init_cpu(0);
 804c4d4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804c4db:	e8 f3 fe ff ff       	call   804c3d3 <z_init_cpu>
 804c4e0:	83 c4 0c             	add    $0xc,%esp
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 804c4e3:	68 93 c3 04 08       	push   $0x804c393
 804c4e8:	53                   	push   %ebx
 804c4e9:	68 00 23 05 08       	push   $0x8052300
 804c4ee:	e8 63 e1 ff ff       	call   804a656 <arch_switch_to_main_thread>
 804c4f3:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 804c4f6:	68 69 01 00 00       	push   $0x169
 804c4fb:	68 88 ed 04 08       	push   $0x804ed88
 804c500:	68 a0 e1 04 08       	push   $0x804e1a0
 804c505:	e8 0e f3 ff ff       	call   804b818 <posix_print_error_and_exit>
 804c50a:	83 c4 10             	add    $0x10,%esp

0804c50d <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
 804c50d:	f3 0f 1e fb          	endbr32 
 804c511:	55                   	push   %ebp
 804c512:	89 e5                	mov    %esp,%ebp
 804c514:	53                   	push   %ebx
 804c515:	83 ec 18             	sub    $0x18,%esp
 804c518:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804c51b:	8b 55 0c             	mov    0xc(%ebp),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
 804c51e:	8d 43 3c             	lea    0x3c(%ebx),%eax

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
 804c521:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
 * @param list the doubly-linked list
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
 804c528:	89 43 3c             	mov    %eax,0x3c(%ebx)
	list->tail = (sys_dnode_t *)list;
 804c52b:	89 43 40             	mov    %eax,0x40(%ebx)
	thread_base->user_options = (uint8_t)options;
 804c52e:	8b 45 28             	mov    0x28(%ebp),%eax
	thread_base->thread_state = (uint8_t)initial_state;
 804c531:	c6 43 0d 04          	movb   $0x4,0xd(%ebx)
	thread_base->user_options = (uint8_t)options;
 804c535:	88 43 0c             	mov    %al,0xc(%ebx)

	thread_base->prio = priority;
 804c538:	8b 45 24             	mov    0x24(%ebp),%eax

	thread_base->sched_locked = 0U;
 804c53b:	c6 43 0f 00          	movb   $0x0,0xf(%ebx)
	thread_base->prio = priority;
 804c53f:	88 43 0e             	mov    %al,0xe(%ebx)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
 804c542:	8b 45 10             	mov    0x10(%ebp),%eax
 * @param node the node
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
 804c545:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
 804c54c:	83 c0 03             	add    $0x3,%eax
	node->prev = NULL;
 804c54f:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
 804c556:	83 e0 fc             	and    $0xfffffffc,%eax
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 804c559:	ff 75 20             	pushl  0x20(%ebp)
	stack_ptr = (char *)stack + stack_obj_size;
 804c55c:	01 d0                	add    %edx,%eax
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 804c55e:	ff 75 1c             	pushl  0x1c(%ebp)
 804c561:	ff 75 18             	pushl  0x18(%ebp)
 804c564:	ff 75 14             	pushl  0x14(%ebp)
 804c567:	50                   	push   %eax
 804c568:	52                   	push   %edx
 804c569:	53                   	push   %ebx
 804c56a:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c56d:	e8 04 e1 ff ff       	call   804a676 <arch_new_thread>
	if (!_current) {
 804c572:	8b 15 68 23 05 08    	mov    0x8052368,%edx
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 804c578:	83 c4 20             	add    $0x20,%esp
	if (!_current) {
 804c57b:	8b 45 f4             	mov    -0xc(%ebp),%eax
	new_thread->init_data = NULL;
 804c57e:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
	if (!_current) {
 804c585:	85 d2                	test   %edx,%edx
 804c587:	74 03                	je     804c58c <z_setup_new_thread+0x7f>
	new_thread->resource_pool = _current->resource_pool;
 804c589:	8b 52 48             	mov    0x48(%edx),%edx
	return stack_ptr;
 804c58c:	89 53 48             	mov    %edx,0x48(%ebx)
}
 804c58f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804c592:	c9                   	leave  
 804c593:	c3                   	ret    

0804c594 <z_init_static_threads>:
{
 804c594:	f3 0f 1e fb          	endbr32 
 804c598:	55                   	push   %ebp
 804c599:	89 e5                	mov    %esp,%ebp
 804c59b:	56                   	push   %esi
 804c59c:	53                   	push   %ebx
	_FOREACH_STATIC_THREAD(thread_data) {
 804c59d:	bb b0 1f 05 08       	mov    $0x8051fb0,%ebx
 804c5a2:	81 fb b0 1f 05 08    	cmp    $0x8051fb0,%ebx
 804c5a8:	73 31                	jae    804c5db <z_init_static_threads+0x47>
		z_setup_new_thread(
 804c5aa:	50                   	push   %eax
 804c5ab:	50                   	push   %eax
 804c5ac:	ff 73 2c             	pushl  0x2c(%ebx)
 804c5af:	ff 73 20             	pushl  0x20(%ebx)
 804c5b2:	ff 73 1c             	pushl  0x1c(%ebx)
 804c5b5:	ff 73 18             	pushl  0x18(%ebx)
 804c5b8:	ff 73 14             	pushl  0x14(%ebx)
 804c5bb:	ff 73 10             	pushl  0x10(%ebx)
 804c5be:	ff 73 0c             	pushl  0xc(%ebx)
 804c5c1:	ff 73 08             	pushl  0x8(%ebx)
 804c5c4:	ff 73 04             	pushl  0x4(%ebx)
 804c5c7:	ff 33                	pushl  (%ebx)
 804c5c9:	e8 3f ff ff ff       	call   804c50d <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
 804c5ce:	8b 03                	mov    (%ebx),%eax
		z_setup_new_thread(
 804c5d0:	83 c4 30             	add    $0x30,%esp
		thread_data->init_thread->init_data = thread_data;
 804c5d3:	89 58 38             	mov    %ebx,0x38(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
 804c5d6:	83 c3 30             	add    $0x30,%ebx
 804c5d9:	eb c7                	jmp    804c5a2 <z_init_static_threads+0xe>
	k_sched_lock();
 804c5db:	e8 f3 01 00 00       	call   804c7d3 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
 804c5e0:	bb b0 1f 05 08       	mov    $0x8051fb0,%ebx
 804c5e5:	81 fb b0 1f 05 08    	cmp    $0x8051fb0,%ebx
 804c5eb:	73 55                	jae    804c642 <z_init_static_threads+0xae>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
 804c5ed:	8b 43 24             	mov    0x24(%ebx),%eax
 804c5f0:	83 f8 ff             	cmp    $0xffffffff,%eax
 804c5f3:	74 48                	je     804c63d <z_init_static_threads+0xa9>
					    K_MSEC(thread_data->init_delay));
 804c5f5:	85 c0                	test   %eax,%eax
 804c5f7:	ba 00 00 00 00       	mov    $0x0,%edx
			schedule_new_thread(thread_data->init_thread,
 804c5fc:	8b 33                	mov    (%ebx),%esi
					    K_MSEC(thread_data->init_delay));
 804c5fe:	0f 48 c2             	cmovs  %edx,%eax
 804c601:	99                   	cltd   
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
 804c602:	83 c0 09             	add    $0x9,%eax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 804c605:	89 c1                	mov    %eax,%ecx
 804c607:	83 d2 00             	adc    $0x0,%edx
 804c60a:	83 f1 09             	xor    $0x9,%ecx
 804c60d:	09 d1                	or     %edx,%ecx
 804c60f:	75 0b                	jne    804c61c <z_init_static_threads+0x88>
	z_sched_start(thread);
 804c611:	83 ec 0c             	sub    $0xc,%esp
 804c614:	56                   	push   %esi
 804c615:	e8 fa 03 00 00       	call   804ca14 <z_sched_start>
 804c61a:	eb 1e                	jmp    804c63a <z_init_static_threads+0xa6>
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
 804c61c:	6a 00                	push   $0x0

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 804c61e:	83 c6 18             	add    $0x18,%esi
 804c621:	6a 0a                	push   $0xa
 804c623:	52                   	push   %edx
 804c624:	50                   	push   %eax
 804c625:	e8 c6 cc ff ff       	call   80492f0 <__udivdi3@plt>
 804c62a:	83 c4 10             	add    $0x10,%esp
 804c62d:	52                   	push   %edx
 804c62e:	50                   	push   %eax
 804c62f:	68 60 ca 04 08       	push   $0x804ca60
 804c634:	56                   	push   %esi
 804c635:	e8 3d 06 00 00       	call   804cc77 <z_add_timeout>
 804c63a:	83 c4 10             	add    $0x10,%esp
	_FOREACH_STATIC_THREAD(thread_data) {
 804c63d:	83 c3 30             	add    $0x30,%ebx
 804c640:	eb a3                	jmp    804c5e5 <z_init_static_threads+0x51>
}
 804c642:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804c645:	5b                   	pop    %ebx
 804c646:	5e                   	pop    %esi
 804c647:	5d                   	pop    %ebp
	k_sched_unlock();
 804c648:	e9 4e 04 00 00       	jmp    804ca9b <k_sched_unlock>

0804c64d <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
 804c64d:	f3 0f 1e fb          	endbr32 
 804c651:	55                   	push   %ebp
 804c652:	89 e5                	mov    %esp,%ebp
 804c654:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
 804c657:	e8 0a ed ff ff       	call   804b366 <posix_irq_lock>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
 804c65c:	e8 f7 da ff ff       	call   804a158 <arch_cpu_idle>
 804c661:	eb f4                	jmp    804c657 <idle+0xa>

0804c663 <sys_dlist_remove>:
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
 804c663:	8b 48 04             	mov    0x4(%eax),%ecx
	sys_dnode_t *const next = node->next;
 804c666:	8b 10                	mov    (%eax),%edx

	prev->next = next;
 804c668:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
 804c66a:	89 4a 04             	mov    %ecx,0x4(%edx)
	node->next = NULL;
 804c66d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
 804c673:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	sys_dnode_init(node);
}
 804c67a:	c3                   	ret    

0804c67b <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
 804c67b:	55                   	push   %ebp
 804c67c:	89 e5                	mov    %esp,%ebp
 804c67e:	83 ec 08             	sub    $0x8,%esp

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
 804c681:	e8 dd ff ff ff       	call   804c663 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
 804c686:	80 60 0d fd          	andb   $0xfd,0xd(%eax)
	thread->base.pended_on = NULL;
 804c68a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
 804c691:	c9                   	leave  
 804c692:	c3                   	ret    

0804c693 <z_reset_time_slice>:
{
 804c693:	f3 0f 1e fb          	endbr32 
 804c697:	55                   	push   %ebp
 804c698:	89 e5                	mov    %esp,%ebp
 804c69a:	53                   	push   %ebx
 804c69b:	52                   	push   %edx
	int ret = slice_ticks;
 804c69c:	8b 1d 94 24 05 08    	mov    0x8052494,%ebx
	if (slice_time(curr) != 0) {
 804c6a2:	85 db                	test   %ebx,%ebx
 804c6a4:	74 1f                	je     804c6c5 <z_reset_time_slice+0x32>
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
 804c6a6:	e8 b5 fc ff ff       	call   804c360 <sys_clock_elapsed>
 804c6ab:	01 c3                	add    %eax,%ebx
		z_set_timeout_expiry(slice_time(curr), false);
 804c6ad:	50                   	push   %eax
 804c6ae:	50                   	push   %eax
 804c6af:	6a 00                	push   $0x0
 804c6b1:	ff 35 94 24 05 08    	pushl  0x8052494
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
 804c6b7:	89 1d 70 23 05 08    	mov    %ebx,0x8052370
		z_set_timeout_expiry(slice_time(curr), false);
 804c6bd:	e8 5f 07 00 00       	call   804ce21 <z_set_timeout_expiry>
 804c6c2:	83 c4 10             	add    $0x10,%esp
}
 804c6c5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804c6c8:	c9                   	leave  
 804c6c9:	c3                   	ret    

0804c6ca <k_sched_time_slice_set>:
{
 804c6ca:	f3 0f 1e fb          	endbr32 
 804c6ce:	55                   	push   %ebp
 804c6cf:	89 e5                	mov    %esp,%ebp
 804c6d1:	57                   	push   %edi
 804c6d2:	56                   	push   %esi
 804c6d3:	53                   	push   %ebx
 804c6d4:	83 ec 0c             	sub    $0xc,%esp
 804c6d7:	8b 75 08             	mov    0x8(%ebp),%esi
 804c6da:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804c6dd:	e8 84 ec ff ff       	call   804b366 <posix_irq_lock>
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
 804c6e2:	31 d2                	xor    %edx,%edx
		_current_cpu->slice_ticks = 0;
 804c6e4:	c7 05 70 23 05 08 00 	movl   $0x0,0x8052370
 804c6eb:	00 00 00 
 804c6ee:	89 c3                	mov    %eax,%ebx
 804c6f0:	89 f0                	mov    %esi,%eax
		t += off;
 804c6f2:	83 c0 09             	add    $0x9,%eax
 804c6f5:	83 d2 00             	adc    $0x0,%edx
		if (result32 && (t < BIT64(32))) {
 804c6f8:	83 fa 00             	cmp    $0x0,%edx
 804c6fb:	77 0e                	ja     804c70b <k_sched_time_slice_set+0x41>
			return ((uint32_t)t) / (from_hz / to_hz);
 804c6fd:	8d 46 09             	lea    0x9(%esi),%eax
 804c700:	b9 0a 00 00 00       	mov    $0xa,%ecx
 804c705:	31 d2                	xor    %edx,%edx
 804c707:	f7 f1                	div    %ecx
 804c709:	eb 0e                	jmp    804c719 <k_sched_time_slice_set+0x4f>
			return t / ((uint64_t)from_hz / to_hz);
 804c70b:	6a 00                	push   $0x0
 804c70d:	6a 0a                	push   $0xa
 804c70f:	52                   	push   %edx
 804c710:	50                   	push   %eax
 804c711:	e8 da cb ff ff       	call   80492f0 <__udivdi3@plt>
 804c716:	83 c4 10             	add    $0x10,%esp
		slice_ticks = k_ms_to_ticks_ceil32(slice);
 804c719:	89 c1                	mov    %eax,%ecx
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
 804c71b:	85 f6                	test   %esi,%esi
 804c71d:	7f 07                	jg     804c726 <k_sched_time_slice_set+0x5c>
		slice_ticks = k_ms_to_ticks_ceil32(slice);
 804c71f:	a3 94 24 05 08       	mov    %eax,0x8052494
 804c724:	eb 11                	jmp    804c737 <k_sched_time_slice_set+0x6d>
			slice_ticks = MAX(2, slice_ticks);
 804c726:	83 f8 02             	cmp    $0x2,%eax
 804c729:	b8 02 00 00 00       	mov    $0x2,%eax
 804c72e:	0f 4c c8             	cmovl  %eax,%ecx
 804c731:	89 0d 94 24 05 08    	mov    %ecx,0x8052494
		z_reset_time_slice(_current);
 804c737:	83 ec 0c             	sub    $0xc,%esp
 804c73a:	ff 35 68 23 05 08    	pushl  0x8052368
		slice_max_prio = prio;
 804c740:	89 3d 90 24 05 08    	mov    %edi,0x8052490
		z_reset_time_slice(_current);
 804c746:	e8 48 ff ff ff       	call   804c693 <z_reset_time_slice>
	posix_irq_unlock(key);
 804c74b:	89 5d 08             	mov    %ebx,0x8(%ebp)
 804c74e:	83 c4 10             	add    $0x10,%esp
}
 804c751:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c754:	5b                   	pop    %ebx
 804c755:	5e                   	pop    %esi
 804c756:	5f                   	pop    %edi
 804c757:	5d                   	pop    %ebp
 804c758:	e9 1f ec ff ff       	jmp    804b37c <posix_irq_unlock>

0804c75d <z_reschedule>:
{
 804c75d:	f3 0f 1e fb          	endbr32 
 804c761:	55                   	push   %ebp
 804c762:	89 e5                	mov    %esp,%ebp
 804c764:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (resched(key.key) && need_swap()) {
 804c767:	89 c2                	mov    %eax,%edx
 804c769:	0b 15 60 23 05 08    	or     0x8052360,%edx
 804c76f:	75 1b                	jne    804c78c <z_reschedule+0x2f>
 804c771:	8b 0d 68 23 05 08    	mov    0x8052368,%ecx
 804c777:	39 0d 78 23 05 08    	cmp    %ecx,0x8052378
 804c77d:	74 0d                	je     804c78c <z_reschedule+0x2f>
	ret = arch_swap(key);
 804c77f:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
 804c786:	5d                   	pop    %ebp
 804c787:	e9 76 de ff ff       	jmp    804a602 <arch_swap>
 804c78c:	89 45 08             	mov    %eax,0x8(%ebp)
 804c78f:	5d                   	pop    %ebp
 804c790:	e9 e7 eb ff ff       	jmp    804b37c <posix_irq_unlock>

0804c795 <z_reschedule_irqlock>:
{
 804c795:	f3 0f 1e fb          	endbr32 
 804c799:	55                   	push   %ebp
 804c79a:	89 e5                	mov    %esp,%ebp
	if (resched(key)) {
 804c79c:	8b 45 08             	mov    0x8(%ebp),%eax
 804c79f:	0b 05 60 23 05 08    	or     0x8052360,%eax
 804c7a5:	75 0d                	jne    804c7b4 <z_reschedule_irqlock+0x1f>
 804c7a7:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
 804c7ae:	5d                   	pop    %ebp
 804c7af:	e9 4e de ff ff       	jmp    804a602 <arch_swap>
 804c7b4:	5d                   	pop    %ebp
 804c7b5:	e9 c2 eb ff ff       	jmp    804b37c <posix_irq_unlock>

0804c7ba <z_reschedule_unlocked>:
{
 804c7ba:	55                   	push   %ebp
 804c7bb:	89 e5                	mov    %esp,%ebp
 804c7bd:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
 804c7c0:	e8 a1 eb ff ff       	call   804b366 <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
 804c7c5:	83 ec 0c             	sub    $0xc,%esp
 804c7c8:	50                   	push   %eax
 804c7c9:	e8 c7 ff ff ff       	call   804c795 <z_reschedule_irqlock>
 804c7ce:	83 c4 10             	add    $0x10,%esp
}
 804c7d1:	c9                   	leave  
 804c7d2:	c3                   	ret    

0804c7d3 <k_sched_lock>:
{
 804c7d3:	f3 0f 1e fb          	endbr32 
 804c7d7:	55                   	push   %ebp
 804c7d8:	89 e5                	mov    %esp,%ebp
 804c7da:	83 ec 08             	sub    $0x8,%esp
 804c7dd:	e8 84 eb ff ff       	call   804b366 <posix_irq_lock>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
 804c7e2:	8b 15 68 23 05 08    	mov    0x8052368,%edx
 804c7e8:	fe 4a 0f             	decb   0xf(%edx)
	posix_irq_unlock(key);
 804c7eb:	83 ec 0c             	sub    $0xc,%esp
 804c7ee:	50                   	push   %eax
 804c7ef:	e8 88 eb ff ff       	call   804b37c <posix_irq_unlock>
 804c7f4:	83 c4 10             	add    $0x10,%esp
}
 804c7f7:	c9                   	leave  
 804c7f8:	c3                   	ret    

0804c7f9 <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
 804c7f9:	f3 0f 1e fb          	endbr32 
 804c7fd:	55                   	push   %ebp
 804c7fe:	89 e5                	mov    %esp,%ebp
 804c800:	8b 55 08             	mov    0x8(%ebp),%edx
	return list->head == list;
 804c803:	8b 02                	mov    (%edx),%eax
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
 804c805:	85 c0                	test   %eax,%eax
 804c807:	74 04                	je     804c80d <z_priq_dumb_best+0x14>
 804c809:	39 c2                	cmp    %eax,%edx
 804c80b:	75 02                	jne    804c80f <z_priq_dumb_best+0x16>
	struct k_thread *thread = NULL;
 804c80d:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
 804c80f:	5d                   	pop    %ebp
 804c810:	c3                   	ret    

0804c811 <update_cache>:
{
 804c811:	55                   	push   %ebp
 804c812:	89 c1                	mov    %eax,%ecx
 804c814:	89 e5                	mov    %esp,%ebp
 804c816:	53                   	push   %ebx
 804c817:	83 ec 10             	sub    $0x10,%esp
	return _priq_run_best(curr_cpu_runq());
 804c81a:	68 7c 23 05 08       	push   $0x805237c
 804c81f:	e8 d5 ff ff ff       	call   804c7f9 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 804c824:	8b 1d 6c 23 05 08    	mov    0x805236c,%ebx
	return _priq_run_best(curr_cpu_runq());
 804c82a:	83 c4 10             	add    $0x10,%esp
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 804c82d:	85 c0                	test   %eax,%eax
 804c82f:	74 02                	je     804c833 <update_cache+0x22>
 804c831:	89 c3                	mov    %eax,%ebx
	if (preempt_ok != 0) {
 804c833:	a1 68 23 05 08       	mov    0x8052368,%eax
 804c838:	85 c9                	test   %ecx,%ecx
 804c83a:	75 14                	jne    804c850 <update_cache+0x3f>
	if (z_is_thread_prevented_from_running(_current)) {
 804c83c:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
 804c840:	75 0e                	jne    804c850 <update_cache+0x3f>
	if (is_preempt(_current) || is_metairq(thread)) {
 804c842:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
 804c847:	76 07                	jbe    804c850 <update_cache+0x3f>
		_kernel.ready_q.cache = _current;
 804c849:	a3 78 23 05 08       	mov    %eax,0x8052378
 804c84e:	eb 16                	jmp    804c866 <update_cache+0x55>
		if (thread != _current) {
 804c850:	39 c3                	cmp    %eax,%ebx
 804c852:	74 0c                	je     804c860 <update_cache+0x4f>
			z_reset_time_slice(thread);
 804c854:	83 ec 0c             	sub    $0xc,%esp
 804c857:	53                   	push   %ebx
 804c858:	e8 36 fe ff ff       	call   804c693 <z_reset_time_slice>
 804c85d:	83 c4 10             	add    $0x10,%esp
		_kernel.ready_q.cache = thread;
 804c860:	89 1d 78 23 05 08    	mov    %ebx,0x8052378
}
 804c866:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804c869:	c9                   	leave  
 804c86a:	c3                   	ret    

0804c86b <move_thread_to_end_of_prio_q>:
{
 804c86b:	55                   	push   %ebp
 804c86c:	89 e5                	mov    %esp,%ebp
 804c86e:	56                   	push   %esi
 804c86f:	53                   	push   %ebx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 804c870:	8a 50 0d             	mov    0xd(%eax),%dl
	if (z_is_thread_queued(thread)) {
 804c873:	84 d2                	test   %dl,%dl
 804c875:	79 0b                	jns    804c882 <move_thread_to_end_of_prio_q+0x17>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804c877:	83 e2 7f             	and    $0x7f,%edx
 804c87a:	88 50 0d             	mov    %dl,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804c87d:	e8 e1 fd ff ff       	call   804c663 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
 804c882:	80 48 0d 80          	orb    $0x80,0xd(%eax)
 804c886:	8b 15 7c 23 05 08    	mov    0x805237c,%edx
 804c88c:	8b 1d 80 23 05 08    	mov    0x8052380,%ebx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804c892:	85 d2                	test   %edx,%edx
 804c894:	74 33                	je     804c8c9 <move_thread_to_end_of_prio_q+0x5e>
 804c896:	81 fa 7c 23 05 08    	cmp    $0x805237c,%edx
 804c89c:	74 2b                	je     804c8c9 <move_thread_to_end_of_prio_q+0x5e>
	int32_t b1 = thread_1->base.prio;
 804c89e:	0f be 70 0e          	movsbl 0xe(%eax),%esi
	int32_t b2 = thread_2->base.prio;
 804c8a2:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
	if (b1 != b2) {
 804c8a6:	39 ce                	cmp    %ecx,%esi
 804c8a8:	74 15                	je     804c8bf <move_thread_to_end_of_prio_q+0x54>
		return b2 - b1;
 804c8aa:	29 f1                	sub    %esi,%ecx
		if (z_sched_prio_cmp(thread, t) > 0) {
 804c8ac:	85 c9                	test   %ecx,%ecx
 804c8ae:	7e 0f                	jle    804c8bf <move_thread_to_end_of_prio_q+0x54>
	sys_dnode_t *const prev = successor->prev;
 804c8b0:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
 804c8b3:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
 804c8b5:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
 804c8b8:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
 804c8ba:	89 42 04             	mov    %eax,0x4(%edx)
}
 804c8bd:	eb 1a                	jmp    804c8d9 <move_thread_to_end_of_prio_q+0x6e>
	return (node == list->tail) ? NULL : node->next;
 804c8bf:	39 da                	cmp    %ebx,%edx
 804c8c1:	74 06                	je     804c8c9 <move_thread_to_end_of_prio_q+0x5e>
 804c8c3:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804c8c5:	85 d2                	test   %edx,%edx
 804c8c7:	75 d9                	jne    804c8a2 <move_thread_to_end_of_prio_q+0x37>
	node->next = list;
 804c8c9:	c7 00 7c 23 05 08    	movl   $0x805237c,(%eax)
	node->prev = tail;
 804c8cf:	89 58 04             	mov    %ebx,0x4(%eax)
	tail->next = node;
 804c8d2:	89 03                	mov    %eax,(%ebx)
	list->tail = node;
 804c8d4:	a3 80 23 05 08       	mov    %eax,0x8052380
	update_cache(thread == _current);
 804c8d9:	39 05 68 23 05 08    	cmp    %eax,0x8052368
}
 804c8df:	5b                   	pop    %ebx
	update_cache(thread == _current);
 804c8e0:	0f 94 c0             	sete   %al
}
 804c8e3:	5e                   	pop    %esi
 804c8e4:	5d                   	pop    %ebp
	update_cache(thread == _current);
 804c8e5:	0f b6 c0             	movzbl %al,%eax
 804c8e8:	e9 24 ff ff ff       	jmp    804c811 <update_cache>

0804c8ed <z_time_slice>:
{
 804c8ed:	f3 0f 1e fb          	endbr32 
 804c8f1:	55                   	push   %ebp
 804c8f2:	89 e5                	mov    %esp,%ebp
 804c8f4:	57                   	push   %edi
 804c8f5:	56                   	push   %esi
 804c8f6:	53                   	push   %ebx
 804c8f7:	83 ec 0c             	sub    $0xc,%esp
 804c8fa:	8b 7d 08             	mov    0x8(%ebp),%edi
	return posix_irq_lock();
 804c8fd:	e8 64 ea ff ff       	call   804b366 <posix_irq_lock>
	if (slice_time(_current) && sliceable(_current)) {
 804c902:	83 3d 94 24 05 08 00 	cmpl   $0x0,0x8052494
 804c909:	89 c6                	mov    %eax,%esi
 804c90b:	74 4e                	je     804c95b <z_time_slice+0x6e>
 804c90d:	8b 1d 68 23 05 08    	mov    0x8052368,%ebx
		&& !z_is_idle_thread_object(thread);
 804c913:	66 83 7b 0e 7f       	cmpw   $0x7f,0xe(%ebx)
 804c918:	77 41                	ja     804c95b <z_time_slice+0x6e>
		&& !z_is_thread_prevented_from_running(thread)
 804c91a:	f6 43 0d 1f          	testb  $0x1f,0xd(%ebx)
 804c91e:	75 3b                	jne    804c95b <z_time_slice+0x6e>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 804c920:	0f be 43 0e          	movsbl 0xe(%ebx),%eax
	if (slice_time(_current) && sliceable(_current)) {
 804c924:	39 05 90 24 05 08    	cmp    %eax,0x8052490
 804c92a:	7f 2f                	jg     804c95b <z_time_slice+0x6e>
 804c92c:	81 fb a0 22 05 08    	cmp    $0x80522a0,%ebx
 804c932:	74 27                	je     804c95b <z_time_slice+0x6e>
		if (ticks >= _current_cpu->slice_ticks) {
 804c934:	a1 70 23 05 08       	mov    0x8052370,%eax
 804c939:	39 f8                	cmp    %edi,%eax
 804c93b:	7f 15                	jg     804c952 <z_time_slice+0x65>
		move_thread_to_end_of_prio_q(curr);
 804c93d:	89 d8                	mov    %ebx,%eax
 804c93f:	e8 27 ff ff ff       	call   804c86b <move_thread_to_end_of_prio_q>
	z_reset_time_slice(curr);
 804c944:	83 ec 0c             	sub    $0xc,%esp
 804c947:	53                   	push   %ebx
 804c948:	e8 46 fd ff ff       	call   804c693 <z_reset_time_slice>
 804c94d:	83 c4 10             	add    $0x10,%esp
	return sched_lock_key;
 804c950:	eb 13                	jmp    804c965 <z_time_slice+0x78>
			_current_cpu->slice_ticks -= ticks;
 804c952:	29 f8                	sub    %edi,%eax
 804c954:	a3 70 23 05 08       	mov    %eax,0x8052370
 804c959:	eb 0a                	jmp    804c965 <z_time_slice+0x78>
		_current_cpu->slice_ticks = 0;
 804c95b:	c7 05 70 23 05 08 00 	movl   $0x0,0x8052370
 804c962:	00 00 00 
	posix_irq_unlock(key);
 804c965:	89 75 08             	mov    %esi,0x8(%ebp)
}
 804c968:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c96b:	5b                   	pop    %ebx
 804c96c:	5e                   	pop    %esi
 804c96d:	5f                   	pop    %edi
 804c96e:	5d                   	pop    %ebp
 804c96f:	e9 08 ea ff ff       	jmp    804b37c <posix_irq_unlock>

0804c974 <ready_thread>:
 804c974:	8a 50 0d             	mov    0xd(%eax),%dl
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 804c977:	84 d2                	test   %dl,%dl
 804c979:	78 73                	js     804c9ee <ready_thread+0x7a>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 804c97b:	f6 c2 1f             	test   $0x1f,%dl
 804c97e:	75 6e                	jne    804c9ee <ready_thread+0x7a>
 804c980:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
 804c984:	75 68                	jne    804c9ee <ready_thread+0x7a>
{
 804c986:	55                   	push   %ebp
	thread->base.thread_state |= _THREAD_QUEUED;
 804c987:	83 ca 80             	or     $0xffffff80,%edx
{
 804c98a:	89 e5                	mov    %esp,%ebp
 804c98c:	56                   	push   %esi
 804c98d:	53                   	push   %ebx
	thread->base.thread_state |= _THREAD_QUEUED;
 804c98e:	88 50 0d             	mov    %dl,0xd(%eax)
	return list->head == list;
 804c991:	8b 15 7c 23 05 08    	mov    0x805237c,%edx
 804c997:	8b 1d 80 23 05 08    	mov    0x8052380,%ebx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804c99d:	85 d2                	test   %edx,%edx
 804c99f:	74 33                	je     804c9d4 <ready_thread+0x60>
 804c9a1:	81 fa 7c 23 05 08    	cmp    $0x805237c,%edx
 804c9a7:	74 2b                	je     804c9d4 <ready_thread+0x60>
	int32_t b1 = thread_1->base.prio;
 804c9a9:	0f be 70 0e          	movsbl 0xe(%eax),%esi
	int32_t b2 = thread_2->base.prio;
 804c9ad:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
	if (b1 != b2) {
 804c9b1:	39 ce                	cmp    %ecx,%esi
 804c9b3:	74 15                	je     804c9ca <ready_thread+0x56>
		return b2 - b1;
 804c9b5:	29 f1                	sub    %esi,%ecx
		if (z_sched_prio_cmp(thread, t) > 0) {
 804c9b7:	85 c9                	test   %ecx,%ecx
 804c9b9:	7e 0f                	jle    804c9ca <ready_thread+0x56>
	sys_dnode_t *const prev = successor->prev;
 804c9bb:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
 804c9be:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
 804c9c0:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
 804c9c3:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
 804c9c5:	89 42 04             	mov    %eax,0x4(%edx)
}
 804c9c8:	eb 1a                	jmp    804c9e4 <ready_thread+0x70>
	return (node == list->tail) ? NULL : node->next;
 804c9ca:	39 d3                	cmp    %edx,%ebx
 804c9cc:	74 06                	je     804c9d4 <ready_thread+0x60>
 804c9ce:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804c9d0:	85 d2                	test   %edx,%edx
 804c9d2:	75 d9                	jne    804c9ad <ready_thread+0x39>
	node->next = list;
 804c9d4:	c7 00 7c 23 05 08    	movl   $0x805237c,(%eax)
	node->prev = tail;
 804c9da:	89 58 04             	mov    %ebx,0x4(%eax)
	tail->next = node;
 804c9dd:	89 03                	mov    %eax,(%ebx)
	list->tail = node;
 804c9df:	a3 80 23 05 08       	mov    %eax,0x8052380
}
 804c9e4:	5b                   	pop    %ebx
		update_cache(0);
 804c9e5:	31 c0                	xor    %eax,%eax
}
 804c9e7:	5e                   	pop    %esi
 804c9e8:	5d                   	pop    %ebp
		update_cache(0);
 804c9e9:	e9 23 fe ff ff       	jmp    804c811 <update_cache>
 804c9ee:	c3                   	ret    

0804c9ef <z_ready_thread>:
{
 804c9ef:	f3 0f 1e fb          	endbr32 
 804c9f3:	55                   	push   %ebp
 804c9f4:	89 e5                	mov    %esp,%ebp
 804c9f6:	56                   	push   %esi
 804c9f7:	53                   	push   %ebx
 804c9f8:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
 804c9fb:	e8 66 e9 ff ff       	call   804b366 <posix_irq_lock>
 804ca00:	89 c3                	mov    %eax,%ebx
			ready_thread(thread);
 804ca02:	89 f0                	mov    %esi,%eax
 804ca04:	e8 6b ff ff ff       	call   804c974 <ready_thread>
	posix_irq_unlock(key);
 804ca09:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 804ca0c:	5b                   	pop    %ebx
 804ca0d:	5e                   	pop    %esi
 804ca0e:	5d                   	pop    %ebp
 804ca0f:	e9 68 e9 ff ff       	jmp    804b37c <posix_irq_unlock>

0804ca14 <z_sched_start>:
{
 804ca14:	f3 0f 1e fb          	endbr32 
 804ca18:	55                   	push   %ebp
 804ca19:	89 e5                	mov    %esp,%ebp
 804ca1b:	56                   	push   %esi
 804ca1c:	53                   	push   %ebx
 804ca1d:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
 804ca20:	e8 41 e9 ff ff       	call   804b366 <posix_irq_lock>
 804ca25:	89 c3                	mov    %eax,%ebx
	if (z_has_thread_started(thread)) {
 804ca27:	8a 46 0d             	mov    0xd(%esi),%al
 804ca2a:	a8 04                	test   $0x4,%al
 804ca2c:	75 0e                	jne    804ca3c <z_sched_start+0x28>
	posix_irq_unlock(key);
 804ca2e:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 804ca31:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804ca34:	5b                   	pop    %ebx
 804ca35:	5e                   	pop    %esi
 804ca36:	5d                   	pop    %ebp
 804ca37:	e9 40 e9 ff ff       	jmp    804b37c <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
 804ca3c:	83 e0 fb             	and    $0xfffffffb,%eax
 804ca3f:	88 46 0d             	mov    %al,0xd(%esi)
	ready_thread(thread);
 804ca42:	89 f0                	mov    %esi,%eax
 804ca44:	e8 2b ff ff ff       	call   804c974 <ready_thread>
	z_reschedule(&sched_spinlock, key);
 804ca49:	50                   	push   %eax
 804ca4a:	50                   	push   %eax
 804ca4b:	53                   	push   %ebx
 804ca4c:	68 a4 24 05 08       	push   $0x80524a4
 804ca51:	e8 07 fd ff ff       	call   804c75d <z_reschedule>
 804ca56:	83 c4 10             	add    $0x10,%esp
}
 804ca59:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804ca5c:	5b                   	pop    %ebx
 804ca5d:	5e                   	pop    %esi
 804ca5e:	5d                   	pop    %ebp
 804ca5f:	c3                   	ret    

0804ca60 <z_thread_timeout>:
{
 804ca60:	f3 0f 1e fb          	endbr32 
 804ca64:	55                   	push   %ebp
 804ca65:	89 e5                	mov    %esp,%ebp
 804ca67:	56                   	push   %esi
 804ca68:	53                   	push   %ebx
 804ca69:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
 804ca6c:	e8 f5 e8 ff ff       	call   804b366 <posix_irq_lock>
 804ca71:	89 c6                	mov    %eax,%esi
		if (!killed) {
 804ca73:	f6 43 f5 28          	testb  $0x28,-0xb(%ebx)
 804ca77:	75 17                	jne    804ca90 <z_thread_timeout+0x30>
			if (thread->base.pended_on != NULL) {
 804ca79:	83 7b f0 00          	cmpl   $0x0,-0x10(%ebx)
	struct k_thread *thread = CONTAINER_OF(timeout,
 804ca7d:	8d 43 e8             	lea    -0x18(%ebx),%eax
			if (thread->base.pended_on != NULL) {
 804ca80:	74 05                	je     804ca87 <z_thread_timeout+0x27>
				unpend_thread_no_timeout(thread);
 804ca82:	e8 f4 fb ff ff       	call   804c67b <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 804ca87:	80 63 f5 eb          	andb   $0xeb,-0xb(%ebx)
			ready_thread(thread);
 804ca8b:	e8 e4 fe ff ff       	call   804c974 <ready_thread>
	posix_irq_unlock(key);
 804ca90:	89 75 08             	mov    %esi,0x8(%ebp)
}
 804ca93:	5b                   	pop    %ebx
 804ca94:	5e                   	pop    %esi
 804ca95:	5d                   	pop    %ebp
 804ca96:	e9 e1 e8 ff ff       	jmp    804b37c <posix_irq_unlock>

0804ca9b <k_sched_unlock>:
{
 804ca9b:	f3 0f 1e fb          	endbr32 
 804ca9f:	55                   	push   %ebp
 804caa0:	89 e5                	mov    %esp,%ebp
 804caa2:	53                   	push   %ebx
 804caa3:	50                   	push   %eax
	return posix_irq_lock();
 804caa4:	e8 bd e8 ff ff       	call   804b366 <posix_irq_lock>
 804caa9:	89 c3                	mov    %eax,%ebx
		++_current->base.sched_locked;
 804caab:	a1 68 23 05 08       	mov    0x8052368,%eax
 804cab0:	fe 40 0f             	incb   0xf(%eax)
		update_cache(0);
 804cab3:	31 c0                	xor    %eax,%eax
 804cab5:	e8 57 fd ff ff       	call   804c811 <update_cache>
	posix_irq_unlock(key);
 804caba:	83 ec 0c             	sub    $0xc,%esp
 804cabd:	53                   	push   %ebx
 804cabe:	e8 b9 e8 ff ff       	call   804b37c <posix_irq_unlock>
}
 804cac3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804cac6:	83 c4 10             	add    $0x10,%esp
 804cac9:	c9                   	leave  
	z_reschedule_unlocked();
 804caca:	e9 eb fc ff ff       	jmp    804c7ba <z_reschedule_unlocked>

0804cacf <z_sched_init>:
	sys_dlist_init(&rq->runq);
#endif
}

void z_sched_init(void)
{
 804cacf:	f3 0f 1e fb          	endbr32 
 804cad3:	55                   	push   %ebp
 804cad4:	89 e5                	mov    %esp,%ebp
 804cad6:	83 ec 10             	sub    $0x10,%esp
	list->head = (sys_dnode_t *)list;
 804cad9:	c7 05 7c 23 05 08 7c 	movl   $0x805237c,0x805237c
 804cae0:	23 05 08 
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
 804cae3:	6a 00                	push   $0x0
 804cae5:	6a 00                	push   $0x0
	list->tail = (sys_dnode_t *)list;
 804cae7:	c7 05 80 23 05 08 7c 	movl   $0x805237c,0x8052380
 804caee:	23 05 08 
 804caf1:	e8 d4 fb ff ff       	call   804c6ca <k_sched_time_slice_set>
 804caf6:	83 c4 10             	add    $0x10,%esp
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
 804caf9:	c9                   	leave  
 804cafa:	c3                   	ret    

0804cafb <z_impl_z_current_get>:
}
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_z_current_get(void)
{
 804cafb:	f3 0f 1e fb          	endbr32 

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
 804caff:	a1 68 23 05 08       	mov    0x8052368,%eax
 804cb04:	c3                   	ret    

0804cb05 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
 804cb05:	f3 0f 1e fb          	endbr32 
 804cb09:	55                   	push   %ebp
 804cb0a:	89 e5                	mov    %esp,%ebp
 804cb0c:	57                   	push   %edi
 804cb0d:	56                   	push   %esi
 804cb0e:	53                   	push   %ebx
 804cb0f:	83 ec 0c             	sub    $0xc,%esp
 804cb12:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
 804cb15:	e8 4c e8 ff ff       	call   804b366 <posix_irq_lock>
 804cb1a:	89 c6                	mov    %eax,%esi
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 804cb1c:	8a 43 0d             	mov    0xd(%ebx),%al
 804cb1f:	a8 08                	test   $0x8,%al
 804cb21:	0f 85 96 00 00 00    	jne    804cbbd <z_thread_abort+0xb8>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 804cb27:	89 c2                	mov    %eax,%edx
 804cb29:	83 e2 df             	and    $0xffffffdf,%edx
		if (z_is_thread_queued(thread)) {
 804cb2c:	80 ca 08             	or     $0x8,%dl
 804cb2f:	78 05                	js     804cb36 <z_thread_abort+0x31>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 804cb31:	88 53 0d             	mov    %dl,0xd(%ebx)
 804cb34:	eb 10                	jmp    804cb46 <z_thread_abort+0x41>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804cb36:	83 e0 5f             	and    $0x5f,%eax
 804cb39:	83 c8 08             	or     $0x8,%eax
 804cb3c:	88 43 0d             	mov    %al,0xd(%ebx)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804cb3f:	89 d8                	mov    %ebx,%eax
 804cb41:	e8 1d fb ff ff       	call   804c663 <sys_dlist_remove>
		if (thread->base.pended_on != NULL) {
 804cb46:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
 804cb4a:	74 07                	je     804cb53 <z_thread_abort+0x4e>
			unpend_thread_no_timeout(thread);
 804cb4c:	89 d8                	mov    %ebx,%eax
 804cb4e:	e8 28 fb ff ff       	call   804c67b <unpend_thread_no_timeout>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
 804cb53:	83 ec 0c             	sub    $0xc,%esp
 804cb56:	8d 43 18             	lea    0x18(%ebx),%eax
 804cb59:	50                   	push   %eax
 804cb5a:	e8 83 02 00 00       	call   804cde2 <z_abort_timeout>
 804cb5f:	83 c4 10             	add    $0x10,%esp
	return list->head == list;
 804cb62:	8b 7b 3c             	mov    0x3c(%ebx),%edi
	while ((thread = z_waitq_head(wait_q)) != NULL) {
 804cb65:	85 ff                	test   %edi,%edi
 804cb67:	74 2d                	je     804cb96 <z_thread_abort+0x91>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 804cb69:	8d 43 3c             	lea    0x3c(%ebx),%eax
 804cb6c:	39 c7                	cmp    %eax,%edi
 804cb6e:	74 26                	je     804cb96 <z_thread_abort+0x91>
		unpend_thread_no_timeout(thread);
 804cb70:	89 f8                	mov    %edi,%eax
 804cb72:	e8 04 fb ff ff       	call   804c67b <unpend_thread_no_timeout>
 804cb77:	83 ec 0c             	sub    $0xc,%esp
 804cb7a:	8d 47 18             	lea    0x18(%edi),%eax
 804cb7d:	50                   	push   %eax
 804cb7e:	e8 5f 02 00 00       	call   804cde2 <z_abort_timeout>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->callee_saved.retval = value;
 804cb83:	c7 47 30 00 00 00 00 	movl   $0x0,0x30(%edi)
 804cb8a:	83 c4 10             	add    $0x10,%esp
		ready_thread(thread);
 804cb8d:	89 f8                	mov    %edi,%eax
 804cb8f:	e8 e0 fd ff ff       	call   804c974 <ready_thread>
 804cb94:	eb cc                	jmp    804cb62 <z_thread_abort+0x5d>
		update_cache(1);
 804cb96:	b8 01 00 00 00       	mov    $0x1,%eax
 804cb9b:	e8 71 fc ff ff       	call   804c811 <update_cache>
		}
		return; /* lock has been released */
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
 804cba0:	39 1d 68 23 05 08    	cmp    %ebx,0x8052368
 804cba6:	75 15                	jne    804cbbd <z_thread_abort+0xb8>
 804cba8:	83 3d 60 23 05 08 00 	cmpl   $0x0,0x8052360
 804cbaf:	75 0c                	jne    804cbbd <z_thread_abort+0xb8>
 804cbb1:	83 ec 0c             	sub    $0xc,%esp
 804cbb4:	56                   	push   %esi
 804cbb5:	e8 48 da ff ff       	call   804a602 <arch_swap>
 804cbba:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804cbbd:	89 75 08             	mov    %esi,0x8(%ebp)
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
 804cbc0:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804cbc3:	5b                   	pop    %ebx
 804cbc4:	5e                   	pop    %esi
 804cbc5:	5f                   	pop    %edi
 804cbc6:	5d                   	pop    %ebp
 804cbc7:	e9 b0 e7 ff ff       	jmp    804b37c <posix_irq_unlock>

0804cbcc <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 804cbcc:	83 3d 98 24 05 08 00 	cmpl   $0x0,0x8052498
 804cbd3:	75 05                	jne    804cbda <elapsed+0xe>
 804cbd5:	e9 86 f7 ff ff       	jmp    804c360 <sys_clock_elapsed>
}
 804cbda:	31 c0                	xor    %eax,%eax
 804cbdc:	c3                   	ret    

0804cbdd <remove_timeout>:
{
 804cbdd:	55                   	push   %ebp
 804cbde:	8b 10                	mov    (%eax),%edx
 804cbe0:	89 e5                	mov    %esp,%ebp
 804cbe2:	53                   	push   %ebx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 804cbe3:	85 c0                	test   %eax,%eax
 804cbe5:	74 18                	je     804cbff <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
 804cbe7:	3b 05 8c 12 05 08    	cmp    0x805128c,%eax
 804cbed:	74 10                	je     804cbff <remove_timeout+0x22>
	if (next(t) != NULL) {
 804cbef:	85 d2                	test   %edx,%edx
 804cbf1:	74 0c                	je     804cbff <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
 804cbf3:	8b 48 0c             	mov    0xc(%eax),%ecx
 804cbf6:	8b 58 10             	mov    0x10(%eax),%ebx
 804cbf9:	01 4a 0c             	add    %ecx,0xc(%edx)
 804cbfc:	11 5a 10             	adc    %ebx,0x10(%edx)
	sys_dnode_t *const prev = node->prev;
 804cbff:	8b 48 04             	mov    0x4(%eax),%ecx
	prev->next = next;
 804cc02:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
 804cc04:	89 4a 04             	mov    %ecx,0x4(%edx)
}
 804cc07:	5b                   	pop    %ebx
	node->next = NULL;
 804cc08:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 804cc0e:	5d                   	pop    %ebp
	node->prev = NULL;
 804cc0f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 804cc16:	c3                   	ret    

0804cc17 <next_timeout>:

static int32_t next_timeout(void)
{
 804cc17:	55                   	push   %ebp
 804cc18:	89 e5                	mov    %esp,%ebp
 804cc1a:	53                   	push   %ebx
 804cc1b:	51                   	push   %ecx
	return list->head == list;
 804cc1c:	8b 1d 88 12 05 08    	mov    0x8051288,%ebx
	return sys_dlist_is_empty(list) ? NULL : list->head;
 804cc22:	81 fb 88 12 05 08    	cmp    $0x8051288,%ebx
 804cc28:	75 02                	jne    804cc2c <next_timeout+0x15>
 804cc2a:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
 804cc2c:	e8 9b ff ff ff       	call   804cbcc <elapsed>
 804cc31:	89 c2                	mov    %eax,%edx
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
 804cc33:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	if ((to == NULL) ||
 804cc38:	85 db                	test   %ebx,%ebx
 804cc3a:	74 28                	je     804cc64 <next_timeout+0x4d>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 804cc3c:	8b 4b 0c             	mov    0xc(%ebx),%ecx
 804cc3f:	89 d0                	mov    %edx,%eax
 804cc41:	8b 5b 10             	mov    0x10(%ebx),%ebx
 804cc44:	99                   	cltd   
 804cc45:	29 c1                	sub    %eax,%ecx
	if ((to == NULL) ||
 804cc47:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 804cc4c:	19 d3                	sbb    %edx,%ebx
	if ((to == NULL) ||
 804cc4e:	31 d2                	xor    %edx,%edx
 804cc50:	39 c8                	cmp    %ecx,%eax
 804cc52:	89 d0                	mov    %edx,%eax
 804cc54:	19 d8                	sbb    %ebx,%eax
		ret = MAX_WAIT;
 804cc56:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	if ((to == NULL) ||
 804cc5b:	7c 07                	jl     804cc64 <next_timeout+0x4d>
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
 804cc5d:	89 c8                	mov    %ecx,%eax
 804cc5f:	85 db                	test   %ebx,%ebx
 804cc61:	0f 48 c2             	cmovs  %edx,%eax
	}

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
 804cc64:	8b 15 70 23 05 08    	mov    0x8052370,%edx
 804cc6a:	85 d2                	test   %edx,%edx
 804cc6c:	74 05                	je     804cc73 <next_timeout+0x5c>
 804cc6e:	39 d0                	cmp    %edx,%eax
 804cc70:	0f 4f c2             	cmovg  %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
 804cc73:	5a                   	pop    %edx
 804cc74:	5b                   	pop    %ebx
 804cc75:	5d                   	pop    %ebp
 804cc76:	c3                   	ret    

0804cc77 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
 804cc77:	f3 0f 1e fb          	endbr32 
 804cc7b:	55                   	push   %ebp
 804cc7c:	89 e5                	mov    %esp,%ebp
 804cc7e:	57                   	push   %edi
 804cc7f:	56                   	push   %esi
 804cc80:	53                   	push   %ebx
 804cc81:	83 ec 1c             	sub    $0x1c,%esp
 804cc84:	8b 4d 14             	mov    0x14(%ebp),%ecx
 804cc87:	8b 55 10             	mov    0x10(%ebp),%edx
 804cc8a:	8b 75 08             	mov    0x8(%ebp),%esi
 804cc8d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cc90:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804cc93:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
{
 804cc97:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804cc9a:	75 0a                	jne    804cca6 <z_add_timeout+0x2f>
 804cc9c:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
 804cca0:	0f 84 34 01 00 00    	je     804cdda <z_add_timeout+0x163>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
 804cca6:	89 46 08             	mov    %eax,0x8(%esi)
	return posix_irq_lock();
 804cca9:	e8 b8 e6 ff ff       	call   804b366 <posix_irq_lock>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
 804ccae:	83 ca ff             	or     $0xffffffff,%edx
 804ccb1:	89 c7                	mov    %eax,%edi
 804ccb3:	89 d3                	mov    %edx,%ebx
 804ccb5:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 804ccba:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804ccbd:	1b 5d e4             	sbb    -0x1c(%ebp),%ebx
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 804ccc0:	85 db                	test   %ebx,%ebx
 804ccc2:	78 2d                	js     804ccf1 <z_add_timeout+0x7a>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 804ccc4:	2b 05 20 24 05 08    	sub    0x8052420,%eax
 804ccca:	1b 15 24 24 05 08    	sbb    0x8052424,%edx
 804ccd0:	2b 45 e0             	sub    -0x20(%ebp),%eax
 804ccd3:	1b 55 e4             	sbb    -0x1c(%ebp),%edx

			to->dticks = MAX(1, ticks);
 804ccd6:	31 c9                	xor    %ecx,%ecx
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 804ccd8:	89 56 10             	mov    %edx,0x10(%esi)
			to->dticks = MAX(1, ticks);
 804ccdb:	8b 56 10             	mov    0x10(%esi),%edx
 804ccde:	39 c1                	cmp    %eax,%ecx
 804cce0:	89 cb                	mov    %ecx,%ebx
 804cce2:	19 d3                	sbb    %edx,%ebx
 804cce4:	bb 01 00 00 00       	mov    $0x1,%ebx
 804cce9:	0f 4d c3             	cmovge %ebx,%eax
 804ccec:	0f 4d d1             	cmovge %ecx,%edx
 804ccef:	eb 1c                	jmp    804cd0d <z_add_timeout+0x96>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
 804ccf1:	e8 d6 fe ff ff       	call   804cbcc <elapsed>
 804ccf6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ccf9:	89 c1                	mov    %eax,%ecx
 804ccfb:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804ccfe:	89 cb                	mov    %ecx,%ebx
 804cd00:	83 c0 01             	add    $0x1,%eax
 804cd03:	83 d2 00             	adc    $0x0,%edx
 804cd06:	c1 fb 1f             	sar    $0x1f,%ebx
 804cd09:	01 c8                	add    %ecx,%eax
 804cd0b:	11 da                	adc    %ebx,%edx
 804cd0d:	89 46 0c             	mov    %eax,0xc(%esi)
	return list->head == list;
 804cd10:	a1 88 12 05 08       	mov    0x8051288,%eax
 804cd15:	89 56 10             	mov    %edx,0x10(%esi)
 804cd18:	8b 15 8c 12 05 08    	mov    0x805128c,%edx
 804cd1e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
 804cd21:	3d 88 12 05 08       	cmp    $0x8051288,%eax
 804cd26:	74 64                	je     804cd8c <z_add_timeout+0x115>
		}

		for (t = first(); t != NULL; t = next(t)) {
 804cd28:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 804cd2c:	74 5e                	je     804cd8c <z_add_timeout+0x115>
			if (t->dticks > to->dticks) {
 804cd2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804cd31:	8b 58 10             	mov    0x10(%eax),%ebx
 804cd34:	8b 48 0c             	mov    0xc(%eax),%ecx
 804cd37:	89 5d dc             	mov    %ebx,-0x24(%ebp)
 804cd3a:	8b 5e 10             	mov    0x10(%esi),%ebx
 804cd3d:	89 4d d8             	mov    %ecx,-0x28(%ebp)
 804cd40:	8b 4e 0c             	mov    0xc(%esi),%ecx
 804cd43:	89 d8                	mov    %ebx,%eax
 804cd45:	3b 4d d8             	cmp    -0x28(%ebp),%ecx
 804cd48:	1b 45 dc             	sbb    -0x24(%ebp),%eax
 804cd4b:	7d 24                	jge    804cd71 <z_add_timeout+0xfa>
				t->dticks -= to->dticks;
 804cd4d:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804cd50:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804cd53:	29 c8                	sub    %ecx,%eax
 804cd55:	89 c1                	mov    %eax,%ecx
 804cd57:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804cd5a:	19 da                	sbb    %ebx,%edx
 804cd5c:	89 50 10             	mov    %edx,0x10(%eax)
	sys_dnode_t *const prev = successor->prev;
 804cd5f:	8b 50 04             	mov    0x4(%eax),%edx
 804cd62:	89 48 0c             	mov    %ecx,0xc(%eax)
	node->prev = prev;
 804cd65:	89 56 04             	mov    %edx,0x4(%esi)
	node->next = successor;
 804cd68:	89 06                	mov    %eax,(%esi)
	prev->next = node;
 804cd6a:	89 32                	mov    %esi,(%edx)
	successor->prev = node;
 804cd6c:	89 70 04             	mov    %esi,0x4(%eax)
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
 804cd6f:	eb 2c                	jmp    804cd9d <z_add_timeout+0x126>
			to->dticks -= t->dticks;
 804cd71:	2b 4d d8             	sub    -0x28(%ebp),%ecx
 804cd74:	1b 5d dc             	sbb    -0x24(%ebp),%ebx
 804cd77:	89 4e 0c             	mov    %ecx,0xc(%esi)
 804cd7a:	89 5e 10             	mov    %ebx,0x10(%esi)
	return (node == list->tail) ? NULL : node->next;
 804cd7d:	39 55 e0             	cmp    %edx,-0x20(%ebp)
 804cd80:	74 0a                	je     804cd8c <z_add_timeout+0x115>
 804cd82:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804cd85:	8b 00                	mov    (%eax),%eax
 804cd87:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804cd8a:	eb 9c                	jmp    804cd28 <z_add_timeout+0xb1>
	node->next = list;
 804cd8c:	c7 06 88 12 05 08    	movl   $0x8051288,(%esi)
	node->prev = tail;
 804cd92:	89 56 04             	mov    %edx,0x4(%esi)
	tail->next = node;
 804cd95:	89 32                	mov    %esi,(%edx)
	list->tail = node;
 804cd97:	89 35 8c 12 05 08    	mov    %esi,0x805128c
	return list->head == list;
 804cd9d:	a1 88 12 05 08       	mov    0x8051288,%eax
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
 804cda2:	39 c6                	cmp    %eax,%esi
 804cda4:	75 25                	jne    804cdcb <z_add_timeout+0x154>
 804cda6:	3d 88 12 05 08       	cmp    $0x8051288,%eax
 804cdab:	74 1e                	je     804cdcb <z_add_timeout+0x154>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
 804cdad:	e8 65 fe ff ff       	call   804cc17 <next_timeout>

			if (next_time == 0 ||
 804cdb2:	85 c0                	test   %eax,%eax
 804cdb4:	74 08                	je     804cdbe <z_add_timeout+0x147>
 804cdb6:	39 05 70 23 05 08    	cmp    %eax,0x8052370
 804cdbc:	74 0d                	je     804cdcb <z_add_timeout+0x154>
			    _current_cpu->slice_ticks != next_time) {
				sys_clock_set_timeout(next_time, false);
 804cdbe:	52                   	push   %edx
 804cdbf:	52                   	push   %edx
 804cdc0:	6a 00                	push   $0x0
 804cdc2:	50                   	push   %eax
 804cdc3:	e8 63 f5 ff ff       	call   804c32b <sys_clock_set_timeout>
 804cdc8:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804cdcb:	89 7d 08             	mov    %edi,0x8(%ebp)
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
 804cdce:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804cdd1:	5b                   	pop    %ebx
 804cdd2:	5e                   	pop    %esi
 804cdd3:	5f                   	pop    %edi
 804cdd4:	5d                   	pop    %ebp
 804cdd5:	e9 a2 e5 ff ff       	jmp    804b37c <posix_irq_unlock>
 804cdda:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804cddd:	5b                   	pop    %ebx
 804cdde:	5e                   	pop    %esi
 804cddf:	5f                   	pop    %edi
 804cde0:	5d                   	pop    %ebp
 804cde1:	c3                   	ret    

0804cde2 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
 804cde2:	f3 0f 1e fb          	endbr32 
 804cde6:	55                   	push   %ebp
 804cde7:	89 e5                	mov    %esp,%ebp
 804cde9:	53                   	push   %ebx
 804cdea:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
 804cded:	e8 74 e5 ff ff       	call   804b366 <posix_irq_lock>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
 804cdf2:	8b 55 08             	mov    0x8(%ebp),%edx
 804cdf5:	89 c3                	mov    %eax,%ebx
	return node->next != NULL;
 804cdf7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 804cdfc:	83 3a 00             	cmpl   $0x0,(%edx)
 804cdff:	74 09                	je     804ce0a <z_abort_timeout+0x28>
			remove_timeout(to);
 804ce01:	89 d0                	mov    %edx,%eax
 804ce03:	e8 d5 fd ff ff       	call   804cbdd <remove_timeout>
			ret = 0;
 804ce08:	31 c0                	xor    %eax,%eax
	posix_irq_unlock(key);
 804ce0a:	83 ec 0c             	sub    $0xc,%esp
 804ce0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ce10:	53                   	push   %ebx
 804ce11:	e8 66 e5 ff ff       	call   804b37c <posix_irq_unlock>
		}
	}

	return ret;
}
 804ce16:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ce19:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804ce1c:	83 c4 10             	add    $0x10,%esp
 804ce1f:	c9                   	leave  
 804ce20:	c3                   	ret    

0804ce21 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
 804ce21:	f3 0f 1e fb          	endbr32 
 804ce25:	55                   	push   %ebp
 804ce26:	89 e5                	mov    %esp,%ebp
 804ce28:	57                   	push   %edi
 804ce29:	56                   	push   %esi
 804ce2a:	53                   	push   %ebx
 804ce2b:	83 ec 0c             	sub    $0xc,%esp
 804ce2e:	8b 75 08             	mov    0x8(%ebp),%esi
 804ce31:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
 804ce34:	e8 2d e5 ff ff       	call   804b366 <posix_irq_lock>
 804ce39:	89 c3                	mov    %eax,%ebx
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
 804ce3b:	e8 d7 fd ff ff       	call   804cc17 <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
 804ce40:	83 f8 ff             	cmp    $0xffffffff,%eax
 804ce43:	0f 94 c1             	sete   %cl
			      || (ticks <= next_to);
 804ce46:	39 f0                	cmp    %esi,%eax
 804ce48:	0f 9d c2             	setge  %dl
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
 804ce4b:	08 d1                	or     %dl,%cl
 804ce4d:	74 1b                	je     804ce6a <z_set_timeout_expiry+0x49>
 804ce4f:	83 f8 01             	cmp    $0x1,%eax
 804ce52:	7e 16                	jle    804ce6a <z_set_timeout_expiry+0x49>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
 804ce54:	39 f0                	cmp    %esi,%eax
 804ce56:	52                   	push   %edx
 804ce57:	0f 4f c6             	cmovg  %esi,%eax
 804ce5a:	52                   	push   %edx
 804ce5b:	89 fa                	mov    %edi,%edx
 804ce5d:	0f b6 fa             	movzbl %dl,%edi
 804ce60:	57                   	push   %edi
 804ce61:	50                   	push   %eax
 804ce62:	e8 c4 f4 ff ff       	call   804c32b <sys_clock_set_timeout>
 804ce67:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804ce6a:	89 5d 08             	mov    %ebx,0x8(%ebp)
		}
	}
}
 804ce6d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ce70:	5b                   	pop    %ebx
 804ce71:	5e                   	pop    %esi
 804ce72:	5f                   	pop    %edi
 804ce73:	5d                   	pop    %ebp
 804ce74:	e9 03 e5 ff ff       	jmp    804b37c <posix_irq_unlock>

0804ce79 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
 804ce79:	f3 0f 1e fb          	endbr32 
 804ce7d:	55                   	push   %ebp
 804ce7e:	89 e5                	mov    %esp,%ebp
 804ce80:	57                   	push   %edi
 804ce81:	56                   	push   %esi
 804ce82:	53                   	push   %ebx
 804ce83:	83 ec 28             	sub    $0x28,%esp
 804ce86:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
 804ce89:	53                   	push   %ebx
 804ce8a:	e8 5e fa ff ff       	call   804c8ed <z_time_slice>
 804ce8f:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 804ce92:	e8 cf e4 ff ff       	call   804b366 <posix_irq_lock>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
 804ce97:	89 1d 98 24 05 08    	mov    %ebx,0x8052498
 804ce9d:	89 c7                	mov    %eax,%edi
	return list->head == list;
 804ce9f:	a1 20 24 05 08       	mov    0x8052420,%eax
 804cea4:	8b 15 24 24 05 08    	mov    0x8052424,%edx
 804ceaa:	8b 1d 88 12 05 08    	mov    0x8051288,%ebx
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
 804ceb0:	8b 35 98 24 05 08    	mov    0x8052498,%esi
 804ceb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804ceb9:	89 55 e4             	mov    %edx,-0x1c(%ebp)

	while (first() != NULL && first()->dticks <= announce_remaining) {
 804cebc:	85 db                	test   %ebx,%ebx
 804cebe:	74 7d                	je     804cf3d <sys_clock_announce+0xc4>
 804cec0:	81 fb 88 12 05 08    	cmp    $0x8051288,%ebx
 804cec6:	74 75                	je     804cf3d <sys_clock_announce+0xc4>
 804cec8:	89 f1                	mov    %esi,%ecx
 804ceca:	8b 43 0c             	mov    0xc(%ebx),%eax
 804cecd:	8b 53 10             	mov    0x10(%ebx),%edx
 804ced0:	89 75 d8             	mov    %esi,-0x28(%ebp)
 804ced3:	c1 f9 1f             	sar    $0x1f,%ecx
 804ced6:	89 4d dc             	mov    %ecx,-0x24(%ebp)
 804ced9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
 804cedc:	39 c6                	cmp    %eax,%esi
 804cede:	19 d1                	sbb    %edx,%ecx
 804cee0:	7c 4f                	jl     804cf31 <sys_clock_announce+0xb8>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
		announce_remaining -= dt;
		t->dticks = 0;
 804cee2:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		int dt = t->dticks;
 804cee9:	89 c1                	mov    %eax,%ecx
		curr_tick += dt;
 804ceeb:	99                   	cltd   
 804ceec:	03 45 e0             	add    -0x20(%ebp),%eax
		t->dticks = 0;
 804ceef:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		curr_tick += dt;
 804cef6:	13 55 e4             	adc    -0x1c(%ebp),%edx
		announce_remaining -= dt;
 804cef9:	29 ce                	sub    %ecx,%esi
		curr_tick += dt;
 804cefb:	a3 20 24 05 08       	mov    %eax,0x8052420
		remove_timeout(t);
 804cf00:	89 d8                	mov    %ebx,%eax
		curr_tick += dt;
 804cf02:	89 15 24 24 05 08    	mov    %edx,0x8052424
		announce_remaining -= dt;
 804cf08:	89 35 98 24 05 08    	mov    %esi,0x8052498
		remove_timeout(t);
 804cf0e:	e8 ca fc ff ff       	call   804cbdd <remove_timeout>
	posix_irq_unlock(key);
 804cf13:	83 ec 0c             	sub    $0xc,%esp
 804cf16:	57                   	push   %edi
 804cf17:	e8 60 e4 ff ff       	call   804b37c <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
 804cf1c:	89 1c 24             	mov    %ebx,(%esp)
 804cf1f:	ff 53 08             	call   *0x8(%ebx)
 804cf22:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 804cf25:	e8 3c e4 ff ff       	call   804b366 <posix_irq_lock>
 804cf2a:	89 c7                	mov    %eax,%edi
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
 804cf2c:	e9 6e ff ff ff       	jmp    804ce9f <sys_clock_announce+0x26>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
 804cf31:	2b 45 d8             	sub    -0x28(%ebp),%eax
 804cf34:	1b 55 dc             	sbb    -0x24(%ebp),%edx
 804cf37:	89 43 0c             	mov    %eax,0xc(%ebx)
 804cf3a:	89 53 10             	mov    %edx,0x10(%ebx)
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
 804cf3d:	c7 05 98 24 05 08 00 	movl   $0x0,0x8052498
 804cf44:	00 00 00 
	curr_tick += announce_remaining;
 804cf47:	89 f0                	mov    %esi,%eax
 804cf49:	99                   	cltd   
 804cf4a:	03 45 e0             	add    -0x20(%ebp),%eax
 804cf4d:	13 55 e4             	adc    -0x1c(%ebp),%edx
 804cf50:	89 15 24 24 05 08    	mov    %edx,0x8052424
 804cf56:	a3 20 24 05 08       	mov    %eax,0x8052420

	sys_clock_set_timeout(next_timeout(), false);
 804cf5b:	e8 b7 fc ff ff       	call   804cc17 <next_timeout>
 804cf60:	52                   	push   %edx
 804cf61:	52                   	push   %edx
 804cf62:	6a 00                	push   $0x0
 804cf64:	50                   	push   %eax
 804cf65:	e8 c1 f3 ff ff       	call   804c32b <sys_clock_set_timeout>
	posix_irq_unlock(key);
 804cf6a:	89 7d 08             	mov    %edi,0x8(%ebp)
 804cf6d:	83 c4 10             	add    $0x10,%esp

	k_spin_unlock(&timeout_lock, key);
}
 804cf70:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804cf73:	5b                   	pop    %ebx
 804cf74:	5e                   	pop    %esi
 804cf75:	5f                   	pop    %edi
 804cf76:	5d                   	pop    %ebp
 804cf77:	e9 00 e4 ff ff       	jmp    804b37c <posix_irq_unlock>

0804cf7c <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
 804cf7c:	f3 0f 1e fb          	endbr32 
 804cf80:	55                   	push   %ebp
 804cf81:	89 e5                	mov    %esp,%ebp
 804cf83:	83 ec 0c             	sub    $0xc,%esp
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
 804cf86:	68 58 ec 04 08       	push   $0x804ec58
 804cf8b:	68 a9 ed 04 08       	push   $0x804eda9
 804cf90:	68 ca ed 04 08       	push   $0x804edca
 804cf95:	e8 05 c8 ff ff       	call   804979f <printk>
 804cf9a:	83 c4 10             	add    $0x10,%esp
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
 804cf9d:	c9                   	leave  
 804cf9e:	c3                   	ret    

0804cf9f <z_device_state_init>:
 *
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
 804cf9f:	f3 0f 1e fb          	endbr32 

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
 804cfa3:	c3                   	ret    

0804cfa4 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
 804cfa4:	f3 0f 1e fb          	endbr32 
 804cfa8:	55                   	push   %ebp
 804cfa9:	89 e5                	mov    %esp,%ebp
 804cfab:	57                   	push   %edi
 804cfac:	56                   	push   %esi
 804cfad:	53                   	push   %ebx
 804cfae:	83 ec 0c             	sub    $0xc,%esp
 804cfb1:	8b 5d 08             	mov    0x8(%ebp),%ebx
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 804cfb4:	8b 34 9d 50 e1 04 08 	mov    0x804e150(,%ebx,4),%esi
 804cfbb:	39 34 9d 54 e1 04 08 	cmp    %esi,0x804e154(,%ebx,4)
 804cfc2:	76 38                	jbe    804cffc <z_sys_init_run_level+0x58>
		const struct device *dev = entry->dev;
 804cfc4:	8b 7e 04             	mov    0x4(%esi),%edi
		int rc = entry->init(dev);
 804cfc7:	83 ec 0c             	sub    $0xc,%esp
 804cfca:	57                   	push   %edi
 804cfcb:	ff 16                	call   *(%esi)
 804cfcd:	83 c4 10             	add    $0x10,%esp

		if (dev != NULL) {
 804cfd0:	85 ff                	test   %edi,%edi
 804cfd2:	74 23                	je     804cff7 <z_sys_init_run_level+0x53>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
 804cfd4:	8b 57 0c             	mov    0xc(%edi),%edx
 804cfd7:	85 c0                	test   %eax,%eax
 804cfd9:	74 18                	je     804cff3 <z_sys_init_run_level+0x4f>
				if (rc < 0) {
 804cfdb:	89 c1                	mov    %eax,%ecx
 804cfdd:	c1 f9 1f             	sar    $0x1f,%ecx
 804cfe0:	31 c8                	xor    %ecx,%eax
 804cfe2:	29 c8                	sub    %ecx,%eax
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
 804cfe4:	b9 ff 00 00 00       	mov    $0xff,%ecx
 804cfe9:	3d ff 00 00 00       	cmp    $0xff,%eax
 804cfee:	0f 4f c1             	cmovg  %ecx,%eax
 804cff1:	88 02                	mov    %al,(%edx)
			}
			dev->state->initialized = true;
 804cff3:	80 4a 01 01          	orb    $0x1,0x1(%edx)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 804cff7:	83 c6 08             	add    $0x8,%esi
 804cffa:	eb bf                	jmp    804cfbb <z_sys_init_run_level+0x17>
		}
	}
}
 804cffc:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804cfff:	5b                   	pop    %ebx
 804d000:	5e                   	pop    %esi
 804d001:	5f                   	pop    %edi
 804d002:	5d                   	pop    %ebp
 804d003:	c3                   	ret    

0804d004 <__x86.get_pc_thunk.bp>:
 804d004:	8b 2c 24             	mov    (%esp),%ebp
 804d007:	c3                   	ret    

Disassembly of section .fini:

0804d008 <_fini>:
 804d008:	f3 0f 1e fb          	endbr32 
 804d00c:	53                   	push   %ebx
 804d00d:	83 ec 08             	sub    $0x8,%esp
 804d010:	e8 9b c5 ff ff       	call   80495b0 <__x86.get_pc_thunk.bx>
 804d015:	81 c3 eb 3f 00 00    	add    $0x3feb,%ebx
 804d01b:	83 c4 08             	add    $0x8,%esp
 804d01e:	5b                   	pop    %ebx
 804d01f:	c3                   	ret    
