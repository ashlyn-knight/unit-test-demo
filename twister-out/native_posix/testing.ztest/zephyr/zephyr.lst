
zephyr.elf:     file format elf32-i386


Disassembly of section .init:

08049000 <_init>:
 8049000:	f3 0f 1e fb          	endbr32 
 8049004:	53                   	push   %ebx
 8049005:	83 ec 08             	sub    $0x8,%esp
 8049008:	e8 03 06 00 00       	call   8049610 <__x86.get_pc_thunk.bx>
 804900d:	81 c3 f3 bf 00 00    	add    $0xbff3,%ebx
 8049013:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049019:	85 c0                	test   %eax,%eax
 804901b:	74 02                	je     804901f <_init+0x1f>
 804901d:	ff d0                	call   *%eax
 804901f:	83 c4 08             	add    $0x8,%esp
 8049022:	5b                   	pop    %ebx
 8049023:	c3                   	ret    

Disassembly of section .plt:

08049030 <.plt>:
 8049030:	ff 35 04 50 05 08    	pushl  0x8055004
 8049036:	ff 25 08 50 05 08    	jmp    *0x8055008
 804903c:	0f 1f 40 00          	nopl   0x0(%eax)
 8049040:	f3 0f 1e fb          	endbr32 
 8049044:	68 00 00 00 00       	push   $0x0
 8049049:	e9 e2 ff ff ff       	jmp    8049030 <.plt>
 804904e:	66 90                	xchg   %ax,%ax
 8049050:	f3 0f 1e fb          	endbr32 
 8049054:	68 08 00 00 00       	push   $0x8
 8049059:	e9 d2 ff ff ff       	jmp    8049030 <.plt>
 804905e:	66 90                	xchg   %ax,%ax
 8049060:	f3 0f 1e fb          	endbr32 
 8049064:	68 10 00 00 00       	push   $0x10
 8049069:	e9 c2 ff ff ff       	jmp    8049030 <.plt>
 804906e:	66 90                	xchg   %ax,%ax
 8049070:	f3 0f 1e fb          	endbr32 
 8049074:	68 18 00 00 00       	push   $0x18
 8049079:	e9 b2 ff ff ff       	jmp    8049030 <.plt>
 804907e:	66 90                	xchg   %ax,%ax
 8049080:	f3 0f 1e fb          	endbr32 
 8049084:	68 20 00 00 00       	push   $0x20
 8049089:	e9 a2 ff ff ff       	jmp    8049030 <.plt>
 804908e:	66 90                	xchg   %ax,%ax
 8049090:	f3 0f 1e fb          	endbr32 
 8049094:	68 28 00 00 00       	push   $0x28
 8049099:	e9 92 ff ff ff       	jmp    8049030 <.plt>
 804909e:	66 90                	xchg   %ax,%ax
 80490a0:	f3 0f 1e fb          	endbr32 
 80490a4:	68 30 00 00 00       	push   $0x30
 80490a9:	e9 82 ff ff ff       	jmp    8049030 <.plt>
 80490ae:	66 90                	xchg   %ax,%ax
 80490b0:	f3 0f 1e fb          	endbr32 
 80490b4:	68 38 00 00 00       	push   $0x38
 80490b9:	e9 72 ff ff ff       	jmp    8049030 <.plt>
 80490be:	66 90                	xchg   %ax,%ax
 80490c0:	f3 0f 1e fb          	endbr32 
 80490c4:	68 40 00 00 00       	push   $0x40
 80490c9:	e9 62 ff ff ff       	jmp    8049030 <.plt>
 80490ce:	66 90                	xchg   %ax,%ax
 80490d0:	f3 0f 1e fb          	endbr32 
 80490d4:	68 48 00 00 00       	push   $0x48
 80490d9:	e9 52 ff ff ff       	jmp    8049030 <.plt>
 80490de:	66 90                	xchg   %ax,%ax
 80490e0:	f3 0f 1e fb          	endbr32 
 80490e4:	68 50 00 00 00       	push   $0x50
 80490e9:	e9 42 ff ff ff       	jmp    8049030 <.plt>
 80490ee:	66 90                	xchg   %ax,%ax
 80490f0:	f3 0f 1e fb          	endbr32 
 80490f4:	68 58 00 00 00       	push   $0x58
 80490f9:	e9 32 ff ff ff       	jmp    8049030 <.plt>
 80490fe:	66 90                	xchg   %ax,%ax
 8049100:	f3 0f 1e fb          	endbr32 
 8049104:	68 60 00 00 00       	push   $0x60
 8049109:	e9 22 ff ff ff       	jmp    8049030 <.plt>
 804910e:	66 90                	xchg   %ax,%ax
 8049110:	f3 0f 1e fb          	endbr32 
 8049114:	68 68 00 00 00       	push   $0x68
 8049119:	e9 12 ff ff ff       	jmp    8049030 <.plt>
 804911e:	66 90                	xchg   %ax,%ax
 8049120:	f3 0f 1e fb          	endbr32 
 8049124:	68 70 00 00 00       	push   $0x70
 8049129:	e9 02 ff ff ff       	jmp    8049030 <.plt>
 804912e:	66 90                	xchg   %ax,%ax
 8049130:	f3 0f 1e fb          	endbr32 
 8049134:	68 78 00 00 00       	push   $0x78
 8049139:	e9 f2 fe ff ff       	jmp    8049030 <.plt>
 804913e:	66 90                	xchg   %ax,%ax
 8049140:	f3 0f 1e fb          	endbr32 
 8049144:	68 80 00 00 00       	push   $0x80
 8049149:	e9 e2 fe ff ff       	jmp    8049030 <.plt>
 804914e:	66 90                	xchg   %ax,%ax
 8049150:	f3 0f 1e fb          	endbr32 
 8049154:	68 88 00 00 00       	push   $0x88
 8049159:	e9 d2 fe ff ff       	jmp    8049030 <.plt>
 804915e:	66 90                	xchg   %ax,%ax
 8049160:	f3 0f 1e fb          	endbr32 
 8049164:	68 90 00 00 00       	push   $0x90
 8049169:	e9 c2 fe ff ff       	jmp    8049030 <.plt>
 804916e:	66 90                	xchg   %ax,%ax
 8049170:	f3 0f 1e fb          	endbr32 
 8049174:	68 98 00 00 00       	push   $0x98
 8049179:	e9 b2 fe ff ff       	jmp    8049030 <.plt>
 804917e:	66 90                	xchg   %ax,%ax
 8049180:	f3 0f 1e fb          	endbr32 
 8049184:	68 a0 00 00 00       	push   $0xa0
 8049189:	e9 a2 fe ff ff       	jmp    8049030 <.plt>
 804918e:	66 90                	xchg   %ax,%ax
 8049190:	f3 0f 1e fb          	endbr32 
 8049194:	68 a8 00 00 00       	push   $0xa8
 8049199:	e9 92 fe ff ff       	jmp    8049030 <.plt>
 804919e:	66 90                	xchg   %ax,%ax
 80491a0:	f3 0f 1e fb          	endbr32 
 80491a4:	68 b0 00 00 00       	push   $0xb0
 80491a9:	e9 82 fe ff ff       	jmp    8049030 <.plt>
 80491ae:	66 90                	xchg   %ax,%ax
 80491b0:	f3 0f 1e fb          	endbr32 
 80491b4:	68 b8 00 00 00       	push   $0xb8
 80491b9:	e9 72 fe ff ff       	jmp    8049030 <.plt>
 80491be:	66 90                	xchg   %ax,%ax
 80491c0:	f3 0f 1e fb          	endbr32 
 80491c4:	68 c0 00 00 00       	push   $0xc0
 80491c9:	e9 62 fe ff ff       	jmp    8049030 <.plt>
 80491ce:	66 90                	xchg   %ax,%ax
 80491d0:	f3 0f 1e fb          	endbr32 
 80491d4:	68 c8 00 00 00       	push   $0xc8
 80491d9:	e9 52 fe ff ff       	jmp    8049030 <.plt>
 80491de:	66 90                	xchg   %ax,%ax
 80491e0:	f3 0f 1e fb          	endbr32 
 80491e4:	68 d0 00 00 00       	push   $0xd0
 80491e9:	e9 42 fe ff ff       	jmp    8049030 <.plt>
 80491ee:	66 90                	xchg   %ax,%ax
 80491f0:	f3 0f 1e fb          	endbr32 
 80491f4:	68 d8 00 00 00       	push   $0xd8
 80491f9:	e9 32 fe ff ff       	jmp    8049030 <.plt>
 80491fe:	66 90                	xchg   %ax,%ax
 8049200:	f3 0f 1e fb          	endbr32 
 8049204:	68 e0 00 00 00       	push   $0xe0
 8049209:	e9 22 fe ff ff       	jmp    8049030 <.plt>
 804920e:	66 90                	xchg   %ax,%ax
 8049210:	f3 0f 1e fb          	endbr32 
 8049214:	68 e8 00 00 00       	push   $0xe8
 8049219:	e9 12 fe ff ff       	jmp    8049030 <.plt>
 804921e:	66 90                	xchg   %ax,%ax
 8049220:	f3 0f 1e fb          	endbr32 
 8049224:	68 f0 00 00 00       	push   $0xf0
 8049229:	e9 02 fe ff ff       	jmp    8049030 <.plt>
 804922e:	66 90                	xchg   %ax,%ax
 8049230:	f3 0f 1e fb          	endbr32 
 8049234:	68 f8 00 00 00       	push   $0xf8
 8049239:	e9 f2 fd ff ff       	jmp    8049030 <.plt>
 804923e:	66 90                	xchg   %ax,%ax
 8049240:	f3 0f 1e fb          	endbr32 
 8049244:	68 00 01 00 00       	push   $0x100
 8049249:	e9 e2 fd ff ff       	jmp    8049030 <.plt>
 804924e:	66 90                	xchg   %ax,%ax
 8049250:	f3 0f 1e fb          	endbr32 
 8049254:	68 08 01 00 00       	push   $0x108
 8049259:	e9 d2 fd ff ff       	jmp    8049030 <.plt>
 804925e:	66 90                	xchg   %ax,%ax
 8049260:	f3 0f 1e fb          	endbr32 
 8049264:	68 10 01 00 00       	push   $0x110
 8049269:	e9 c2 fd ff ff       	jmp    8049030 <.plt>
 804926e:	66 90                	xchg   %ax,%ax
 8049270:	f3 0f 1e fb          	endbr32 
 8049274:	68 18 01 00 00       	push   $0x118
 8049279:	e9 b2 fd ff ff       	jmp    8049030 <.plt>
 804927e:	66 90                	xchg   %ax,%ax
 8049280:	f3 0f 1e fb          	endbr32 
 8049284:	68 20 01 00 00       	push   $0x120
 8049289:	e9 a2 fd ff ff       	jmp    8049030 <.plt>
 804928e:	66 90                	xchg   %ax,%ax
 8049290:	f3 0f 1e fb          	endbr32 
 8049294:	68 28 01 00 00       	push   $0x128
 8049299:	e9 92 fd ff ff       	jmp    8049030 <.plt>
 804929e:	66 90                	xchg   %ax,%ax
 80492a0:	f3 0f 1e fb          	endbr32 
 80492a4:	68 30 01 00 00       	push   $0x130
 80492a9:	e9 82 fd ff ff       	jmp    8049030 <.plt>
 80492ae:	66 90                	xchg   %ax,%ax
 80492b0:	f3 0f 1e fb          	endbr32 
 80492b4:	68 38 01 00 00       	push   $0x138
 80492b9:	e9 72 fd ff ff       	jmp    8049030 <.plt>
 80492be:	66 90                	xchg   %ax,%ax
 80492c0:	f3 0f 1e fb          	endbr32 
 80492c4:	68 40 01 00 00       	push   $0x140
 80492c9:	e9 62 fd ff ff       	jmp    8049030 <.plt>
 80492ce:	66 90                	xchg   %ax,%ax
 80492d0:	f3 0f 1e fb          	endbr32 
 80492d4:	68 48 01 00 00       	push   $0x148
 80492d9:	e9 52 fd ff ff       	jmp    8049030 <.plt>
 80492de:	66 90                	xchg   %ax,%ax
 80492e0:	f3 0f 1e fb          	endbr32 
 80492e4:	68 50 01 00 00       	push   $0x150
 80492e9:	e9 42 fd ff ff       	jmp    8049030 <.plt>
 80492ee:	66 90                	xchg   %ax,%ax
 80492f0:	f3 0f 1e fb          	endbr32 
 80492f4:	68 58 01 00 00       	push   $0x158
 80492f9:	e9 32 fd ff ff       	jmp    8049030 <.plt>
 80492fe:	66 90                	xchg   %ax,%ax

Disassembly of section .plt.sec:

08049300 <pthread_mutex_unlock@plt>:
 8049300:	f3 0f 1e fb          	endbr32 
 8049304:	ff 25 0c 50 05 08    	jmp    *0x805500c
 804930a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049310 <__snprintf_chk@plt>:
 8049310:	f3 0f 1e fb          	endbr32 
 8049314:	ff 25 10 50 05 08    	jmp    *0x8055010
 804931a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049320 <__udivdi3@plt>:
 8049320:	f3 0f 1e fb          	endbr32 
 8049324:	ff 25 14 50 05 08    	jmp    *0x8055014
 804932a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049330 <strcmp@plt>:
 8049330:	f3 0f 1e fb          	endbr32 
 8049334:	ff 25 18 50 05 08    	jmp    *0x8055018
 804933a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049340 <__vfprintf_chk@plt>:
 8049340:	f3 0f 1e fb          	endbr32 
 8049344:	ff 25 1c 50 05 08    	jmp    *0x805501c
 804934a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049350 <pthread_cond_broadcast@plt>:
 8049350:	f3 0f 1e fb          	endbr32 
 8049354:	ff 25 20 50 05 08    	jmp    *0x8055020
 804935a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049360 <free@plt>:
 8049360:	f3 0f 1e fb          	endbr32 
 8049364:	ff 25 24 50 05 08    	jmp    *0x8055024
 804936a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049370 <__pthread_register_cancel@plt>:
 8049370:	f3 0f 1e fb          	endbr32 
 8049374:	ff 25 28 50 05 08    	jmp    *0x8055028
 804937a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049380 <clock_gettime@plt>:
 8049380:	f3 0f 1e fb          	endbr32 
 8049384:	ff 25 2c 50 05 08    	jmp    *0x805502c
 804938a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049390 <pthread_self@plt>:
 8049390:	f3 0f 1e fb          	endbr32 
 8049394:	ff 25 30 50 05 08    	jmp    *0x8055030
 804939a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493a0 <pthread_cond_wait@plt>:
 80493a0:	f3 0f 1e fb          	endbr32 
 80493a4:	ff 25 34 50 05 08    	jmp    *0x8055034
 80493aa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493b0 <sleep@plt>:
 80493b0:	f3 0f 1e fb          	endbr32 
 80493b4:	ff 25 38 50 05 08    	jmp    *0x8055038
 80493ba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493c0 <__stack_chk_fail@plt>:
 80493c0:	f3 0f 1e fb          	endbr32 
 80493c4:	ff 25 3c 50 05 08    	jmp    *0x805503c
 80493ca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493d0 <pthread_mutex_lock@plt>:
 80493d0:	f3 0f 1e fb          	endbr32 
 80493d4:	ff 25 40 50 05 08    	jmp    *0x8055040
 80493da:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493e0 <strtoll@plt>:
 80493e0:	f3 0f 1e fb          	endbr32 
 80493e4:	ff 25 44 50 05 08    	jmp    *0x8055044
 80493ea:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493f0 <realloc@plt>:
 80493f0:	f3 0f 1e fb          	endbr32 
 80493f4:	ff 25 48 50 05 08    	jmp    *0x8055048
 80493fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049400 <exit@plt>:
 8049400:	f3 0f 1e fb          	endbr32 
 8049404:	ff 25 4c 50 05 08    	jmp    *0x805504c
 804940a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049410 <__udivmoddi4@plt>:
 8049410:	f3 0f 1e fb          	endbr32 
 8049414:	ff 25 50 50 05 08    	jmp    *0x8055050
 804941a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049420 <strtoul@plt>:
 8049420:	f3 0f 1e fb          	endbr32 
 8049424:	ff 25 54 50 05 08    	jmp    *0x8055054
 804942a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049430 <getcwd@plt>:
 8049430:	f3 0f 1e fb          	endbr32 
 8049434:	ff 25 58 50 05 08    	jmp    *0x8055058
 804943a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049440 <__libc_start_main@plt>:
 8049440:	f3 0f 1e fb          	endbr32 
 8049444:	ff 25 5c 50 05 08    	jmp    *0x805505c
 804944a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049450 <strcasecmp@plt>:
 8049450:	f3 0f 1e fb          	endbr32 
 8049454:	ff 25 60 50 05 08    	jmp    *0x8055060
 804945a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049460 <setvbuf@plt>:
 8049460:	f3 0f 1e fb          	endbr32 
 8049464:	ff 25 64 50 05 08    	jmp    *0x8055064
 804946a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049470 <snprintf@plt>:
 8049470:	f3 0f 1e fb          	endbr32 
 8049474:	ff 25 68 50 05 08    	jmp    *0x8055068
 804947a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049480 <putchar@plt>:
 8049480:	f3 0f 1e fb          	endbr32 
 8049484:	ff 25 6c 50 05 08    	jmp    *0x805506c
 804948a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049490 <pthread_cancel@plt>:
 8049490:	f3 0f 1e fb          	endbr32 
 8049494:	ff 25 70 50 05 08    	jmp    *0x8055070
 804949a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494a0 <strncpy@plt>:
 80494a0:	f3 0f 1e fb          	endbr32 
 80494a4:	ff 25 74 50 05 08    	jmp    *0x8055074
 80494aa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494b0 <strtoull@plt>:
 80494b0:	f3 0f 1e fb          	endbr32 
 80494b4:	ff 25 78 50 05 08    	jmp    *0x8055078
 80494ba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494c0 <strtod@plt>:
 80494c0:	f3 0f 1e fb          	endbr32 
 80494c4:	ff 25 7c 50 05 08    	jmp    *0x805507c
 80494ca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494d0 <pthread_exit@plt>:
 80494d0:	f3 0f 1e fb          	endbr32 
 80494d4:	ff 25 80 50 05 08    	jmp    *0x8055080
 80494da:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494e0 <strnlen@plt>:
 80494e0:	f3 0f 1e fb          	endbr32 
 80494e4:	ff 25 84 50 05 08    	jmp    *0x8055084
 80494ea:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494f0 <__sigsetjmp@plt>:
 80494f0:	f3 0f 1e fb          	endbr32 
 80494f4:	ff 25 88 50 05 08    	jmp    *0x8055088
 80494fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049500 <sigemptyset@plt>:
 8049500:	f3 0f 1e fb          	endbr32 
 8049504:	ff 25 8c 50 05 08    	jmp    *0x805508c
 804950a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049510 <__pthread_unwind_next@plt>:
 8049510:	f3 0f 1e fb          	endbr32 
 8049514:	ff 25 90 50 05 08    	jmp    *0x8055090
 804951a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049520 <nanosleep@plt>:
 8049520:	f3 0f 1e fb          	endbr32 
 8049524:	ff 25 94 50 05 08    	jmp    *0x8055094
 804952a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049530 <__fprintf_chk@plt>:
 8049530:	f3 0f 1e fb          	endbr32 
 8049534:	ff 25 98 50 05 08    	jmp    *0x8055098
 804953a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049540 <pthread_create@plt>:
 8049540:	f3 0f 1e fb          	endbr32 
 8049544:	ff 25 9c 50 05 08    	jmp    *0x805509c
 804954a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049550 <sigaction@plt>:
 8049550:	f3 0f 1e fb          	endbr32 
 8049554:	ff 25 a0 50 05 08    	jmp    *0x80550a0
 804955a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049560 <pthread_detach@plt>:
 8049560:	f3 0f 1e fb          	endbr32 
 8049564:	ff 25 a4 50 05 08    	jmp    *0x80550a4
 804956a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049570 <strncmp@plt>:
 8049570:	f3 0f 1e fb          	endbr32 
 8049574:	ff 25 a8 50 05 08    	jmp    *0x80550a8
 804957a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049580 <isatty@plt>:
 8049580:	f3 0f 1e fb          	endbr32 
 8049584:	ff 25 ac 50 05 08    	jmp    *0x80550ac
 804958a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049590 <strtol@plt>:
 8049590:	f3 0f 1e fb          	endbr32 
 8049594:	ff 25 b0 50 05 08    	jmp    *0x80550b0
 804959a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080495a0 <__ctype_b_loc@plt>:
 80495a0:	f3 0f 1e fb          	endbr32 
 80495a4:	ff 25 b4 50 05 08    	jmp    *0x80550b4
 80495aa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080495b0 <calloc@plt>:
 80495b0:	f3 0f 1e fb          	endbr32 
 80495b4:	ff 25 b8 50 05 08    	jmp    *0x80550b8
 80495ba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

Disassembly of section .text:

080495c0 <_start>:
 80495c0:	f3 0f 1e fb          	endbr32 
 80495c4:	31 ed                	xor    %ebp,%ebp
 80495c6:	5e                   	pop    %esi
 80495c7:	89 e1                	mov    %esp,%ecx
 80495c9:	83 e4 f0             	and    $0xfffffff0,%esp
 80495cc:	50                   	push   %eax
 80495cd:	54                   	push   %esp
 80495ce:	52                   	push   %edx
 80495cf:	e8 23 00 00 00       	call   80495f7 <_start+0x37>
 80495d4:	81 c3 2c ba 00 00    	add    $0xba2c,%ebx
 80495da:	8d 83 50 47 ff ff    	lea    -0xb8b0(%ebx),%eax
 80495e0:	50                   	push   %eax
 80495e1:	8d 83 e0 46 ff ff    	lea    -0xb920(%ebx),%eax
 80495e7:	50                   	push   %eax
 80495e8:	51                   	push   %ecx
 80495e9:	56                   	push   %esi
 80495ea:	c7 c0 3d d2 04 08    	mov    $0x804d23d,%eax
 80495f0:	50                   	push   %eax
 80495f1:	e8 4a fe ff ff       	call   8049440 <__libc_start_main@plt>
 80495f6:	f4                   	hlt    
 80495f7:	8b 1c 24             	mov    (%esp),%ebx
 80495fa:	c3                   	ret    
 80495fb:	66 90                	xchg   %ax,%ax
 80495fd:	66 90                	xchg   %ax,%ax
 80495ff:	90                   	nop

08049600 <_dl_relocate_static_pie>:
 8049600:	f3 0f 1e fb          	endbr32 
 8049604:	c3                   	ret    
 8049605:	66 90                	xchg   %ax,%ax
 8049607:	66 90                	xchg   %ax,%ax
 8049609:	66 90                	xchg   %ax,%ax
 804960b:	66 90                	xchg   %ax,%ax
 804960d:	66 90                	xchg   %ax,%ax
 804960f:	90                   	nop

08049610 <__x86.get_pc_thunk.bx>:
 8049610:	8b 1c 24             	mov    (%esp),%ebx
 8049613:	c3                   	ret    
 8049614:	66 90                	xchg   %ax,%ax
 8049616:	66 90                	xchg   %ax,%ax
 8049618:	66 90                	xchg   %ax,%ax
 804961a:	66 90                	xchg   %ax,%ax
 804961c:	66 90                	xchg   %ax,%ax
 804961e:	66 90                	xchg   %ax,%ax

08049620 <deregister_tm_clones>:
 8049620:	b8 9c 52 05 08       	mov    $0x805529c,%eax
 8049625:	3d 9c 52 05 08       	cmp    $0x805529c,%eax
 804962a:	74 24                	je     8049650 <deregister_tm_clones+0x30>
 804962c:	b8 00 00 00 00       	mov    $0x0,%eax
 8049631:	85 c0                	test   %eax,%eax
 8049633:	74 1b                	je     8049650 <deregister_tm_clones+0x30>
 8049635:	55                   	push   %ebp
 8049636:	89 e5                	mov    %esp,%ebp
 8049638:	83 ec 14             	sub    $0x14,%esp
 804963b:	68 9c 52 05 08       	push   $0x805529c
 8049640:	ff d0                	call   *%eax
 8049642:	83 c4 10             	add    $0x10,%esp
 8049645:	c9                   	leave  
 8049646:	c3                   	ret    
 8049647:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804964e:	66 90                	xchg   %ax,%ax
 8049650:	c3                   	ret    
 8049651:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049658:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804965f:	90                   	nop

08049660 <register_tm_clones>:
 8049660:	b8 9c 52 05 08       	mov    $0x805529c,%eax
 8049665:	2d 9c 52 05 08       	sub    $0x805529c,%eax
 804966a:	89 c2                	mov    %eax,%edx
 804966c:	c1 e8 1f             	shr    $0x1f,%eax
 804966f:	c1 fa 02             	sar    $0x2,%edx
 8049672:	01 d0                	add    %edx,%eax
 8049674:	d1 f8                	sar    %eax
 8049676:	74 20                	je     8049698 <register_tm_clones+0x38>
 8049678:	ba 00 00 00 00       	mov    $0x0,%edx
 804967d:	85 d2                	test   %edx,%edx
 804967f:	74 17                	je     8049698 <register_tm_clones+0x38>
 8049681:	55                   	push   %ebp
 8049682:	89 e5                	mov    %esp,%ebp
 8049684:	83 ec 10             	sub    $0x10,%esp
 8049687:	50                   	push   %eax
 8049688:	68 9c 52 05 08       	push   $0x805529c
 804968d:	ff d2                	call   *%edx
 804968f:	83 c4 10             	add    $0x10,%esp
 8049692:	c9                   	leave  
 8049693:	c3                   	ret    
 8049694:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049698:	c3                   	ret    
 8049699:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

080496a0 <__do_global_dtors_aux>:
 80496a0:	f3 0f 1e fb          	endbr32 
 80496a4:	80 3d e8 6a 05 08 00 	cmpb   $0x0,0x8056ae8
 80496ab:	75 1b                	jne    80496c8 <__do_global_dtors_aux+0x28>
 80496ad:	55                   	push   %ebp
 80496ae:	89 e5                	mov    %esp,%ebp
 80496b0:	83 ec 08             	sub    $0x8,%esp
 80496b3:	e8 68 ff ff ff       	call   8049620 <deregister_tm_clones>
 80496b8:	c6 05 e8 6a 05 08 01 	movb   $0x1,0x8056ae8
 80496bf:	c9                   	leave  
 80496c0:	c3                   	ret    
 80496c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80496c8:	c3                   	ret    
 80496c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

080496d0 <frame_dummy>:
 80496d0:	f3 0f 1e fb          	endbr32 
 80496d4:	eb 8a                	jmp    8049660 <register_tm_clones>
 80496d6:	66 90                	xchg   %ax,%ax
 80496d8:	66 90                	xchg   %ax,%ax
 80496da:	66 90                	xchg   %ax,%ax
 80496dc:	66 90                	xchg   %ax,%ax
 80496de:	66 90                	xchg   %ax,%ax

080496e0 <__libc_csu_init>:
 80496e0:	f3 0f 1e fb          	endbr32 
 80496e4:	55                   	push   %ebp
 80496e5:	e8 84 6e 00 00       	call   805056e <__x86.get_pc_thunk.bp>
 80496ea:	81 c5 16 b9 00 00    	add    $0xb916,%ebp
 80496f0:	57                   	push   %edi
 80496f1:	56                   	push   %esi
 80496f2:	53                   	push   %ebx
 80496f3:	83 ec 0c             	sub    $0xc,%esp
 80496f6:	89 eb                	mov    %ebp,%ebx
 80496f8:	8b 7c 24 28          	mov    0x28(%esp),%edi
 80496fc:	e8 ff f8 ff ff       	call   8049000 <_init>
 8049701:	8d 9d c8 11 00 00    	lea    0x11c8(%ebp),%ebx
 8049707:	8d 85 c4 11 00 00    	lea    0x11c4(%ebp),%eax
 804970d:	29 c3                	sub    %eax,%ebx
 804970f:	c1 fb 02             	sar    $0x2,%ebx
 8049712:	74 29                	je     804973d <__libc_csu_init+0x5d>
 8049714:	31 f6                	xor    %esi,%esi
 8049716:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804971d:	8d 76 00             	lea    0x0(%esi),%esi
 8049720:	83 ec 04             	sub    $0x4,%esp
 8049723:	57                   	push   %edi
 8049724:	ff 74 24 2c          	pushl  0x2c(%esp)
 8049728:	ff 74 24 2c          	pushl  0x2c(%esp)
 804972c:	ff 94 b5 c4 11 00 00 	call   *0x11c4(%ebp,%esi,4)
 8049733:	83 c6 01             	add    $0x1,%esi
 8049736:	83 c4 10             	add    $0x10,%esp
 8049739:	39 f3                	cmp    %esi,%ebx
 804973b:	75 e3                	jne    8049720 <__libc_csu_init+0x40>
 804973d:	83 c4 0c             	add    $0xc,%esp
 8049740:	5b                   	pop    %ebx
 8049741:	5e                   	pop    %esi
 8049742:	5f                   	pop    %edi
 8049743:	5d                   	pop    %ebp
 8049744:	c3                   	ret    
 8049745:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804974c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08049750 <__libc_csu_fini>:
 8049750:	f3 0f 1e fb          	endbr32 
 8049754:	c3                   	ret    

08049755 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
 8049755:	f3 0f 1e fb          	endbr32 

#if defined(CONFIG_FPU_SHARING)
GEN_OFFSET_SYM(_thread_arch_t, excNestCount);
#endif

GEN_ABS_SYM_END
 8049759:	c3                   	ret    

0804975a <_ZN4math3addEjj>:
#include "math.hpp"

namespace math {

uint32_t add(uint32_t op1, uint32_t op2) {
 804975a:	f3 0f 1e fb          	endbr32 
 804975e:	55                   	push   %ebp
 804975f:	89 e5                	mov    %esp,%ebp
	return op1 + op2;
 8049761:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049764:	03 45 08             	add    0x8(%ebp),%eax
}
 8049767:	5d                   	pop    %ebp
 8049768:	c3                   	ret    

08049769 <_ZN4math8subtractEjj>:

uint32_t subtract(uint32_t op1, uint32_t op2) {
 8049769:	f3 0f 1e fb          	endbr32 
 804976d:	55                   	push   %ebp
 804976e:	89 e5                	mov    %esp,%ebp
	return op1 - op2;
 8049770:	8b 45 08             	mov    0x8(%ebp),%eax
 8049773:	2b 45 0c             	sub    0xc(%ebp),%eax
}
 8049776:	5d                   	pop    %ebp
 8049777:	c3                   	ret    

08049778 <_ZN4math8multiplyEjj>:

uint32_t multiply(uint32_t op1, uint32_t op2) {
 8049778:	f3 0f 1e fb          	endbr32 
 804977c:	55                   	push   %ebp
 804977d:	89 e5                	mov    %esp,%ebp
	return op1 * op2;
 804977f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049782:	0f af 45 08          	imul   0x8(%ebp),%eax
}
 8049786:	5d                   	pop    %ebp
 8049787:	c3                   	ret    

08049788 <_ZN4math6divideEjj>:

uint32_t divide(uint32_t op1, uint32_t op2) {
 8049788:	f3 0f 1e fb          	endbr32 
 804978c:	55                   	push   %ebp
	return op1 / op2;
 804978d:	31 d2                	xor    %edx,%edx
uint32_t divide(uint32_t op1, uint32_t op2) {
 804978f:	89 e5                	mov    %esp,%ebp
 8049791:	8b 45 08             	mov    0x8(%ebp),%eax
	return op1 / op2;
 8049794:	f7 75 0c             	divl   0xc(%ebp)
}
 8049797:	5d                   	pop    %ebp
 8049798:	c3                   	ret    

08049799 <_ZN4math8modulateEjj>:

uint32_t modulate(uint32_t op1, uint32_t op2) {
 8049799:	f3 0f 1e fb          	endbr32 
 804979d:	55                   	push   %ebp
	return op1 % op2;
 804979e:	31 d2                	xor    %edx,%edx
uint32_t modulate(uint32_t op1, uint32_t op2) {
 80497a0:	89 e5                	mov    %esp,%ebp
 80497a2:	8b 45 08             	mov    0x8(%ebp),%eax
	return op1 % op2;
 80497a5:	f7 75 0c             	divl   0xc(%ebp)
}
 80497a8:	5d                   	pop    %ebp
 80497a9:	89 d0                	mov    %edx,%eax
 80497ab:	c3                   	ret    

080497ac <_ZN4math5powerEjj>:

uint32_t power(uint32_t op1, uint32_t op2) {
 80497ac:	f3 0f 1e fb          	endbr32 
 80497b0:	55                   	push   %ebp
 80497b1:	89 e5                	mov    %esp,%ebp
	uint32_t val = 1;
	op2++;
 80497b3:	8b 45 0c             	mov    0xc(%ebp),%eax
 80497b6:	8d 50 01             	lea    0x1(%eax),%edx
	uint32_t val = 1;
 80497b9:	b8 01 00 00 00       	mov    $0x1,%eax
	while (--op2) {
 80497be:	4a                   	dec    %edx
 80497bf:	74 06                	je     80497c7 <_ZN4math5powerEjj+0x1b>
		val *= op1;
 80497c1:	0f af 45 08          	imul   0x8(%ebp),%eax
	while (--op2) {
 80497c5:	eb f7                	jmp    80497be <_ZN4math5powerEjj+0x12>
	}
	return val;
}
 80497c7:	5d                   	pop    %ebp
 80497c8:	c3                   	ret    

080497c9 <_ZN4math9factorialEj>:

uint32_t factorial(uint32_t op) {
 80497c9:	f3 0f 1e fb          	endbr32 
 80497cd:	55                   	push   %ebp
	return (op == 0 || op == 1) ? 1 : op * factorial(op-1);
 80497ce:	b8 01 00 00 00       	mov    $0x1,%eax
uint32_t factorial(uint32_t op) {
 80497d3:	89 e5                	mov    %esp,%ebp
 80497d5:	8b 55 08             	mov    0x8(%ebp),%edx
	return (op == 0 || op == 1) ? 1 : op * factorial(op-1);
 80497d8:	83 fa 01             	cmp    $0x1,%edx
 80497db:	76 06                	jbe    80497e3 <_ZN4math9factorialEj+0x1a>
 80497dd:	0f af c2             	imul   %edx,%eax
 80497e0:	4a                   	dec    %edx
 80497e1:	eb f5                	jmp    80497d8 <_ZN4math9factorialEj+0xf>
}
 80497e3:	5d                   	pop    %ebp
 80497e4:	c3                   	ret    

080497e5 <_ZN5mocks5writeEj>:

namespace {
uint32_t r_w_val = 0;
}

bool write(uint32_t val) {
 80497e5:	f3 0f 1e fb          	endbr32 
	if (r_w_val != 0) {
 80497e9:	83 3d 28 6a 05 08 00 	cmpl   $0x0,0x8056a28
 80497f0:	75 0f                	jne    8049801 <_ZN5mocks5writeEj+0x1c>
bool write(uint32_t val) {
 80497f2:	55                   	push   %ebp
 80497f3:	89 e5                	mov    %esp,%ebp
		return false;
	}
	r_w_val = val;
 80497f5:	8b 45 08             	mov    0x8(%ebp),%eax
	return true;
}
 80497f8:	5d                   	pop    %ebp
	r_w_val = val;
 80497f9:	a3 28 6a 05 08       	mov    %eax,0x8056a28
	return true;
 80497fe:	b0 01                	mov    $0x1,%al
}
 8049800:	c3                   	ret    
 8049801:	31 c0                	xor    %eax,%eax
 8049803:	c3                   	ret    

08049804 <_ZN5mocks4readEPj>:
bool read(uint32_t *val) {
 8049804:	f3 0f 1e fb          	endbr32 
 8049808:	55                   	push   %ebp
	if (r_w_val == 0) {
 8049809:	8b 0d 28 6a 05 08    	mov    0x8056a28,%ecx
 804980f:	31 c0                	xor    %eax,%eax
bool read(uint32_t *val) {
 8049811:	89 e5                	mov    %esp,%ebp
 8049813:	8b 55 08             	mov    0x8(%ebp),%edx
	if (r_w_val == 0) {
 8049816:	85 c9                	test   %ecx,%ecx
 8049818:	74 12                	je     804982c <_ZN5mocks4readEPj+0x28>
		return false;
	}
	if (val != nullptr) {
 804981a:	85 d2                	test   %edx,%edx
 804981c:	74 02                	je     8049820 <_ZN5mocks4readEPj+0x1c>
		*val = r_w_val;
 804981e:	89 0a                	mov    %ecx,(%edx)
	}
	r_w_val = 0;
 8049820:	c7 05 28 6a 05 08 00 	movl   $0x0,0x8056a28
 8049827:	00 00 00 
	return true;
 804982a:	b0 01                	mov    $0x1,%al
}
 804982c:	5d                   	pop    %ebp
 804982d:	c3                   	ret    

0804982e <z_zassert.constprop.0>:
#define z_zassert(cond, default_msg, file, line, func, msg, ...)	\
	z_zassert_(cond, file, line)

#else /* CONFIG_ZTEST_ASSERT_VERBOSE != 0 */

static inline bool z_zassert(bool cond,
 804982e:	55                   	push   %ebp
 804982f:	89 e5                	mov    %esp,%ebp
 8049831:	83 ec 14             	sub    $0x14,%esp
		ztest_test_fail();
		return false;
	}
#if CONFIG_ZTEST_ASSERT_VERBOSE == 2
	else {
		PRINT("\n   Assertion succeeded at %s:%d (%s)\n",
 8049834:	68 2c 13 05 08       	push   $0x805132c
 8049839:	e8 23 46 00 00       	call   804de61 <ztest_relative_filename>
 804983e:	83 c4 10             	add    $0x10,%esp
 8049841:	68 56 13 05 08       	push   $0x8051356
 8049846:	ff 75 14             	pushl  0x14(%ebp)
 8049849:	50                   	push   %eax
 804984a:	68 67 13 05 08       	push   $0x8051367
 804984f:	e8 47 0f 00 00       	call   804a79b <printk>
 8049854:	83 c4 10             	add    $0x10,%esp
		      ztest_relative_filename(file), line, func);
	}
#endif
	return true;
}
 8049857:	b0 01                	mov    $0x1,%al
 8049859:	c9                   	leave  
 804985a:	c3                   	ret    

0804985b <_ZL25_base_test_assert_wrapperPv>:
#include <ztest.h>

ZTEST_SUITE(base, NULL, NULL, NULL, NULL, NULL);

ZTEST(base, test_assert) {
 804985b:	f3 0f 1e fb          	endbr32 
 804985f:	55                   	push   %ebp
 8049860:	89 e5                	mov    %esp,%ebp
 8049862:	83 ec 10             	sub    $0x10,%esp
	zassert_true(true, "1 was false");
 8049865:	68 8e 13 05 08       	push   $0x805138e
 804986a:	68 56 13 05 08       	push   $0x8051356
 804986f:	6a 06                	push   $0x6
 8049871:	68 2c 13 05 08       	push   $0x805132c
 8049876:	68 9a 13 05 08       	push   $0x805139a
 804987b:	6a 01                	push   $0x1
 804987d:	e8 ac ff ff ff       	call   804982e <z_zassert.constprop.0>
 8049882:	83 c4 18             	add    $0x18,%esp
	zassert_false(false, "0 was true");
 8049885:	68 aa 13 05 08       	push   $0x80513aa
 804988a:	68 56 13 05 08       	push   $0x8051356
 804988f:	6a 07                	push   $0x7
 8049891:	68 2c 13 05 08       	push   $0x805132c
 8049896:	68 b5 13 05 08       	push   $0x80513b5
 804989b:	6a 01                	push   $0x1
 804989d:	e8 8c ff ff ff       	call   804982e <z_zassert.constprop.0>
 80498a2:	83 c4 18             	add    $0x18,%esp
	zassert_is_null(NULL, "NULL was not NULL");
 80498a5:	68 c5 13 05 08       	push   $0x80513c5
 80498aa:	68 56 13 05 08       	push   $0x8051356
 80498af:	6a 08                	push   $0x8
 80498b1:	68 2c 13 05 08       	push   $0x805132c
 80498b6:	68 d7 13 05 08       	push   $0x80513d7
 80498bb:	6a 01                	push   $0x1
 80498bd:	e8 6c ff ff ff       	call   804982e <z_zassert.constprop.0>
 80498c2:	83 c4 18             	add    $0x18,%esp
	zassert_not_null("foo", "\"foo\" was NULL");
 80498c5:	68 ea 13 05 08       	push   $0x80513ea
 80498ca:	68 56 13 05 08       	push   $0x8051356
 80498cf:	6a 09                	push   $0x9
 80498d1:	68 2c 13 05 08       	push   $0x805132c
 80498d6:	68 f9 13 05 08       	push   $0x80513f9
 80498db:	6a 01                	push   $0x1
 80498dd:	e8 4c ff ff ff       	call   804982e <z_zassert.constprop.0>
 80498e2:	83 c4 18             	add    $0x18,%esp
	zassert_equal(1, 1, "1 was not equal to 1");
 80498e5:	68 09 14 05 08       	push   $0x8051409
 80498ea:	68 56 13 05 08       	push   $0x8051356
 80498ef:	6a 0a                	push   $0xa
 80498f1:	68 2c 13 05 08       	push   $0x805132c
 80498f6:	68 1e 14 05 08       	push   $0x805141e
 80498fb:	6a 01                	push   $0x1
 80498fd:	e8 2c ff ff ff       	call   804982e <z_zassert.constprop.0>
 8049902:	83 c4 18             	add    $0x18,%esp
	zassert_equal_ptr(NULL, NULL, "NULL was not equal to NULL");
 8049905:	68 31 14 05 08       	push   $0x8051431
 804990a:	68 56 13 05 08       	push   $0x8051356
 804990f:	6a 0b                	push   $0xb
 8049911:	68 2c 13 05 08       	push   $0x805132c
 8049916:	68 4c 14 05 08       	push   $0x805144c
 804991b:	6a 01                	push   $0x1
 804991d:	e8 0c ff ff ff       	call   804982e <z_zassert.constprop.0>
 8049922:	83 c4 20             	add    $0x20,%esp
ZTEST(base, test_assert) {
 8049925:	c9                   	leave  
 8049926:	c3                   	ret    

08049927 <z_zassert.constprop.0>:
static inline bool z_zassert(bool cond,
 8049927:	55                   	push   %ebp
 8049928:	89 e5                	mov    %esp,%ebp
 804992a:	57                   	push   %edi
 804992b:	56                   	push   %esi
 804992c:	53                   	push   %ebx
 804992d:	83 ec 0c             	sub    $0xc,%esp
 8049930:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8049933:	8b 7d 18             	mov    0x18(%ebp),%edi
	if (cond == false) {
 8049936:	84 db                	test   %bl,%bl
 8049938:	75 45                	jne    804997f <z_zassert.constprop.0+0x58>
		PRINT("\n    Assertion failed at %s:%d: %s: %s\n",
 804993a:	83 ec 0c             	sub    $0xc,%esp
		va_start(vargs, msg);
 804993d:	8d 75 20             	lea    0x20(%ebp),%esi
		PRINT("\n    Assertion failed at %s:%d: %s: %s\n",
 8049940:	68 6a 14 05 08       	push   $0x805146a
 8049945:	e8 17 45 00 00       	call   804de61 <ztest_relative_filename>
 804994a:	5a                   	pop    %edx
 804994b:	ff 75 0c             	pushl  0xc(%ebp)
 804994e:	57                   	push   %edi
 804994f:	ff 75 14             	pushl  0x14(%ebp)
 8049952:	50                   	push   %eax
 8049953:	68 92 14 05 08       	push   $0x8051492
 8049958:	e8 3e 0e 00 00       	call   804a79b <printk>
 804995d:	83 c4 18             	add    $0x18,%esp
		vprintk(msg, vargs);
 8049960:	56                   	push   %esi
 8049961:	ff 75 1c             	pushl  0x1c(%ebp)
 8049964:	e8 ec 0d 00 00       	call   804a755 <vprintk>
		printk("\n");
 8049969:	c7 04 24 37 30 05 08 	movl   $0x8053037,(%esp)
 8049970:	e8 26 0e 00 00       	call   804a79b <printk>
 8049975:	83 c4 10             	add    $0x10,%esp
		ztest_test_fail();
 8049978:	e8 74 45 00 00       	call   804def1 <ztest_test_fail>
		return false;
 804997d:	eb 22                	jmp    80499a1 <z_zassert.constprop.0+0x7a>
		PRINT("\n   Assertion succeeded at %s:%d (%s)\n",
 804997f:	83 ec 0c             	sub    $0xc,%esp
 8049982:	68 6a 14 05 08       	push   $0x805146a
 8049987:	e8 d5 44 00 00       	call   804de61 <ztest_relative_filename>
 804998c:	83 c4 10             	add    $0x10,%esp
 804998f:	57                   	push   %edi
 8049990:	ff 75 14             	pushl  0x14(%ebp)
 8049993:	50                   	push   %eax
 8049994:	68 67 13 05 08       	push   $0x8051367
 8049999:	e8 fd 0d 00 00       	call   804a79b <printk>
 804999e:	83 c4 10             	add    $0x10,%esp
}
 80499a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80499a4:	89 d8                	mov    %ebx,%eax
 80499a6:	5b                   	pop    %ebx
 80499a7:	5e                   	pop    %esi
 80499a8:	5f                   	pop    %edi
 80499a9:	5d                   	pop    %ebp
 80499aa:	c3                   	ret    

080499ab <_ZL28_math_test_factorial_wrapperPv>:
	zassert_equal(math::power(3,0), 1, "3^0 != 1");
	zassert_equal(math::power(3,1), 3, "3^1 != 3");
	zassert_equal(math::power(3,3), 27, "3^3 != 27");
}

ZTEST(math, test_factorial) {
 80499ab:	f3 0f 1e fb          	endbr32 
 80499af:	55                   	push   %ebp
 80499b0:	89 e5                	mov    %esp,%ebp
 80499b2:	83 ec 14             	sub    $0x14,%esp
	zassert_equal(math::factorial(0), 1, "0! != 1");
 80499b5:	6a 00                	push   $0x0
 80499b7:	e8 0d fe ff ff       	call   80497c9 <_ZN4math9factorialEj>
 80499bc:	5a                   	pop    %edx
 80499bd:	59                   	pop    %ecx
 80499be:	68 ba 14 05 08       	push   $0x80514ba
 80499c3:	48                   	dec    %eax
 80499c4:	68 c2 14 05 08       	push   $0x80514c2
 80499c9:	0f 94 c0             	sete   %al
 80499cc:	6a 35                	push   $0x35
 80499ce:	0f b6 c0             	movzbl %al,%eax
 80499d1:	68 6a 14 05 08       	push   $0x805146a
 80499d6:	68 d6 14 05 08       	push   $0x80514d6
 80499db:	50                   	push   %eax
 80499dc:	e8 46 ff ff ff       	call   8049927 <z_zassert.constprop.0>
 80499e1:	83 c4 14             	add    $0x14,%esp
	zassert_equal(math::factorial(1), 1, "1! != 1");
 80499e4:	6a 01                	push   $0x1
 80499e6:	e8 de fd ff ff       	call   80497c9 <_ZN4math9factorialEj>
 80499eb:	5a                   	pop    %edx
 80499ec:	59                   	pop    %ecx
 80499ed:	68 fa 14 05 08       	push   $0x80514fa
 80499f2:	48                   	dec    %eax
 80499f3:	68 c2 14 05 08       	push   $0x80514c2
 80499f8:	0f 94 c0             	sete   %al
 80499fb:	6a 36                	push   $0x36
 80499fd:	0f b6 c0             	movzbl %al,%eax
 8049a00:	68 6a 14 05 08       	push   $0x805146a
 8049a05:	68 02 15 05 08       	push   $0x8051502
 8049a0a:	50                   	push   %eax
 8049a0b:	e8 17 ff ff ff       	call   8049927 <z_zassert.constprop.0>
 8049a10:	83 c4 14             	add    $0x14,%esp
	zassert_equal(math::factorial(2), 2, "2! != 2");
 8049a13:	6a 02                	push   $0x2
 8049a15:	e8 af fd ff ff       	call   80497c9 <_ZN4math9factorialEj>
 8049a1a:	5a                   	pop    %edx
 8049a1b:	59                   	pop    %ecx
 8049a1c:	68 26 15 05 08       	push   $0x8051526
 8049a21:	83 f8 02             	cmp    $0x2,%eax
 8049a24:	68 c2 14 05 08       	push   $0x80514c2
 8049a29:	0f 94 c0             	sete   %al
 8049a2c:	6a 37                	push   $0x37
 8049a2e:	0f b6 c0             	movzbl %al,%eax
 8049a31:	68 6a 14 05 08       	push   $0x805146a
 8049a36:	68 2e 15 05 08       	push   $0x805152e
 8049a3b:	50                   	push   %eax
 8049a3c:	e8 e6 fe ff ff       	call   8049927 <z_zassert.constprop.0>
 8049a41:	83 c4 14             	add    $0x14,%esp
	zassert_equal(math::factorial(3), 6, "3! != 6");
 8049a44:	6a 03                	push   $0x3
 8049a46:	e8 7e fd ff ff       	call   80497c9 <_ZN4math9factorialEj>
 8049a4b:	5a                   	pop    %edx
 8049a4c:	59                   	pop    %ecx
 8049a4d:	68 52 15 05 08       	push   $0x8051552
 8049a52:	83 f8 06             	cmp    $0x6,%eax
 8049a55:	68 c2 14 05 08       	push   $0x80514c2
 8049a5a:	0f 94 c0             	sete   %al
 8049a5d:	6a 38                	push   $0x38
 8049a5f:	0f b6 c0             	movzbl %al,%eax
 8049a62:	68 6a 14 05 08       	push   $0x805146a
 8049a67:	68 5a 15 05 08       	push   $0x805155a
 8049a6c:	50                   	push   %eax
 8049a6d:	e8 b5 fe ff ff       	call   8049927 <z_zassert.constprop.0>
 8049a72:	83 c4 14             	add    $0x14,%esp
	zassert_equal(math::factorial(8), 40320, "8! != 40320");
 8049a75:	6a 08                	push   $0x8
 8049a77:	e8 4d fd ff ff       	call   80497c9 <_ZN4math9factorialEj>
 8049a7c:	5a                   	pop    %edx
 8049a7d:	59                   	pop    %ecx
 8049a7e:	68 7e 15 05 08       	push   $0x805157e
 8049a83:	3d 80 9d 00 00       	cmp    $0x9d80,%eax
 8049a88:	68 c2 14 05 08       	push   $0x80514c2
 8049a8d:	0f 94 c0             	sete   %al
 8049a90:	6a 39                	push   $0x39
 8049a92:	0f b6 c0             	movzbl %al,%eax
 8049a95:	68 6a 14 05 08       	push   $0x805146a
 8049a9a:	68 8a 15 05 08       	push   $0x805158a
 8049a9f:	50                   	push   %eax
 8049aa0:	e8 82 fe ff ff       	call   8049927 <z_zassert.constprop.0>
 8049aa5:	83 c4 20             	add    $0x20,%esp
ZTEST(math, test_factorial) {
 8049aa8:	c9                   	leave  
 8049aa9:	c3                   	ret    

08049aaa <_ZL24_math_test_power_wrapperPv>:
ZTEST(math, test_power) {
 8049aaa:	f3 0f 1e fb          	endbr32 
 8049aae:	55                   	push   %ebp
 8049aaf:	89 e5                	mov    %esp,%ebp
 8049ab1:	83 ec 10             	sub    $0x10,%esp
	zassert_equal(math::power(0,1), 0, "0^1 != 0");
 8049ab4:	6a 01                	push   $0x1
 8049ab6:	6a 00                	push   $0x0
 8049ab8:	e8 ef fc ff ff       	call   80497ac <_ZN4math5powerEjj>
 8049abd:	5a                   	pop    %edx
 8049abe:	59                   	pop    %ecx
 8049abf:	68 b2 15 05 08       	push   $0x80515b2
 8049ac4:	85 c0                	test   %eax,%eax
 8049ac6:	68 bb 15 05 08       	push   $0x80515bb
 8049acb:	0f 94 c0             	sete   %al
 8049ace:	6a 2d                	push   $0x2d
 8049ad0:	0f b6 c0             	movzbl %al,%eax
 8049ad3:	68 6a 14 05 08       	push   $0x805146a
 8049ad8:	68 cb 15 05 08       	push   $0x80515cb
 8049add:	50                   	push   %eax
 8049ade:	e8 44 fe ff ff       	call   8049927 <z_zassert.constprop.0>
 8049ae3:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::power(1,0), 1, "1^0 != 1");
 8049ae6:	6a 00                	push   $0x0
 8049ae8:	6a 01                	push   $0x1
 8049aea:	e8 bd fc ff ff       	call   80497ac <_ZN4math5powerEjj>
 8049aef:	5a                   	pop    %edx
 8049af0:	59                   	pop    %ecx
 8049af1:	68 ed 15 05 08       	push   $0x80515ed
 8049af6:	48                   	dec    %eax
 8049af7:	68 bb 15 05 08       	push   $0x80515bb
 8049afc:	0f 94 c0             	sete   %al
 8049aff:	6a 2e                	push   $0x2e
 8049b01:	0f b6 c0             	movzbl %al,%eax
 8049b04:	68 6a 14 05 08       	push   $0x805146a
 8049b09:	68 f6 15 05 08       	push   $0x80515f6
 8049b0e:	50                   	push   %eax
 8049b0f:	e8 13 fe ff ff       	call   8049927 <z_zassert.constprop.0>
 8049b14:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::power(3,0), 1, "3^0 != 1");
 8049b17:	6a 00                	push   $0x0
 8049b19:	6a 03                	push   $0x3
 8049b1b:	e8 8c fc ff ff       	call   80497ac <_ZN4math5powerEjj>
 8049b20:	5a                   	pop    %edx
 8049b21:	59                   	pop    %ecx
 8049b22:	68 18 16 05 08       	push   $0x8051618
 8049b27:	48                   	dec    %eax
 8049b28:	68 bb 15 05 08       	push   $0x80515bb
 8049b2d:	0f 94 c0             	sete   %al
 8049b30:	6a 2f                	push   $0x2f
 8049b32:	0f b6 c0             	movzbl %al,%eax
 8049b35:	68 6a 14 05 08       	push   $0x805146a
 8049b3a:	68 21 16 05 08       	push   $0x8051621
 8049b3f:	50                   	push   %eax
 8049b40:	e8 e2 fd ff ff       	call   8049927 <z_zassert.constprop.0>
 8049b45:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::power(3,1), 3, "3^1 != 3");
 8049b48:	6a 01                	push   $0x1
 8049b4a:	6a 03                	push   $0x3
 8049b4c:	e8 5b fc ff ff       	call   80497ac <_ZN4math5powerEjj>
 8049b51:	5a                   	pop    %edx
 8049b52:	59                   	pop    %ecx
 8049b53:	68 43 16 05 08       	push   $0x8051643
 8049b58:	83 f8 03             	cmp    $0x3,%eax
 8049b5b:	68 bb 15 05 08       	push   $0x80515bb
 8049b60:	0f 94 c0             	sete   %al
 8049b63:	6a 30                	push   $0x30
 8049b65:	0f b6 c0             	movzbl %al,%eax
 8049b68:	68 6a 14 05 08       	push   $0x805146a
 8049b6d:	68 4c 16 05 08       	push   $0x805164c
 8049b72:	50                   	push   %eax
 8049b73:	e8 af fd ff ff       	call   8049927 <z_zassert.constprop.0>
 8049b78:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::power(3,3), 27, "3^3 != 27");
 8049b7b:	6a 03                	push   $0x3
 8049b7d:	6a 03                	push   $0x3
 8049b7f:	e8 28 fc ff ff       	call   80497ac <_ZN4math5powerEjj>
 8049b84:	5a                   	pop    %edx
 8049b85:	59                   	pop    %ecx
 8049b86:	68 6e 16 05 08       	push   $0x805166e
 8049b8b:	83 f8 1b             	cmp    $0x1b,%eax
 8049b8e:	68 bb 15 05 08       	push   $0x80515bb
 8049b93:	0f 94 c0             	sete   %al
 8049b96:	6a 31                	push   $0x31
 8049b98:	0f b6 c0             	movzbl %al,%eax
 8049b9b:	68 6a 14 05 08       	push   $0x805146a
 8049ba0:	68 78 16 05 08       	push   $0x8051678
 8049ba5:	50                   	push   %eax
 8049ba6:	e8 7c fd ff ff       	call   8049927 <z_zassert.constprop.0>
 8049bab:	83 c4 20             	add    $0x20,%esp
ZTEST(math, test_power) {
 8049bae:	c9                   	leave  
 8049baf:	c3                   	ret    

08049bb0 <_ZL27_math_test_modulate_wrapperPv>:
ZTEST(math, test_modulate) {
 8049bb0:	f3 0f 1e fb          	endbr32 
 8049bb4:	55                   	push   %ebp
 8049bb5:	89 e5                	mov    %esp,%ebp
 8049bb7:	83 ec 10             	sub    $0x10,%esp
	zassert_equal(math::modulate(0,1), 0, "0%1 != 0");
 8049bba:	6a 01                	push   $0x1
 8049bbc:	6a 00                	push   $0x0
 8049bbe:	e8 d6 fb ff ff       	call   8049799 <_ZN4math8modulateEjj>
 8049bc3:	5a                   	pop    %edx
 8049bc4:	59                   	pop    %ecx
 8049bc5:	68 9b 16 05 08       	push   $0x805169b
 8049bca:	85 c0                	test   %eax,%eax
 8049bcc:	68 a4 16 05 08       	push   $0x80516a4
 8049bd1:	0f 94 c0             	sete   %al
 8049bd4:	6a 26                	push   $0x26
 8049bd6:	0f b6 c0             	movzbl %al,%eax
 8049bd9:	68 6a 14 05 08       	push   $0x805146a
 8049bde:	68 b7 16 05 08       	push   $0x80516b7
 8049be3:	50                   	push   %eax
 8049be4:	e8 3e fd ff ff       	call   8049927 <z_zassert.constprop.0>
 8049be9:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::modulate(1,1), 0, "1%1 != 0");
 8049bec:	6a 01                	push   $0x1
 8049bee:	6a 01                	push   $0x1
 8049bf0:	e8 a4 fb ff ff       	call   8049799 <_ZN4math8modulateEjj>
 8049bf5:	5a                   	pop    %edx
 8049bf6:	59                   	pop    %ecx
 8049bf7:	68 dc 16 05 08       	push   $0x80516dc
 8049bfc:	85 c0                	test   %eax,%eax
 8049bfe:	68 a4 16 05 08       	push   $0x80516a4
 8049c03:	0f 94 c0             	sete   %al
 8049c06:	6a 27                	push   $0x27
 8049c08:	0f b6 c0             	movzbl %al,%eax
 8049c0b:	68 6a 14 05 08       	push   $0x805146a
 8049c10:	68 e5 16 05 08       	push   $0x80516e5
 8049c15:	50                   	push   %eax
 8049c16:	e8 0c fd ff ff       	call   8049927 <z_zassert.constprop.0>
 8049c1b:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::modulate(8,2), 0, "8%2 != 0");
 8049c1e:	6a 02                	push   $0x2
 8049c20:	6a 08                	push   $0x8
 8049c22:	e8 72 fb ff ff       	call   8049799 <_ZN4math8modulateEjj>
 8049c27:	5a                   	pop    %edx
 8049c28:	59                   	pop    %ecx
 8049c29:	68 0a 17 05 08       	push   $0x805170a
 8049c2e:	85 c0                	test   %eax,%eax
 8049c30:	68 a4 16 05 08       	push   $0x80516a4
 8049c35:	0f 94 c0             	sete   %al
 8049c38:	6a 28                	push   $0x28
 8049c3a:	0f b6 c0             	movzbl %al,%eax
 8049c3d:	68 6a 14 05 08       	push   $0x805146a
 8049c42:	68 13 17 05 08       	push   $0x8051713
 8049c47:	50                   	push   %eax
 8049c48:	e8 da fc ff ff       	call   8049927 <z_zassert.constprop.0>
 8049c4d:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::modulate(9,2), 1, "9%2 != 1");
 8049c50:	6a 02                	push   $0x2
 8049c52:	6a 09                	push   $0x9
 8049c54:	e8 40 fb ff ff       	call   8049799 <_ZN4math8modulateEjj>
 8049c59:	5a                   	pop    %edx
 8049c5a:	59                   	pop    %ecx
 8049c5b:	68 38 17 05 08       	push   $0x8051738
 8049c60:	48                   	dec    %eax
 8049c61:	68 a4 16 05 08       	push   $0x80516a4
 8049c66:	0f 94 c0             	sete   %al
 8049c69:	6a 29                	push   $0x29
 8049c6b:	0f b6 c0             	movzbl %al,%eax
 8049c6e:	68 6a 14 05 08       	push   $0x805146a
 8049c73:	68 41 17 05 08       	push   $0x8051741
 8049c78:	50                   	push   %eax
 8049c79:	e8 a9 fc ff ff       	call   8049927 <z_zassert.constprop.0>
 8049c7e:	83 c4 20             	add    $0x20,%esp
ZTEST(math, test_modulate) {
 8049c81:	c9                   	leave  
 8049c82:	c3                   	ret    

08049c83 <_ZL25_math_test_divide_wrapperPv>:
ZTEST(math, test_divide) {
 8049c83:	f3 0f 1e fb          	endbr32 
 8049c87:	55                   	push   %ebp
 8049c88:	89 e5                	mov    %esp,%ebp
 8049c8a:	83 ec 10             	sub    $0x10,%esp
	zassert_equal(math::divide(0,1), 0, "0/1 != 0");
 8049c8d:	6a 01                	push   $0x1
 8049c8f:	6a 00                	push   $0x0
 8049c91:	e8 f2 fa ff ff       	call   8049788 <_ZN4math6divideEjj>
 8049c96:	5a                   	pop    %edx
 8049c97:	59                   	pop    %ecx
 8049c98:	68 66 17 05 08       	push   $0x8051766
 8049c9d:	85 c0                	test   %eax,%eax
 8049c9f:	68 6f 17 05 08       	push   $0x805176f
 8049ca4:	0f 94 c0             	sete   %al
 8049ca7:	6a 1f                	push   $0x1f
 8049ca9:	0f b6 c0             	movzbl %al,%eax
 8049cac:	68 6a 14 05 08       	push   $0x805146a
 8049cb1:	68 80 17 05 08       	push   $0x8051780
 8049cb6:	50                   	push   %eax
 8049cb7:	e8 6b fc ff ff       	call   8049927 <z_zassert.constprop.0>
 8049cbc:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::divide(1,1), 1, "1/1 != 1");
 8049cbf:	6a 01                	push   $0x1
 8049cc1:	6a 01                	push   $0x1
 8049cc3:	e8 c0 fa ff ff       	call   8049788 <_ZN4math6divideEjj>
 8049cc8:	5a                   	pop    %edx
 8049cc9:	59                   	pop    %ecx
 8049cca:	68 a3 17 05 08       	push   $0x80517a3
 8049ccf:	48                   	dec    %eax
 8049cd0:	68 6f 17 05 08       	push   $0x805176f
 8049cd5:	0f 94 c0             	sete   %al
 8049cd8:	6a 20                	push   $0x20
 8049cda:	0f b6 c0             	movzbl %al,%eax
 8049cdd:	68 6a 14 05 08       	push   $0x805146a
 8049ce2:	68 ac 17 05 08       	push   $0x80517ac
 8049ce7:	50                   	push   %eax
 8049ce8:	e8 3a fc ff ff       	call   8049927 <z_zassert.constprop.0>
 8049ced:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::divide(8,2), 4, "8/2 != 4");
 8049cf0:	6a 02                	push   $0x2
 8049cf2:	6a 08                	push   $0x8
 8049cf4:	e8 8f fa ff ff       	call   8049788 <_ZN4math6divideEjj>
 8049cf9:	5a                   	pop    %edx
 8049cfa:	59                   	pop    %ecx
 8049cfb:	68 cf 17 05 08       	push   $0x80517cf
 8049d00:	83 f8 04             	cmp    $0x4,%eax
 8049d03:	68 6f 17 05 08       	push   $0x805176f
 8049d08:	0f 94 c0             	sete   %al
 8049d0b:	6a 21                	push   $0x21
 8049d0d:	0f b6 c0             	movzbl %al,%eax
 8049d10:	68 6a 14 05 08       	push   $0x805146a
 8049d15:	68 d8 17 05 08       	push   $0x80517d8
 8049d1a:	50                   	push   %eax
 8049d1b:	e8 07 fc ff ff       	call   8049927 <z_zassert.constprop.0>
 8049d20:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::divide(9,2), 4, "9/2 != 4");
 8049d23:	6a 02                	push   $0x2
 8049d25:	6a 09                	push   $0x9
 8049d27:	e8 5c fa ff ff       	call   8049788 <_ZN4math6divideEjj>
 8049d2c:	5a                   	pop    %edx
 8049d2d:	59                   	pop    %ecx
 8049d2e:	68 fb 17 05 08       	push   $0x80517fb
 8049d33:	83 f8 04             	cmp    $0x4,%eax
 8049d36:	68 6f 17 05 08       	push   $0x805176f
 8049d3b:	0f 94 c0             	sete   %al
 8049d3e:	6a 22                	push   $0x22
 8049d40:	0f b6 c0             	movzbl %al,%eax
 8049d43:	68 6a 14 05 08       	push   $0x805146a
 8049d48:	68 04 18 05 08       	push   $0x8051804
 8049d4d:	50                   	push   %eax
 8049d4e:	e8 d4 fb ff ff       	call   8049927 <z_zassert.constprop.0>
 8049d53:	83 c4 20             	add    $0x20,%esp
ZTEST(math, test_divide) {
 8049d56:	c9                   	leave  
 8049d57:	c3                   	ret    

08049d58 <_ZL27_math_test_multiply_wrapperPv>:
ZTEST(math, test_multiply) {
 8049d58:	f3 0f 1e fb          	endbr32 
 8049d5c:	55                   	push   %ebp
 8049d5d:	89 e5                	mov    %esp,%ebp
 8049d5f:	83 ec 10             	sub    $0x10,%esp
	zassert_equal(math::multiply(0,0), 0, "0*0 != 0");
 8049d62:	6a 00                	push   $0x0
 8049d64:	6a 00                	push   $0x0
 8049d66:	e8 0d fa ff ff       	call   8049778 <_ZN4math8multiplyEjj>
 8049d6b:	5a                   	pop    %edx
 8049d6c:	59                   	pop    %ecx
 8049d6d:	68 27 18 05 08       	push   $0x8051827
 8049d72:	85 c0                	test   %eax,%eax
 8049d74:	68 30 18 05 08       	push   $0x8051830
 8049d79:	0f 94 c0             	sete   %al
 8049d7c:	6a 17                	push   $0x17
 8049d7e:	0f b6 c0             	movzbl %al,%eax
 8049d81:	68 6a 14 05 08       	push   $0x805146a
 8049d86:	68 43 18 05 08       	push   $0x8051843
 8049d8b:	50                   	push   %eax
 8049d8c:	e8 96 fb ff ff       	call   8049927 <z_zassert.constprop.0>
 8049d91:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::multiply(1,0), 0, "1*0 != 0");
 8049d94:	6a 00                	push   $0x0
 8049d96:	6a 01                	push   $0x1
 8049d98:	e8 db f9 ff ff       	call   8049778 <_ZN4math8multiplyEjj>
 8049d9d:	5a                   	pop    %edx
 8049d9e:	59                   	pop    %ecx
 8049d9f:	68 68 18 05 08       	push   $0x8051868
 8049da4:	85 c0                	test   %eax,%eax
 8049da6:	68 30 18 05 08       	push   $0x8051830
 8049dab:	0f 94 c0             	sete   %al
 8049dae:	6a 18                	push   $0x18
 8049db0:	0f b6 c0             	movzbl %al,%eax
 8049db3:	68 6a 14 05 08       	push   $0x805146a
 8049db8:	68 71 18 05 08       	push   $0x8051871
 8049dbd:	50                   	push   %eax
 8049dbe:	e8 64 fb ff ff       	call   8049927 <z_zassert.constprop.0>
 8049dc3:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::multiply(1,1), 1, "1*1 != 1");
 8049dc6:	6a 01                	push   $0x1
 8049dc8:	6a 01                	push   $0x1
 8049dca:	e8 a9 f9 ff ff       	call   8049778 <_ZN4math8multiplyEjj>
 8049dcf:	5a                   	pop    %edx
 8049dd0:	59                   	pop    %ecx
 8049dd1:	68 96 18 05 08       	push   $0x8051896
 8049dd6:	48                   	dec    %eax
 8049dd7:	68 30 18 05 08       	push   $0x8051830
 8049ddc:	0f 94 c0             	sete   %al
 8049ddf:	6a 19                	push   $0x19
 8049de1:	0f b6 c0             	movzbl %al,%eax
 8049de4:	68 6a 14 05 08       	push   $0x805146a
 8049de9:	68 9f 18 05 08       	push   $0x805189f
 8049dee:	50                   	push   %eax
 8049def:	e8 33 fb ff ff       	call   8049927 <z_zassert.constprop.0>
 8049df4:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::multiply(8,2), 16, "8*2 != 16");
 8049df7:	6a 02                	push   $0x2
 8049df9:	6a 08                	push   $0x8
 8049dfb:	e8 78 f9 ff ff       	call   8049778 <_ZN4math8multiplyEjj>
 8049e00:	5a                   	pop    %edx
 8049e01:	59                   	pop    %ecx
 8049e02:	68 c4 18 05 08       	push   $0x80518c4
 8049e07:	83 f8 10             	cmp    $0x10,%eax
 8049e0a:	68 30 18 05 08       	push   $0x8051830
 8049e0f:	0f 94 c0             	sete   %al
 8049e12:	6a 1a                	push   $0x1a
 8049e14:	0f b6 c0             	movzbl %al,%eax
 8049e17:	68 6a 14 05 08       	push   $0x805146a
 8049e1c:	68 ce 18 05 08       	push   $0x80518ce
 8049e21:	50                   	push   %eax
 8049e22:	e8 00 fb ff ff       	call   8049927 <z_zassert.constprop.0>
 8049e27:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::multiply(2,8), 16, "2*8 != 16");
 8049e2a:	6a 08                	push   $0x8
 8049e2c:	6a 02                	push   $0x2
 8049e2e:	e8 45 f9 ff ff       	call   8049778 <_ZN4math8multiplyEjj>
 8049e33:	5a                   	pop    %edx
 8049e34:	59                   	pop    %ecx
 8049e35:	68 f4 18 05 08       	push   $0x80518f4
 8049e3a:	83 f8 10             	cmp    $0x10,%eax
 8049e3d:	68 30 18 05 08       	push   $0x8051830
 8049e42:	0f 94 c0             	sete   %al
 8049e45:	6a 1b                	push   $0x1b
 8049e47:	0f b6 c0             	movzbl %al,%eax
 8049e4a:	68 6a 14 05 08       	push   $0x805146a
 8049e4f:	68 fe 18 05 08       	push   $0x80518fe
 8049e54:	50                   	push   %eax
 8049e55:	e8 cd fa ff ff       	call   8049927 <z_zassert.constprop.0>
 8049e5a:	83 c4 20             	add    $0x20,%esp
ZTEST(math, test_multiply) {
 8049e5d:	c9                   	leave  
 8049e5e:	c3                   	ret    

08049e5f <_ZL27_math_test_subtract_wrapperPv>:
ZTEST(math, test_subtract) {
 8049e5f:	f3 0f 1e fb          	endbr32 
 8049e63:	55                   	push   %ebp
 8049e64:	89 e5                	mov    %esp,%ebp
 8049e66:	83 ec 10             	sub    $0x10,%esp
	zassert_equal(math::subtract(0,0), 0, "0-0 != 0");
 8049e69:	6a 00                	push   $0x0
 8049e6b:	6a 00                	push   $0x0
 8049e6d:	e8 f7 f8 ff ff       	call   8049769 <_ZN4math8subtractEjj>
 8049e72:	5a                   	pop    %edx
 8049e73:	59                   	pop    %ecx
 8049e74:	68 24 19 05 08       	push   $0x8051924
 8049e79:	85 c0                	test   %eax,%eax
 8049e7b:	68 2d 19 05 08       	push   $0x805192d
 8049e80:	0f 94 c0             	sete   %al
 8049e83:	6a 10                	push   $0x10
 8049e85:	0f b6 c0             	movzbl %al,%eax
 8049e88:	68 6a 14 05 08       	push   $0x805146a
 8049e8d:	68 40 19 05 08       	push   $0x8051940
 8049e92:	50                   	push   %eax
 8049e93:	e8 8f fa ff ff       	call   8049927 <z_zassert.constprop.0>
 8049e98:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::subtract(1,0), 1, "1-0 != 1");
 8049e9b:	6a 00                	push   $0x0
 8049e9d:	6a 01                	push   $0x1
 8049e9f:	e8 c5 f8 ff ff       	call   8049769 <_ZN4math8subtractEjj>
 8049ea4:	5a                   	pop    %edx
 8049ea5:	59                   	pop    %ecx
 8049ea6:	68 65 19 05 08       	push   $0x8051965
 8049eab:	48                   	dec    %eax
 8049eac:	68 2d 19 05 08       	push   $0x805192d
 8049eb1:	0f 94 c0             	sete   %al
 8049eb4:	6a 11                	push   $0x11
 8049eb6:	0f b6 c0             	movzbl %al,%eax
 8049eb9:	68 6a 14 05 08       	push   $0x805146a
 8049ebe:	68 6e 19 05 08       	push   $0x805196e
 8049ec3:	50                   	push   %eax
 8049ec4:	e8 5e fa ff ff       	call   8049927 <z_zassert.constprop.0>
 8049ec9:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::subtract(1,1), 0, "1-1 != 0");
 8049ecc:	6a 01                	push   $0x1
 8049ece:	6a 01                	push   $0x1
 8049ed0:	e8 94 f8 ff ff       	call   8049769 <_ZN4math8subtractEjj>
 8049ed5:	5a                   	pop    %edx
 8049ed6:	59                   	pop    %ecx
 8049ed7:	68 93 19 05 08       	push   $0x8051993
 8049edc:	85 c0                	test   %eax,%eax
 8049ede:	68 2d 19 05 08       	push   $0x805192d
 8049ee3:	0f 94 c0             	sete   %al
 8049ee6:	6a 12                	push   $0x12
 8049ee8:	0f b6 c0             	movzbl %al,%eax
 8049eeb:	68 6a 14 05 08       	push   $0x805146a
 8049ef0:	68 9c 19 05 08       	push   $0x805199c
 8049ef5:	50                   	push   %eax
 8049ef6:	e8 2c fa ff ff       	call   8049927 <z_zassert.constprop.0>
 8049efb:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::subtract(8,2), 6, "8-2 != 6");
 8049efe:	6a 02                	push   $0x2
 8049f00:	6a 08                	push   $0x8
 8049f02:	e8 62 f8 ff ff       	call   8049769 <_ZN4math8subtractEjj>
 8049f07:	5a                   	pop    %edx
 8049f08:	59                   	pop    %ecx
 8049f09:	68 c1 19 05 08       	push   $0x80519c1
 8049f0e:	83 f8 06             	cmp    $0x6,%eax
 8049f11:	68 2d 19 05 08       	push   $0x805192d
 8049f16:	0f 94 c0             	sete   %al
 8049f19:	6a 13                	push   $0x13
 8049f1b:	0f b6 c0             	movzbl %al,%eax
 8049f1e:	68 6a 14 05 08       	push   $0x805146a
 8049f23:	68 ca 19 05 08       	push   $0x80519ca
 8049f28:	50                   	push   %eax
 8049f29:	e8 f9 f9 ff ff       	call   8049927 <z_zassert.constprop.0>
 8049f2e:	83 c4 20             	add    $0x20,%esp
ZTEST(math, test_subtract) {
 8049f31:	c9                   	leave  
 8049f32:	c3                   	ret    

08049f33 <_ZL22_math_test_add_wrapperPv>:
ZTEST(math, test_add) {
 8049f33:	f3 0f 1e fb          	endbr32 
 8049f37:	55                   	push   %ebp
 8049f38:	89 e5                	mov    %esp,%ebp
 8049f3a:	83 ec 10             	sub    $0x10,%esp
	zassert_equal(math::add(0,0), 0, "0+0 != 0");
 8049f3d:	6a 00                	push   $0x0
 8049f3f:	6a 00                	push   $0x0
 8049f41:	e8 14 f8 ff ff       	call   804975a <_ZN4math3addEjj>
 8049f46:	5a                   	pop    %edx
 8049f47:	59                   	pop    %ecx
 8049f48:	68 ef 19 05 08       	push   $0x80519ef
 8049f4d:	85 c0                	test   %eax,%eax
 8049f4f:	68 f8 19 05 08       	push   $0x80519f8
 8049f54:	0f 94 c0             	sete   %al
 8049f57:	6a 08                	push   $0x8
 8049f59:	0f b6 c0             	movzbl %al,%eax
 8049f5c:	68 6a 14 05 08       	push   $0x805146a
 8049f61:	68 06 1a 05 08       	push   $0x8051a06
 8049f66:	50                   	push   %eax
 8049f67:	e8 bb f9 ff ff       	call   8049927 <z_zassert.constprop.0>
 8049f6c:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::add(1,0), 1, "1+0 != 1");
 8049f6f:	6a 00                	push   $0x0
 8049f71:	6a 01                	push   $0x1
 8049f73:	e8 e2 f7 ff ff       	call   804975a <_ZN4math3addEjj>
 8049f78:	5a                   	pop    %edx
 8049f79:	59                   	pop    %ecx
 8049f7a:	68 26 1a 05 08       	push   $0x8051a26
 8049f7f:	48                   	dec    %eax
 8049f80:	68 f8 19 05 08       	push   $0x80519f8
 8049f85:	0f 94 c0             	sete   %al
 8049f88:	6a 09                	push   $0x9
 8049f8a:	0f b6 c0             	movzbl %al,%eax
 8049f8d:	68 6a 14 05 08       	push   $0x805146a
 8049f92:	68 2f 1a 05 08       	push   $0x8051a2f
 8049f97:	50                   	push   %eax
 8049f98:	e8 8a f9 ff ff       	call   8049927 <z_zassert.constprop.0>
 8049f9d:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::add(1,1), 2, "1+1 != 2");
 8049fa0:	6a 01                	push   $0x1
 8049fa2:	6a 01                	push   $0x1
 8049fa4:	e8 b1 f7 ff ff       	call   804975a <_ZN4math3addEjj>
 8049fa9:	5a                   	pop    %edx
 8049faa:	59                   	pop    %ecx
 8049fab:	68 4f 1a 05 08       	push   $0x8051a4f
 8049fb0:	83 f8 02             	cmp    $0x2,%eax
 8049fb3:	68 f8 19 05 08       	push   $0x80519f8
 8049fb8:	0f 94 c0             	sete   %al
 8049fbb:	6a 0a                	push   $0xa
 8049fbd:	0f b6 c0             	movzbl %al,%eax
 8049fc0:	68 6a 14 05 08       	push   $0x805146a
 8049fc5:	68 58 1a 05 08       	push   $0x8051a58
 8049fca:	50                   	push   %eax
 8049fcb:	e8 57 f9 ff ff       	call   8049927 <z_zassert.constprop.0>
 8049fd0:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::add(2,8), 10, "2+8 != 10");
 8049fd3:	6a 08                	push   $0x8
 8049fd5:	6a 02                	push   $0x2
 8049fd7:	e8 7e f7 ff ff       	call   804975a <_ZN4math3addEjj>
 8049fdc:	5a                   	pop    %edx
 8049fdd:	59                   	pop    %ecx
 8049fde:	68 78 1a 05 08       	push   $0x8051a78
 8049fe3:	83 f8 0a             	cmp    $0xa,%eax
 8049fe6:	68 f8 19 05 08       	push   $0x80519f8
 8049feb:	0f 94 c0             	sete   %al
 8049fee:	6a 0b                	push   $0xb
 8049ff0:	0f b6 c0             	movzbl %al,%eax
 8049ff3:	68 6a 14 05 08       	push   $0x805146a
 8049ff8:	68 82 1a 05 08       	push   $0x8051a82
 8049ffd:	50                   	push   %eax
 8049ffe:	e8 24 f9 ff ff       	call   8049927 <z_zassert.constprop.0>
 804a003:	83 c4 18             	add    $0x18,%esp
	zassert_equal(math::add(8,2), 10, "8+2 != 10");
 804a006:	6a 02                	push   $0x2
 804a008:	6a 08                	push   $0x8
 804a00a:	e8 4b f7 ff ff       	call   804975a <_ZN4math3addEjj>
 804a00f:	5a                   	pop    %edx
 804a010:	59                   	pop    %ecx
 804a011:	68 a3 1a 05 08       	push   $0x8051aa3
 804a016:	83 f8 0a             	cmp    $0xa,%eax
 804a019:	68 f8 19 05 08       	push   $0x80519f8
 804a01e:	0f 94 c0             	sete   %al
 804a021:	6a 0c                	push   $0xc
 804a023:	0f b6 c0             	movzbl %al,%eax
 804a026:	68 6a 14 05 08       	push   $0x805146a
 804a02b:	68 ad 1a 05 08       	push   $0x8051aad
 804a030:	50                   	push   %eax
 804a031:	e8 f1 f8 ff ff       	call   8049927 <z_zassert.constprop.0>
 804a036:	83 c4 20             	add    $0x20,%esp
ZTEST(math, test_add) {
 804a039:	c9                   	leave  
 804a03a:	c3                   	ret    

0804a03b <z_zassert.constprop.0>:
static inline bool z_zassert(bool cond,
 804a03b:	55                   	push   %ebp
 804a03c:	89 e5                	mov    %esp,%ebp
 804a03e:	57                   	push   %edi
 804a03f:	56                   	push   %esi
 804a040:	53                   	push   %ebx
 804a041:	83 ec 0c             	sub    $0xc,%esp
 804a044:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804a047:	8b 75 14             	mov    0x14(%ebp),%esi
	if (cond == false) {
 804a04a:	84 db                	test   %bl,%bl
 804a04c:	75 47                	jne    804a095 <z_zassert.constprop.0+0x5a>
		PRINT("\n    Assertion failed at %s:%d: %s: %s\n",
 804a04e:	83 ec 0c             	sub    $0xc,%esp
		va_start(vargs, msg);
 804a051:	8d 7d 20             	lea    0x20(%ebp),%edi
		PRINT("\n    Assertion failed at %s:%d: %s: %s\n",
 804a054:	68 d3 1a 05 08       	push   $0x8051ad3
 804a059:	e8 03 3e 00 00       	call   804de61 <ztest_relative_filename>
 804a05e:	5a                   	pop    %edx
 804a05f:	ff 75 0c             	pushl  0xc(%ebp)
 804a062:	68 fb 1a 05 08       	push   $0x8051afb
 804a067:	56                   	push   %esi
 804a068:	50                   	push   %eax
 804a069:	68 92 14 05 08       	push   $0x8051492
 804a06e:	e8 28 07 00 00       	call   804a79b <printk>
 804a073:	83 c4 18             	add    $0x18,%esp
		vprintk(msg, vargs);
 804a076:	57                   	push   %edi
 804a077:	ff 75 1c             	pushl  0x1c(%ebp)
 804a07a:	e8 d6 06 00 00       	call   804a755 <vprintk>
		printk("\n");
 804a07f:	c7 04 24 37 30 05 08 	movl   $0x8053037,(%esp)
 804a086:	e8 10 07 00 00       	call   804a79b <printk>
 804a08b:	83 c4 10             	add    $0x10,%esp
		ztest_test_fail();
 804a08e:	e8 5e 3e 00 00       	call   804def1 <ztest_test_fail>
		return false;
 804a093:	eb 24                	jmp    804a0b9 <z_zassert.constprop.0+0x7e>
		PRINT("\n   Assertion succeeded at %s:%d (%s)\n",
 804a095:	83 ec 0c             	sub    $0xc,%esp
 804a098:	68 d3 1a 05 08       	push   $0x8051ad3
 804a09d:	e8 bf 3d 00 00       	call   804de61 <ztest_relative_filename>
 804a0a2:	83 c4 10             	add    $0x10,%esp
 804a0a5:	68 fb 1a 05 08       	push   $0x8051afb
 804a0aa:	56                   	push   %esi
 804a0ab:	50                   	push   %eax
 804a0ac:	68 67 13 05 08       	push   $0x8051367
 804a0b1:	e8 e5 06 00 00       	call   804a79b <printk>
 804a0b6:	83 c4 10             	add    $0x10,%esp
}
 804a0b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a0bc:	89 d8                	mov    %ebx,%eax
 804a0be:	5b                   	pop    %ebx
 804a0bf:	5e                   	pop    %esi
 804a0c0:	5f                   	pop    %edi
 804a0c1:	5d                   	pop    %ebp
 804a0c2:	c3                   	ret    

0804a0c3 <_ZL24_mock_test_stuff_wrapperPv>:

#include "mock.hpp"

ZTEST_SUITE(mock, NULL, NULL, NULL, NULL, NULL);

ZTEST(mock, test_stuff) {
 804a0c3:	f3 0f 1e fb          	endbr32 
 804a0c7:	55                   	push   %ebp
 804a0c8:	89 e5                	mov    %esp,%ebp
 804a0ca:	53                   	push   %ebx
	uint32_t data = 0;
	zassert_false(mocks::read(&data), "data to read");
 804a0cb:	8d 5d f0             	lea    -0x10(%ebp),%ebx
ZTEST(mock, test_stuff) {
 804a0ce:	83 ec 20             	sub    $0x20,%esp
 804a0d1:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a0d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a0da:	31 c0                	xor    %eax,%eax
	zassert_false(mocks::read(&data), "data to read");
 804a0dc:	53                   	push   %ebx
	uint32_t data = 0;
 804a0dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	zassert_false(mocks::read(&data), "data to read");
 804a0e4:	e8 1b f7 ff ff       	call   8049804 <_ZN5mocks4readEPj>
 804a0e9:	5a                   	pop    %edx
 804a0ea:	59                   	pop    %ecx
 804a0eb:	68 0b 1b 05 08       	push   $0x8051b0b
 804a0f0:	83 f0 01             	xor    $0x1,%eax
 804a0f3:	68 fb 1a 05 08       	push   $0x8051afb
 804a0f8:	0f b6 c0             	movzbl %al,%eax
 804a0fb:	6a 09                	push   $0x9
 804a0fd:	68 d3 1a 05 08       	push   $0x8051ad3
 804a102:	68 18 1b 05 08       	push   $0x8051b18
 804a107:	50                   	push   %eax
 804a108:	e8 2e ff ff ff       	call   804a03b <z_zassert.constprop.0>
 804a10d:	83 c4 14             	add    $0x14,%esp
	zassert_true(mocks::write(12), "data already written");
 804a110:	6a 0c                	push   $0xc
 804a112:	e8 ce f6 ff ff       	call   80497e5 <_ZN5mocks5writeEj>
 804a117:	5a                   	pop    %edx
 804a118:	59                   	pop    %ecx
 804a119:	68 35 1b 05 08       	push   $0x8051b35
 804a11e:	0f b6 c0             	movzbl %al,%eax
 804a121:	68 fb 1a 05 08       	push   $0x8051afb
 804a126:	6a 0a                	push   $0xa
 804a128:	68 d3 1a 05 08       	push   $0x8051ad3
 804a12d:	68 4a 1b 05 08       	push   $0x8051b4a
 804a132:	50                   	push   %eax
 804a133:	e8 03 ff ff ff       	call   804a03b <z_zassert.constprop.0>
 804a138:	83 c4 14             	add    $0x14,%esp
	zassert_false(mocks::write(14), "data overwritten");
 804a13b:	6a 0e                	push   $0xe
 804a13d:	e8 a3 f6 ff ff       	call   80497e5 <_ZN5mocks5writeEj>
 804a142:	5a                   	pop    %edx
 804a143:	59                   	pop    %ecx
 804a144:	68 66 1b 05 08       	push   $0x8051b66
 804a149:	83 f0 01             	xor    $0x1,%eax
 804a14c:	68 fb 1a 05 08       	push   $0x8051afb
 804a151:	0f b6 c0             	movzbl %al,%eax
 804a154:	6a 0b                	push   $0xb
 804a156:	68 d3 1a 05 08       	push   $0x8051ad3
 804a15b:	68 77 1b 05 08       	push   $0x8051b77
 804a160:	50                   	push   %eax
 804a161:	e8 d5 fe ff ff       	call   804a03b <z_zassert.constprop.0>
 804a166:	83 c4 14             	add    $0x14,%esp
	zassert_true(mocks::read(&data), "data can't be read");
 804a169:	53                   	push   %ebx
 804a16a:	e8 95 f6 ff ff       	call   8049804 <_ZN5mocks4readEPj>
 804a16f:	5a                   	pop    %edx
 804a170:	59                   	pop    %ecx
 804a171:	68 92 1b 05 08       	push   $0x8051b92
 804a176:	0f b6 c0             	movzbl %al,%eax
 804a179:	68 fb 1a 05 08       	push   $0x8051afb
 804a17e:	6a 0c                	push   $0xc
 804a180:	68 d3 1a 05 08       	push   $0x8051ad3
 804a185:	68 a5 1b 05 08       	push   $0x8051ba5
 804a18a:	50                   	push   %eax
 804a18b:	e8 ab fe ff ff       	call   804a03b <z_zassert.constprop.0>
 804a190:	83 c4 18             	add    $0x18,%esp
	zassert_equal(data, 12, "data incorrect");
 804a193:	31 c0                	xor    %eax,%eax
 804a195:	83 7d f0 0c          	cmpl   $0xc,-0x10(%ebp)
 804a199:	0f 94 c0             	sete   %al
 804a19c:	68 c3 1b 05 08       	push   $0x8051bc3
 804a1a1:	68 fb 1a 05 08       	push   $0x8051afb
 804a1a6:	6a 0d                	push   $0xd
 804a1a8:	68 d3 1a 05 08       	push   $0x8051ad3
 804a1ad:	68 d2 1b 05 08       	push   $0x8051bd2
 804a1b2:	50                   	push   %eax
 804a1b3:	e8 83 fe ff ff       	call   804a03b <z_zassert.constprop.0>
 804a1b8:	83 c4 14             	add    $0x14,%esp
	zassert_false(mocks::read(&data), "data to read");
 804a1bb:	53                   	push   %ebx
 804a1bc:	e8 43 f6 ff ff       	call   8049804 <_ZN5mocks4readEPj>
 804a1c1:	5b                   	pop    %ebx
 804a1c2:	5a                   	pop    %edx
 804a1c3:	68 0b 1b 05 08       	push   $0x8051b0b
 804a1c8:	83 f0 01             	xor    $0x1,%eax
 804a1cb:	68 fb 1a 05 08       	push   $0x8051afb
 804a1d0:	0f b6 c0             	movzbl %al,%eax
 804a1d3:	6a 0e                	push   $0xe
 804a1d5:	68 d3 1a 05 08       	push   $0x8051ad3
 804a1da:	68 18 1b 05 08       	push   $0x8051b18
 804a1df:	50                   	push   %eax
 804a1e0:	e8 56 fe ff ff       	call   804a03b <z_zassert.constprop.0>
 804a1e5:	83 c4 20             	add    $0x20,%esp
ZTEST(mock, test_stuff) {
 804a1e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a1eb:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804a1f2:	74 05                	je     804a1f9 <_ZL24_mock_test_stuff_wrapperPv+0x136>
 804a1f4:	e8 c7 f1 ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804a1f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804a1fc:	c9                   	leave  
 804a1fd:	c3                   	ret    

0804a1fe <cbvprintf_package>:
	return cb(str, strl, ctx);
}

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
 804a1fe:	f3 0f 1e fb          	endbr32 
 804a202:	55                   	push   %ebp
 804a203:	89 e5                	mov    %esp,%ebp
 804a205:	57                   	push   %edi
 804a206:	56                   	push   %esi
 804a207:	53                   	push   %ebx
 804a208:	83 ec 5c             	sub    $0x5c,%esp
 804a20b:	8b 45 14             	mov    0x14(%ebp),%eax
	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
	/* Get number of first read only strings present in the string.
	 * There is always at least 1 (fmt) but flags can indicate more, e.g
	 * fixed prefix appended to all strings.
	 */
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 804a20e:	8b 4d 10             	mov    0x10(%ebp),%ecx
{
 804a211:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804a214:	8b 55 18             	mov    0x18(%ebp),%edx
 804a217:	89 45 b8             	mov    %eax,-0x48(%ebp)
 804a21a:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a220:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804a223:	31 c0                	xor    %eax,%eax
	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
 804a225:	8b 45 10             	mov    0x10(%ebp),%eax
 804a228:	83 e0 04             	and    $0x4,%eax
 804a22b:	0f 95 45 9f          	setne  -0x61(%ebp)
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 804a22f:	c1 e9 03             	shr    $0x3,%ecx
 804a232:	83 e1 07             	and    $0x7,%ecx
	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
 804a235:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 804a238:	8d 41 01             	lea    0x1(%ecx),%eax

	/* Buffer must be aligned at least to size of a pointer. */
	if ((uintptr_t)packaged % sizeof(void *)) {
		return -EFAULT;
 804a23b:	b9 f2 ff ff ff       	mov    $0xfffffff2,%ecx
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 804a240:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	if ((uintptr_t)packaged % sizeof(void *)) {
 804a243:	f6 c3 03             	test   $0x3,%bl
 804a246:	0f 85 33 04 00 00    	jne    804a67f <cbvprintf_package+0x481>
	 *
	 * Given the next value to store is the format string pointer
	 * which is guaranteed to be at least 4 bytes, we just reserve
	 * a pointer size for the above to preserve alignment.
	 */
	buf += sizeof(char *);
 804a24c:	8d 43 04             	lea    0x4(%ebx),%eax
 804a24f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
 804a252:	85 db                	test   %ebx,%ebx
 804a254:	0f 85 16 04 00 00    	jne    804a670 <cbvprintf_package+0x472>
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
 804a25a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
		 * the total as this won't be part of the buffer. To avoid
		 * going negative with an unsigned variable, we add an offset
		 * (CBPRINTF_PACKAGE_ALIGNMENT) that will be removed before
		 * returning.
		 */
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
 804a25d:	be 08 00 00 00       	mov    $0x8,%esi
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
 804a262:	83 e1 07             	and    $0x7,%ecx
 804a265:	8d 41 04             	lea    0x4(%ecx),%eax
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
 804a268:	29 ce                	sub    %ecx,%esi
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
 804a26a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
 804a26d:	89 75 0c             	mov    %esi,0xc(%ebp)
	 * Here we branch directly into the code processing strings
	 * which is in the middle of the following while() loop. That's the
	 * reason for the post-decrement on fmt as it will be incremented
	 * prior to the next (actually first) round of that loop.
	 */
	s = fmt--;
 804a270:	8b 45 b8             	mov    -0x48(%ebp),%eax
	unsigned int s_ro_cnt = 0; /* number of ro strings */
 804a273:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
	unsigned int s_rw_cnt = 0; /* number of rw strings */
 804a27a:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
	s = fmt--;
 804a281:	48                   	dec    %eax
	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
 804a282:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	s = fmt--;
 804a289:	89 45 b0             	mov    %eax,-0x50(%ebp)
	bool parsing = false;
 804a28c:	c6 45 bc 00          	movb   $0x0,-0x44(%ebp)
	align = VA_STACK_ALIGN(char *);
	size = sizeof(char *);
 804a290:	c7 45 c0 04 00 00 00 	movl   $0x4,-0x40(%ebp)

		/* copy va_list data over to our buffer */
		if (*fmt == 's') {
			s = va_arg(ap, char *);
process_string:
			if (buf0 != NULL) {
 804a297:	85 db                	test   %ebx,%ebx
 804a299:	74 08                	je     804a2a3 <cbvprintf_package+0xa5>
				*(const char **)buf = s;
 804a29b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804a29e:	8b 7d b8             	mov    -0x48(%ebp),%edi
 804a2a1:	89 38                	mov    %edi,(%eax)
			}

			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);

			if (is_ro && !do_ro) {
 804a2a3:	8b 7d 10             	mov    0x10(%ebp),%edi
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 804a2a6:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
 804a2aa:	0f 9f c1             	setg   %cl
			if (is_ro && !do_ro) {
 804a2ad:	83 e7 02             	and    $0x2,%edi
 804a2b0:	75 08                	jne    804a2ba <cbvprintf_package+0xbc>
 804a2b2:	84 c9                	test   %cl,%cl
 804a2b4:	0f 85 d4 00 00 00    	jne    804a38e <cbvprintf_package+0x190>
				/* nothing to do */
			} else {
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 804a2ba:	8b 75 c4             	mov    -0x3c(%ebp),%esi
 804a2bd:	29 de                	sub    %ebx,%esi
				 * In the do_ro case we must consider
				 * room for possible STR_POS_RO_FLAG.
				 * Otherwise the index range is 8 bits
				 * and any overflow is caught later.
				 */
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 804a2bf:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
 804a2c5:	76 32                	jbe    804a2f9 <cbvprintf_package+0xfb>
 804a2c7:	85 ff                	test   %edi,%edi
 804a2c9:	74 2e                	je     804a2f9 <cbvprintf_package+0xfb>
					__ASSERT(false, "String with too many arguments");
 804a2cb:	68 e5 01 00 00       	push   $0x1e5
 804a2d0:	68 ee 1b 05 08       	push   $0x8051bee
 804a2d5:	68 2e 18 05 08       	push   $0x805182e
 804a2da:	68 1c 1c 05 08       	push   $0x8051c1c
 804a2df:	e8 55 0e 00 00       	call   804b139 <assert_print>
 804a2e4:	c7 04 24 39 1c 05 08 	movl   $0x8051c39,(%esp)
 804a2eb:	e8 49 0e 00 00       	call   804b139 <assert_print>
 804a2f0:	59                   	pop    %ecx
 804a2f1:	5b                   	pop    %ebx
 804a2f2:	68 e5 01 00 00       	push   $0x1e5
 804a2f7:	eb 32                	jmp    804a32b <cbvprintf_package+0x12d>
					return -EINVAL;
				}

				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
 804a2f9:	83 7d b4 0f          	cmpl   $0xf,-0x4c(%ebp)
 804a2fd:	76 43                	jbe    804a342 <cbvprintf_package+0x144>
					__ASSERT(false, "str_ptr_pos[] too small");
 804a2ff:	68 ea 01 00 00       	push   $0x1ea
 804a304:	68 ee 1b 05 08       	push   $0x8051bee
 804a309:	68 2e 18 05 08       	push   $0x805182e
 804a30e:	68 1c 1c 05 08       	push   $0x8051c1c
 804a313:	e8 21 0e 00 00       	call   804b139 <assert_print>
 804a318:	c7 04 24 5a 1c 05 08 	movl   $0x8051c5a,(%esp)
 804a31f:	e8 15 0e 00 00       	call   804b139 <assert_print>
 804a324:	58                   	pop    %eax
 804a325:	5a                   	pop    %edx
 804a326:	68 ea 01 00 00       	push   $0x1ea
 804a32b:	68 ee 1b 05 08       	push   $0x8051bee
 804a330:	e8 1f 0e 00 00       	call   804b154 <assert_post_action>
 804a335:	83 c4 10             	add    $0x10,%esp
					return -EINVAL;
 804a338:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
 804a33d:	e9 3d 03 00 00       	jmp    804a67f <cbvprintf_package+0x481>
				}

				if (buf0 != NULL) {
 804a342:	85 db                	test   %ebx,%ebx
 804a344:	74 28                	je     804a36e <cbvprintf_package+0x170>
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 804a346:	c1 ee 02             	shr    $0x2,%esi
					/*
					 * Remember string pointer location.
					 * We will append non-ro strings later.
					 */
					str_ptr_pos[s_idx] = s_ptr_idx;
					if (is_ro) {
 804a349:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
 804a34d:	7e 11                	jle    804a360 <cbvprintf_package+0x162>
						/* flag read-only string. */
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
 804a34f:	8b 7d b4             	mov    -0x4c(%ebp),%edi
 804a352:	83 ce 80             	or     $0xffffff80,%esi
						s_ro_cnt++;
 804a355:	ff 45 ac             	incl   -0x54(%ebp)
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
 804a358:	89 f0                	mov    %esi,%eax
 804a35a:	88 44 3d d4          	mov    %al,-0x2c(%ebp,%edi,1)
						s_ro_cnt++;
 804a35e:	eb 2b                	jmp    804a38b <cbvprintf_package+0x18d>
					str_ptr_pos[s_idx] = s_ptr_idx;
 804a360:	8b 7d b4             	mov    -0x4c(%ebp),%edi
 804a363:	89 f0                	mov    %esi,%eax
					} else {
						s_rw_cnt++;
 804a365:	ff 45 a8             	incl   -0x58(%ebp)
					str_ptr_pos[s_idx] = s_ptr_idx;
 804a368:	88 44 3d d4          	mov    %al,-0x2c(%ebp,%edi,1)
						s_rw_cnt++;
 804a36c:	eb 1d                	jmp    804a38b <cbvprintf_package+0x18d>
					}
				} else if (is_ro || rws_pos_en) {
 804a36e:	80 7d 9f 00          	cmpb   $0x0,-0x61(%ebp)
 804a372:	75 04                	jne    804a378 <cbvprintf_package+0x17a>
 804a374:	84 c9                	test   %cl,%cl
 804a376:	74 05                	je     804a37d <cbvprintf_package+0x17f>
					/*
					 * Add only pointer position prefix
					 * when counting strings.
					 */
					len += 1;
 804a378:	ff 45 0c             	incl   0xc(%ebp)
 804a37b:	eb 0e                	jmp    804a38b <cbvprintf_package+0x18d>
				} else {
					/*
					 * Add the string length, the final '\0'
					 * and size of the pointer position prefix.
					 */
					len += strlen(s) + 1 + 1;
 804a37d:	8b 7d b8             	mov    -0x48(%ebp),%edi
 804a380:	8a 45 9f             	mov    -0x61(%ebp),%al
 804a383:	83 c9 ff             	or     $0xffffffff,%ecx
 804a386:	f2 ae                	repnz scas %es:(%edi),%al
 804a388:	29 4d 0c             	sub    %ecx,0xc(%ebp)
				}

				s_idx++;
 804a38b:	ff 45 b4             	incl   -0x4c(%ebp)
			}
			buf += sizeof(char *);
 804a38e:	83 45 c4 04          	addl   $0x4,-0x3c(%ebp)
			parsing = false;
 804a392:	31 ff                	xor    %edi,%edi
	while (*++fmt != '\0') {
 804a394:	ff 45 b0             	incl   -0x50(%ebp)
 804a397:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804a39a:	8a 08                	mov    (%eax),%cl
 804a39c:	84 c9                	test   %cl,%cl
 804a39e:	0f 84 a3 01 00 00    	je     804a547 <cbvprintf_package+0x349>
		if (!parsing) {
 804a3a4:	80 7d bc 00          	cmpb   $0x0,-0x44(%ebp)
 804a3a8:	75 15                	jne    804a3bf <cbvprintf_package+0x1c1>
				parsing = true;
 804a3aa:	80 f9 25             	cmp    $0x25,%cl
 804a3ad:	b9 04 00 00 00       	mov    $0x4,%ecx
 804a3b2:	0f 45 4d c0          	cmovne -0x40(%ebp),%ecx
 804a3b6:	0f 94 45 bc          	sete   -0x44(%ebp)
 804a3ba:	89 4d c0             	mov    %ecx,-0x40(%ebp)
 804a3bd:	eb d5                	jmp    804a394 <cbvprintf_package+0x196>
		switch (*fmt) {
 804a3bf:	80 f9 7a             	cmp    $0x7a,%cl
 804a3c2:	0f 8f 6a 01 00 00    	jg     804a532 <cbvprintf_package+0x334>
 804a3c8:	80 f9 29             	cmp    $0x29,%cl
 804a3cb:	7f 13                	jg     804a3e0 <cbvprintf_package+0x1e2>
 804a3cd:	80 f9 20             	cmp    $0x20,%cl
 804a3d0:	74 c2                	je     804a394 <cbvprintf_package+0x196>
			parsing = false;
 804a3d2:	80 f9 23             	cmp    $0x23,%cl
 804a3d5:	8a 4d bc             	mov    -0x44(%ebp),%cl
 804a3d8:	0f 45 cf             	cmovne %edi,%ecx
 804a3db:	88 4d bc             	mov    %cl,-0x44(%ebp)
 804a3de:	eb b4                	jmp    804a394 <cbvprintf_package+0x196>
 804a3e0:	8d 71 d6             	lea    -0x2a(%ecx),%esi
 804a3e3:	89 f0                	mov    %esi,%eax
 804a3e5:	3c 50                	cmp    $0x50,%al
 804a3e7:	0f 87 45 01 00 00    	ja     804a532 <cbvprintf_package+0x334>
 804a3ed:	0f b6 f0             	movzbl %al,%esi
 804a3f0:	3e ff 24 b5 24 10 05 	notrack jmp *0x8051024(,%esi,4)
 804a3f7:	08 
			parsing = false;
 804a3f8:	c6 45 bc 00          	movb   $0x0,-0x44(%ebp)
			size = sizeof(void *);
 804a3fc:	c7 45 c0 04 00 00 00 	movl   $0x4,-0x40(%ebp)
 804a403:	e9 87 00 00 00       	jmp    804a48f <cbvprintf_package+0x291>
			size = sizeof(ptrdiff_t);
 804a408:	c7 45 c0 04 00 00 00 	movl   $0x4,-0x40(%ebp)
			continue;
 804a40f:	eb 83                	jmp    804a394 <cbvprintf_package+0x196>
			if (fmt[-1] == 'l') {
 804a411:	8b 45 b0             	mov    -0x50(%ebp),%eax
			parsing = false;
 804a414:	c6 45 bc 00          	movb   $0x0,-0x44(%ebp)
			if (fmt[-1] == 'l') {
 804a418:	80 78 ff 6c          	cmpb   $0x6c,-0x1(%eax)
 804a41c:	75 71                	jne    804a48f <cbvprintf_package+0x291>
			parsing = false;
 804a41e:	80 78 fe 6c          	cmpb   $0x6c,-0x2(%eax)
 804a422:	0f 94 c0             	sete   %al
 804a425:	0f b6 c0             	movzbl %al,%eax
 804a428:	8d 04 85 04 00 00 00 	lea    0x4(,%eax,4),%eax
 804a42f:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804a432:	eb 5b                	jmp    804a48f <cbvprintf_package+0x291>
			if (fmt[-1] == 'L') {
 804a434:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804a437:	8a 48 ff             	mov    -0x1(%eax),%cl
 804a43a:	80 f9 4c             	cmp    $0x4c,%cl
 804a43d:	75 11                	jne    804a450 <cbvprintf_package+0x252>
				v.ld = va_arg(ap, long double);
 804a43f:	db 2a                	fldt   (%edx)
				size = sizeof(long double);
 804a441:	c7 45 c0 0c 00 00 00 	movl   $0xc,-0x40(%ebp)
				v.ld = va_arg(ap, long double);
 804a448:	83 c2 0c             	add    $0xc,%edx
 804a44b:	db 7d c8             	fstpt  -0x38(%ebp)
				size = sizeof(long double);
 804a44e:	eb 0f                	jmp    804a45f <cbvprintf_package+0x261>
				v.d = va_arg(ap, double);
 804a450:	dd 02                	fldl   (%edx)
				size = sizeof(double);
 804a452:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
				v.d = va_arg(ap, double);
 804a459:	83 c2 08             	add    $0x8,%edx
 804a45c:	dd 5d c8             	fstpl  -0x38(%ebp)
			if (buf0 != NULL) {
 804a45f:	85 db                	test   %ebx,%ebx
 804a461:	74 21                	je     804a484 <cbvprintf_package+0x286>
				if (BUF_OFFSET + size > len) {
 804a463:	8b 75 c4             	mov    -0x3c(%ebp),%esi
 804a466:	29 de                	sub    %ebx,%esi
 804a468:	03 75 c0             	add    -0x40(%ebp),%esi
 804a46b:	3b 75 0c             	cmp    0xc(%ebp),%esi
 804a46e:	77 30                	ja     804a4a0 <cbvprintf_package+0x2a2>
					*(long double *)buf = v.ld;
 804a470:	8b 45 c4             	mov    -0x3c(%ebp),%eax
				} else if (fmt[-1] == 'L') {
 804a473:	80 f9 4c             	cmp    $0x4c,%cl
 804a476:	75 07                	jne    804a47f <cbvprintf_package+0x281>
					*(long double *)buf = v.ld;
 804a478:	db 6d c8             	fldt   -0x38(%ebp)
 804a47b:	db 38                	fstpt  (%eax)
 804a47d:	eb 05                	jmp    804a484 <cbvprintf_package+0x286>
					*(double *)buf = v.d;
 804a47f:	dd 45 c8             	fldl   -0x38(%ebp)
 804a482:	dd 18                	fstpl  (%eax)
			buf += size;
 804a484:	8b 75 c0             	mov    -0x40(%ebp),%esi
 804a487:	01 75 c4             	add    %esi,-0x3c(%ebp)
 804a48a:	e9 a3 00 00 00       	jmp    804a532 <cbvprintf_package+0x334>
		if (buf0 != NULL && BUF_OFFSET + size > len) {
 804a48f:	85 db                	test   %ebx,%ebx
 804a491:	74 17                	je     804a4aa <cbvprintf_package+0x2ac>
 804a493:	8b 75 c4             	mov    -0x3c(%ebp),%esi
 804a496:	29 de                	sub    %ebx,%esi
 804a498:	03 75 c0             	add    -0x40(%ebp),%esi
 804a49b:	3b 75 0c             	cmp    0xc(%ebp),%esi
 804a49e:	76 0a                	jbe    804a4aa <cbvprintf_package+0x2ac>
			return -ENOSPC;
 804a4a0:	b9 e4 ff ff ff       	mov    $0xffffffe4,%ecx
 804a4a5:	e9 d5 01 00 00       	jmp    804a67f <cbvprintf_package+0x481>
		if (*fmt == 's') {
 804a4aa:	80 f9 73             	cmp    $0x73,%cl
 804a4ad:	75 10                	jne    804a4bf <cbvprintf_package+0x2c1>
			s = va_arg(ap, char *);
 804a4af:	8b 02                	mov    (%edx),%eax
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 804a4b1:	ff 4d a4             	decl   -0x5c(%ebp)
			s = va_arg(ap, char *);
 804a4b4:	83 c2 04             	add    $0x4,%edx
 804a4b7:	89 45 b8             	mov    %eax,-0x48(%ebp)
 804a4ba:	e9 d8 fd ff ff       	jmp    804a297 <cbvprintf_package+0x99>
		} else if (size == sizeof(int)) {
 804a4bf:	83 7d c0 04          	cmpl   $0x4,-0x40(%ebp)
 804a4c3:	75 14                	jne    804a4d9 <cbvprintf_package+0x2db>
			int v = va_arg(ap, int);
 804a4c5:	8d 4a 04             	lea    0x4(%edx),%ecx

			if (buf0 != NULL) {
 804a4c8:	85 db                	test   %ebx,%ebx
 804a4ca:	74 07                	je     804a4d3 <cbvprintf_package+0x2d5>
			int v = va_arg(ap, int);
 804a4cc:	8b 12                	mov    (%edx),%edx
				*(int *)buf = v;
 804a4ce:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804a4d1:	89 10                	mov    %edx,(%eax)
			}
			buf += sizeof(int);
 804a4d3:	83 45 c4 04          	addl   $0x4,-0x3c(%ebp)
 804a4d7:	eb 1e                	jmp    804a4f7 <cbvprintf_package+0x2f9>

			if (buf0 != NULL) {
				*(long *)buf = v;
			}
			buf += sizeof(long);
		} else if (size == sizeof(long long)) {
 804a4d9:	83 7d c0 08          	cmpl   $0x8,-0x40(%ebp)
 804a4dd:	75 1f                	jne    804a4fe <cbvprintf_package+0x300>
			long long v = va_arg(ap, long long);
 804a4df:	8d 4a 08             	lea    0x8(%edx),%ecx

			if (buf0 != NULL) {
 804a4e2:	85 db                	test   %ebx,%ebx
 804a4e4:	74 0d                	je     804a4f3 <cbvprintf_package+0x2f5>
			long long v = va_arg(ap, long long);
 804a4e6:	8b 02                	mov    (%edx),%eax
				if (Z_CBPRINTF_VA_STACK_LL_DBL_MEMCPY) {
					memcpy(buf, &v, sizeof(long long));
				} else {
					*(long long *)buf = v;
 804a4e8:	8b 75 c4             	mov    -0x3c(%ebp),%esi
			long long v = va_arg(ap, long long);
 804a4eb:	8b 52 04             	mov    0x4(%edx),%edx
					*(long long *)buf = v;
 804a4ee:	89 06                	mov    %eax,(%esi)
 804a4f0:	89 56 04             	mov    %edx,0x4(%esi)
				}
			}
			buf += sizeof(long long);
 804a4f3:	83 45 c4 08          	addl   $0x8,-0x3c(%ebp)
			long long v = va_arg(ap, long long);
 804a4f7:	89 ca                	mov    %ecx,%edx
 804a4f9:	e9 96 fe ff ff       	jmp    804a394 <cbvprintf_package+0x196>
		} else {
			__ASSERT(false, "unexpected size %u", size);
 804a4fe:	68 26 02 00 00       	push   $0x226
 804a503:	68 ee 1b 05 08       	push   $0x8051bee
 804a508:	68 2e 18 05 08       	push   $0x805182e
 804a50d:	68 1c 1c 05 08       	push   $0x8051c1c
 804a512:	e8 22 0c 00 00       	call   804b139 <assert_print>
 804a517:	59                   	pop    %ecx
 804a518:	5b                   	pop    %ebx
 804a519:	ff 75 c0             	pushl  -0x40(%ebp)
 804a51c:	68 74 1c 05 08       	push   $0x8051c74
 804a521:	e8 13 0c 00 00       	call   804b139 <assert_print>
 804a526:	5e                   	pop    %esi
 804a527:	5f                   	pop    %edi
 804a528:	68 26 02 00 00       	push   $0x226
 804a52d:	e9 f9 fd ff ff       	jmp    804a32b <cbvprintf_package+0x12d>
			parsing = false;
 804a532:	c6 45 bc 00          	movb   $0x0,-0x44(%ebp)
 804a536:	e9 59 fe ff ff       	jmp    804a394 <cbvprintf_package+0x196>
			size = sizeof(intmax_t);
 804a53b:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
 804a542:	e9 4d fe ff ff       	jmp    804a394 <cbvprintf_package+0x196>
	 * We remember the size of the argument list as a multiple of
	 * sizeof(int) and limit it to a 8-bit field. That means 1020 bytes
	 * worth of va_list, or about 127 arguments on a 64-bit system
	 * (twice that on 32-bit systems). That ought to be good enough.
	 */
	if (BUF_OFFSET / sizeof(int) > 255) {
 804a547:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804a54a:	29 d8                	sub    %ebx,%eax
 804a54c:	3d ff 03 00 00       	cmp    $0x3ff,%eax
 804a551:	76 31                	jbe    804a584 <cbvprintf_package+0x386>
		__ASSERT(false, "too many format args");
 804a553:	68 32 02 00 00       	push   $0x232
 804a558:	68 ee 1b 05 08       	push   $0x8051bee
 804a55d:	68 2e 18 05 08       	push   $0x805182e
 804a562:	68 1c 1c 05 08       	push   $0x8051c1c
 804a567:	e8 cd 0b 00 00       	call   804b139 <assert_print>
 804a56c:	c7 04 24 89 1c 05 08 	movl   $0x8051c89,(%esp)
 804a573:	e8 c1 0b 00 00       	call   804b139 <assert_print>
 804a578:	58                   	pop    %eax
 804a579:	5a                   	pop    %edx
 804a57a:	68 32 02 00 00       	push   $0x232
 804a57f:	e9 a7 fd ff ff       	jmp    804a32b <cbvprintf_package+0x12d>

	/*
	 * If all we wanted was to count required buffer size
	 * then we have it now.
	 */
	if (buf0 == NULL) {
 804a584:	85 db                	test   %ebx,%ebx
 804a586:	75 0c                	jne    804a594 <cbvprintf_package+0x396>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
 804a588:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804a58b:	8d 4c 38 f8          	lea    -0x8(%eax,%edi,1),%ecx
 804a58f:	e9 eb 00 00 00       	jmp    804a67f <cbvprintf_package+0x481>

	/* Clear our buffer header. We made room for it initially. */
	*(char **)buf0 = NULL;

	/* Record end of argument list. */
	buf0[0] = BUF_OFFSET / sizeof(int);
 804a594:	c1 e8 02             	shr    $0x2,%eax

	if (rws_pos_en) {
 804a597:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
	*(char **)buf0 = NULL;
 804a59b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	buf0[0] = BUF_OFFSET / sizeof(int);
 804a5a1:	88 03                	mov    %al,(%ebx)
	if (rws_pos_en) {
 804a5a3:	74 0c                	je     804a5b1 <cbvprintf_package+0x3b3>
		/* Strings are appended, update location counter. */
		buf0[1] = 0;
		buf0[3] = s_rw_cnt;
 804a5a5:	8a 45 a8             	mov    -0x58(%ebp),%al
		buf0[1] = 0;
 804a5a8:	c6 43 01 00          	movb   $0x0,0x1(%ebx)
		buf0[3] = s_rw_cnt;
 804a5ac:	88 43 03             	mov    %al,0x3(%ebx)
 804a5af:	eb 0a                	jmp    804a5bb <cbvprintf_package+0x3bd>
	} else {
		/* Strings are appended, update append counter. */
		buf0[1] = s_rw_cnt;
 804a5b1:	8a 45 a8             	mov    -0x58(%ebp),%al
		buf0[3] = 0;
 804a5b4:	c6 43 03 00          	movb   $0x0,0x3(%ebx)
		buf0[1] = s_rw_cnt;
 804a5b8:	88 43 01             	mov    %al,0x1(%ebx)
	}

	buf0[2] = s_ro_cnt;
 804a5bb:	8a 45 ac             	mov    -0x54(%ebp),%al

	/* Store strings pointer locations of read only strings. */
	if (s_ro_cnt) {
 804a5be:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
	buf0[2] = s_ro_cnt;
 804a5c2:	88 43 02             	mov    %al,0x2(%ebx)
	if (s_ro_cnt) {
 804a5c5:	74 31                	je     804a5f8 <cbvprintf_package+0x3fa>
			}

			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;

			/* make sure it fits */
			if (BUF_OFFSET + 1 > len) {
 804a5c7:	b9 01 00 00 00       	mov    $0x1,%ecx
		for (i = 0; i < s_idx; i++) {
 804a5cc:	31 c0                	xor    %eax,%eax
			if (BUF_OFFSET + 1 > len) {
 804a5ce:	29 d9                	sub    %ebx,%ecx
		for (i = 0; i < s_idx; i++) {
 804a5d0:	39 45 b4             	cmp    %eax,-0x4c(%ebp)
 804a5d3:	74 23                	je     804a5f8 <cbvprintf_package+0x3fa>
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
 804a5d5:	8a 54 05 d4          	mov    -0x2c(%ebp,%eax,1),%dl
 804a5d9:	84 d2                	test   %dl,%dl
 804a5db:	79 18                	jns    804a5f5 <cbvprintf_package+0x3f7>
			if (BUF_OFFSET + 1 > len) {
 804a5dd:	8b 7d c4             	mov    -0x3c(%ebp),%edi
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
 804a5e0:	83 e2 7f             	and    $0x7f,%edx
			if (BUF_OFFSET + 1 > len) {
 804a5e3:	8d 34 0f             	lea    (%edi,%ecx,1),%esi
 804a5e6:	3b 75 0c             	cmp    0xc(%ebp),%esi
 804a5e9:	0f 87 b1 fe ff ff    	ja     804a4a0 <cbvprintf_package+0x2a2>
				return -ENOSPC;
			}
			/* store the pointer position prefix */
			*buf++ = pos;
 804a5ef:	88 17                	mov    %dl,(%edi)
 804a5f1:	47                   	inc    %edi
 804a5f2:	89 7d c4             	mov    %edi,-0x3c(%ebp)
		for (i = 0; i < s_idx; i++) {
 804a5f5:	40                   	inc    %eax
 804a5f6:	eb d8                	jmp    804a5d0 <cbvprintf_package+0x3d2>
 804a5f8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804a5fb:	8d 55 d4             	lea    -0x2c(%ebp),%edx
 804a5fe:	01 d0                	add    %edx,%eax
 804a600:	89 45 c0             	mov    %eax,-0x40(%ebp)
			/* find the string length including terminating '\0' */
			size = strlen(s) + 1;
		}

		/* make sure it fits */
		if (BUF_OFFSET + 1 + size > len) {
 804a603:	b8 01 00 00 00       	mov    $0x1,%eax
 804a608:	29 d8                	sub    %ebx,%eax
 804a60a:	89 45 bc             	mov    %eax,-0x44(%ebp)
	for (i = 0; i < s_idx; i++) {
 804a60d:	39 55 c0             	cmp    %edx,-0x40(%ebp)
 804a610:	74 57                	je     804a669 <cbvprintf_package+0x46b>
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
 804a612:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
 804a616:	74 05                	je     804a61d <cbvprintf_package+0x41f>
 804a618:	80 3a 00             	cmpb   $0x0,(%edx)
 804a61b:	78 49                	js     804a666 <cbvprintf_package+0x468>
			size = 0;
 804a61d:	31 c9                	xor    %ecx,%ecx
		if (rws_pos_en) {
 804a61f:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
 804a623:	75 1a                	jne    804a63f <cbvprintf_package+0x441>
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
 804a625:	0f b6 02             	movzbl (%edx),%eax
			size = strlen(s) + 1;
 804a628:	83 c9 ff             	or     $0xffffffff,%ecx
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
 804a62b:	8d 04 83             	lea    (%ebx,%eax,4),%eax
 804a62e:	8b 38                	mov    (%eax),%edi
			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
 804a630:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			size = strlen(s) + 1;
 804a636:	31 c0                	xor    %eax,%eax
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
 804a638:	89 7d b8             	mov    %edi,-0x48(%ebp)
			size = strlen(s) + 1;
 804a63b:	f2 ae                	repnz scas %es:(%edi),%al
 804a63d:	f7 d1                	not    %ecx
		if (BUF_OFFSET + 1 + size > len) {
 804a63f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804a642:	03 45 bc             	add    -0x44(%ebp),%eax
 804a645:	01 c8                	add    %ecx,%eax
 804a647:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a64a:	0f 87 50 fe ff ff    	ja     804a4a0 <cbvprintf_package+0x2a2>
			return -ENOSPC;
		}
		/* store the pointer position prefix */
		*buf++ = str_ptr_pos[i];
 804a650:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804a653:	8d 70 01             	lea    0x1(%eax),%esi
 804a656:	89 c7                	mov    %eax,%edi
 804a658:	8a 02                	mov    (%edx),%al
 804a65a:	88 07                	mov    %al,(%edi)
		/* copy the string with its terminating '\0' */
		memcpy(buf, s, size);
		buf += size;
 804a65c:	89 f7                	mov    %esi,%edi
 804a65e:	8b 75 b8             	mov    -0x48(%ebp),%esi
 804a661:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
 804a663:	89 7d c4             	mov    %edi,-0x3c(%ebp)
	for (i = 0; i < s_idx; i++) {
 804a666:	42                   	inc    %edx
 804a667:	eb a4                	jmp    804a60d <cbvprintf_package+0x40f>
	/*
	 * TODO: remove pointers for appended strings since they're useless.
	 * TODO: explore leveraging same mechanism to remove alignment padding
	 */

	return BUF_OFFSET;
 804a669:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
 804a66c:	29 d9                	sub    %ebx,%ecx
 804a66e:	eb 0f                	jmp    804a67f <cbvprintf_package+0x481>
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
 804a670:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
 804a674:	0f 87 f6 fb ff ff    	ja     804a270 <cbvprintf_package+0x72>
 804a67a:	e9 21 fe ff ff       	jmp    804a4a0 <cbvprintf_package+0x2a2>

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
 804a67f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a682:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804a689:	74 05                	je     804a690 <cbvprintf_package+0x492>
 804a68b:	e8 30 ed ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804a690:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a693:	89 c8                	mov    %ecx,%eax
 804a695:	5b                   	pop    %ebx
 804a696:	5e                   	pop    %esi
 804a697:	5f                   	pop    %edi
 804a698:	5d                   	pop    %ebp
 804a699:	c3                   	ret    

0804a69a <cbpprintf_external>:
}

int cbpprintf_external(cbprintf_cb out,
		       cbvprintf_exteral_formatter_func formatter,
		       void *ctx, void *packaged)
{
 804a69a:	f3 0f 1e fb          	endbr32 
 804a69e:	55                   	push   %ebp
 804a69f:	89 e5                	mov    %esp,%ebp
 804a6a1:	57                   	push   %edi
 804a6a2:	56                   	push   %esi
 804a6a3:	53                   	push   %ebx
 804a6a4:	83 ec 1c             	sub    $0x1c,%esp
 804a6a7:	8b 45 08             	mov    0x8(%ebp),%eax
 804a6aa:	8b 55 14             	mov    0x14(%ebp),%edx
 804a6ad:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804a6b0:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a6b3:	89 45 dc             	mov    %eax,-0x24(%ebp)
 804a6b6:	8b 45 10             	mov    0x10(%ebp),%eax
 804a6b9:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint8_t *buf = packaged;
	char *fmt, *s, **ps;
	unsigned int i, args_size, s_nbr, ros_nbr, rws_nbr, s_idx;

	if (buf == NULL) {
 804a6bc:	85 d2                	test   %edx,%edx
 804a6be:	74 5d                	je     804a71d <cbpprintf_external+0x83>
		return -EINVAL;
	}

	/* Retrieve the size of the arg list and number of strings. */
	args_size = buf[0] * sizeof(int);
	s_nbr     = buf[1];
 804a6c0:	0f b6 42 01          	movzbl 0x1(%edx),%eax
	ros_nbr   = buf[2];
	rws_nbr   = buf[3];
 804a6c4:	0f b6 4a 03          	movzbl 0x3(%edx),%ecx
	s = (char *)(buf + args_size + ros_nbr + rws_nbr);

	/*
	 * Patch in string pointers.
	 */
	for (i = 0; i < s_nbr; i++) {
 804a6c8:	31 db                	xor    %ebx,%ebx
	s_nbr     = buf[1];
 804a6ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	ros_nbr   = buf[2];
 804a6cd:	0f b6 42 02          	movzbl 0x2(%edx),%eax
	s = (char *)(buf + args_size + ros_nbr + rws_nbr);
 804a6d1:	01 c8                	add    %ecx,%eax
	args_size = buf[0] * sizeof(int);
 804a6d3:	0f b6 0a             	movzbl (%edx),%ecx
	s = (char *)(buf + args_size + ros_nbr + rws_nbr);
 804a6d6:	8d 0c 88             	lea    (%eax,%ecx,4),%ecx
		s_idx = *(uint8_t *)s++;
		ps = (char **)(buf + s_idx * sizeof(int));
		/* update the pointer with current string location */
		*ps = s;
		/* move to next string */
		s += strlen(s) + 1;
 804a6d9:	31 c0                	xor    %eax,%eax
	s = (char *)(buf + args_size + ros_nbr + rws_nbr);
 804a6db:	01 d1                	add    %edx,%ecx
	for (i = 0; i < s_nbr; i++) {
 804a6dd:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
 804a6e0:	73 17                	jae    804a6f9 <cbpprintf_external+0x5f>
		s_idx = *(uint8_t *)s++;
 804a6e2:	8d 71 01             	lea    0x1(%ecx),%esi
 804a6e5:	0f b6 09             	movzbl (%ecx),%ecx
	for (i = 0; i < s_nbr; i++) {
 804a6e8:	43                   	inc    %ebx
		s += strlen(s) + 1;
 804a6e9:	89 f7                	mov    %esi,%edi
		*ps = s;
 804a6eb:	89 34 8a             	mov    %esi,(%edx,%ecx,4)
		s += strlen(s) + 1;
 804a6ee:	83 c9 ff             	or     $0xffffffff,%ecx
 804a6f1:	f2 ae                	repnz scas %es:(%edi),%al
 804a6f3:	f7 d1                	not    %ecx
 804a6f5:	01 f1                	add    %esi,%ecx
	for (i = 0; i < s_nbr; i++) {
 804a6f7:	eb e4                	jmp    804a6dd <cbpprintf_external+0x43>

	/* Retrieve format string */
	fmt = ((char **)buf)[1];

	/* skip past format string pointer */
	buf += sizeof(char *) * 2;
 804a6f9:	8d 42 08             	lea    0x8(%edx),%eax
	return formatter(out, ctx, fmt, u.ap);
 804a6fc:	89 45 14             	mov    %eax,0x14(%ebp)
 804a6ff:	8b 42 04             	mov    0x4(%edx),%eax
 804a702:	89 45 10             	mov    %eax,0x10(%ebp)
 804a705:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a708:	89 45 0c             	mov    %eax,0xc(%ebp)
 804a70b:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a70e:	89 45 08             	mov    %eax,0x8(%ebp)
 804a711:	8b 45 dc             	mov    -0x24(%ebp),%eax

	/* Turn this into a va_list and  print it */
	return cbprintf_via_va_list(out, formatter, ctx, fmt, buf);
}
 804a714:	83 c4 1c             	add    $0x1c,%esp
 804a717:	5b                   	pop    %ebx
 804a718:	5e                   	pop    %esi
 804a719:	5f                   	pop    %edi
 804a71a:	5d                   	pop    %ebp
	return formatter(out, ctx, fmt, u.ap);
 804a71b:	ff e0                	jmp    *%eax
}
 804a71d:	83 c4 1c             	add    $0x1c,%esp
 804a720:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 804a725:	5b                   	pop    %ebx
 804a726:	5e                   	pop    %esi
 804a727:	5f                   	pop    %edi
 804a728:	5d                   	pop    %ebp
 804a729:	c3                   	ret    

0804a72a <arch_printk_char_out>:
 *
 * @return 0
 */
/* LCOV_EXCL_START */
__attribute__((weak)) int arch_printk_char_out(int c)
{
 804a72a:	f3 0f 1e fb          	endbr32 
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
 804a72e:	31 c0                	xor    %eax,%eax
 804a730:	c3                   	ret    

0804a731 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
 804a731:	f3 0f 1e fb          	endbr32 
 804a735:	55                   	push   %ebp
 804a736:	89 e5                	mov    %esp,%ebp
 804a738:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct out_context *ctx = ctx_p;

	ctx->count++;
 804a73b:	ff 00                	incl   (%eax)
	return _char_out(c);
}
 804a73d:	5d                   	pop    %ebp
	return _char_out(c);
 804a73e:	ff 25 70 52 05 08    	jmp    *0x8055270

0804a744 <__printk_hook_install>:
{
 804a744:	f3 0f 1e fb          	endbr32 
 804a748:	55                   	push   %ebp
 804a749:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
 804a74b:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804a74e:	5d                   	pop    %ebp
	_char_out = fn;
 804a74f:	a3 70 52 05 08       	mov    %eax,0x8055270
}
 804a754:	c3                   	ret    

0804a755 <vprintk>:

void vprintk(const char *fmt, va_list ap)
{
 804a755:	f3 0f 1e fb          	endbr32 
 804a759:	55                   	push   %ebp
 804a75a:	89 e5                	mov    %esp,%ebp
 804a75c:	83 ec 18             	sub    $0x18,%esp
 804a75f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a765:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a768:	31 c0                	xor    %eax,%eax
		struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
		k_spinlock_key_t key = k_spin_lock(&lock);
#endif

		cbvprintf(char_out, &ctx, fmt, ap);
 804a76a:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804a76d:	ff 75 0c             	pushl  0xc(%ebp)
 804a770:	ff 75 08             	pushl  0x8(%ebp)
 804a773:	50                   	push   %eax
 804a774:	68 31 a7 04 08       	push   $0x804a731
		struct out_context ctx = { 0 };
 804a779:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cbvprintf(char_out, &ctx, fmt, ap);
 804a780:	e8 cc 01 00 00       	call   804a951 <cbvprintf>
 804a785:	83 c4 10             	add    $0x10,%esp

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
 804a788:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a78b:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804a792:	74 05                	je     804a799 <vprintk+0x44>
 804a794:	e8 27 ec ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804a799:	c9                   	leave  
 804a79a:	c3                   	ret    

0804a79b <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
 804a79b:	f3 0f 1e fb          	endbr32 
 804a79f:	55                   	push   %ebp
 804a7a0:	89 e5                	mov    %esp,%ebp
 804a7a2:	83 ec 10             	sub    $0x10,%esp
	va_list ap;

	va_start(ap, fmt);
 804a7a5:	8d 45 0c             	lea    0xc(%ebp),%eax

	vprintk(fmt, ap);
 804a7a8:	50                   	push   %eax
 804a7a9:	ff 75 08             	pushl  0x8(%ebp)
 804a7ac:	e8 a4 ff ff ff       	call   804a755 <vprintk>
 804a7b1:	83 c4 10             	add    $0x10,%esp

	va_end(ap);
}
 804a7b4:	c9                   	leave  
 804a7b5:	c3                   	ret    

0804a7b6 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
 804a7b6:	f3 0f 1e fb          	endbr32 
 804a7ba:	55                   	push   %ebp
 804a7bb:	89 e5                	mov    %esp,%ebp
 804a7bd:	83 ec 0c             	sub    $0xc,%esp
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
 804a7c0:	ff 75 14             	pushl  0x14(%ebp)
 804a7c3:	ff 75 10             	pushl  0x10(%ebp)
 804a7c6:	ff 75 0c             	pushl  0xc(%ebp)
 804a7c9:	ff 55 08             	call   *0x8(%ebp)
 804a7cc:	83 c4 10             	add    $0x10,%esp
	if (z_syscall_trap()) {
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
 804a7cf:	e8 85 51 00 00       	call   804f959 <z_impl_z_current_get>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
 804a7d4:	83 ec 0c             	sub    $0xc,%esp
 804a7d7:	50                   	push   %eax
 804a7d8:	e8 c0 18 00 00       	call   804c09d <z_impl_k_thread_abort>
 804a7dd:	83 c4 0c             	add    $0xc,%esp
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 804a7e0:	6a 2d                	push   $0x2d
 804a7e2:	68 a0 1c 05 08       	push   $0x8051ca0
 804a7e7:	68 c9 1c 05 08       	push   $0x8051cc9
 804a7ec:	e8 4d 2b 00 00       	call   804d33e <posix_print_error_and_exit>
 804a7f1:	83 c4 10             	add    $0x10,%esp

0804a7f4 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
 804a7f4:	55                   	push   %ebp
 804a7f5:	89 e5                	mov    %esp,%ebp
 804a7f7:	57                   	push   %edi
 804a7f8:	89 cf                	mov    %ecx,%edi
 804a7fa:	56                   	push   %esi
 804a7fb:	89 c6                	mov    %eax,%esi
 804a7fd:	53                   	push   %ebx
	size_t count = 0;
 804a7fe:	31 db                	xor    %ebx,%ebx
{
 804a800:	83 ec 1c             	sub    $0x1c,%esp

	while ((sp < ep) || ((ep == NULL) && *sp)) {
 804a803:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
 804a806:	39 45 08             	cmp    %eax,0x8(%ebp)
 804a809:	76 1a                	jbe    804a825 <outs+0x31>
		int rc = out((int)*sp++, ctx);
 804a80b:	50                   	push   %eax
 804a80c:	50                   	push   %eax
 804a80d:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
 804a811:	52                   	push   %edx
 804a812:	50                   	push   %eax
 804a813:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804a816:	ff d6                	call   *%esi
 804a818:	83 c4 10             	add    $0x10,%esp

		if (rc < 0) {
 804a81b:	85 c0                	test   %eax,%eax
 804a81d:	78 18                	js     804a837 <outs+0x43>
			return rc;
		}
		++count;
 804a81f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a822:	43                   	inc    %ebx
 804a823:	eb de                	jmp    804a803 <outs+0xf>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 804a825:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804a829:	74 04                	je     804a82f <outs+0x3b>
	}

	return (int)count;
 804a82b:	89 d8                	mov    %ebx,%eax
 804a82d:	eb 08                	jmp    804a837 <outs+0x43>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 804a82f:	80 3c 1f 00          	cmpb   $0x0,(%edi,%ebx,1)
 804a833:	75 d6                	jne    804a80b <outs+0x17>
 804a835:	eb f4                	jmp    804a82b <outs+0x37>
}
 804a837:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a83a:	5b                   	pop    %ebx
 804a83b:	5e                   	pop    %esi
 804a83c:	5f                   	pop    %edi
 804a83d:	5d                   	pop    %ebp
 804a83e:	c3                   	ret    

0804a83f <extract_decimal>:
{
 804a83f:	55                   	push   %ebp
 804a840:	89 e5                	mov    %esp,%ebp
 804a842:	57                   	push   %edi
 804a843:	56                   	push   %esi
 804a844:	53                   	push   %ebx
 804a845:	89 c3                	mov    %eax,%ebx
 804a847:	83 ec 0c             	sub    $0xc,%esp
	const char *sp = *str;
 804a84a:	8b 30                	mov    (%eax),%esi
	while (isdigit((int)(unsigned char)*sp)) {
 804a84c:	e8 4f ed ff ff       	call   80495a0 <__ctype_b_loc@plt>
 804a851:	8b 08                	mov    (%eax),%ecx
	size_t val = 0;
 804a853:	31 c0                	xor    %eax,%eax
	while (isdigit((int)(unsigned char)*sp)) {
 804a855:	0f be 16             	movsbl (%esi),%edx
 804a858:	0f b6 fa             	movzbl %dl,%edi
 804a85b:	f6 44 79 01 08       	testb  $0x8,0x1(%ecx,%edi,2)
 804a860:	74 0a                	je     804a86c <extract_decimal+0x2d>
		val = 10U * val + *sp++ - '0';
 804a862:	6b c0 0a             	imul   $0xa,%eax,%eax
 804a865:	46                   	inc    %esi
 804a866:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
 804a86a:	eb e9                	jmp    804a855 <extract_decimal+0x16>
	*str = sp;
 804a86c:	89 33                	mov    %esi,(%ebx)
}
 804a86e:	83 c4 0c             	add    $0xc,%esp
 804a871:	5b                   	pop    %ebx
 804a872:	5e                   	pop    %esi
 804a873:	5f                   	pop    %edi
 804a874:	5d                   	pop    %ebp
 804a875:	c3                   	ret    

0804a876 <encode_uint>:
{
 804a876:	55                   	push   %ebp
 804a877:	89 e5                	mov    %esp,%ebp
 804a879:	57                   	push   %edi
 804a87a:	56                   	push   %esi
 804a87b:	89 ce                	mov    %ecx,%esi
 804a87d:	53                   	push   %ebx
	switch (specifier) {
 804a87e:	bb 08 00 00 00       	mov    $0x8,%ebx
{
 804a883:	83 ec 3c             	sub    $0x3c,%esp
 804a886:	89 55 dc             	mov    %edx,-0x24(%ebp)
 804a889:	89 45 d8             	mov    %eax,-0x28(%ebp)
	bool upcase = isupper((int)conv->specifier);
 804a88c:	e8 0f ed ff ff       	call   80495a0 <__ctype_b_loc@plt>
 804a891:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
 804a895:	8b 10                	mov    (%eax),%edx
 804a897:	66 8b 14 4a          	mov    (%edx,%ecx,2),%dx
 804a89b:	66 81 e2 00 01       	and    $0x100,%dx
 804a8a0:	66 89 55 ce          	mov    %dx,-0x32(%ebp)
	switch (specifier) {
 804a8a4:	80 f9 6f             	cmp    $0x6f,%cl
 804a8a7:	74 1b                	je     804a8c4 <encode_uint+0x4e>
 804a8a9:	89 c8                	mov    %ecx,%eax
 804a8ab:	77 05                	ja     804a8b2 <encode_uint+0x3c>
		return 16;
 804a8ad:	80 f9 58             	cmp    $0x58,%cl
 804a8b0:	eb 05                	jmp    804a8b7 <encode_uint+0x41>
	switch (specifier) {
 804a8b2:	83 e0 f7             	and    $0xfffffff7,%eax
		return 16;
 804a8b5:	3c 70                	cmp    $0x70,%al
 804a8b7:	bb 0a 00 00 00       	mov    $0xa,%ebx
 804a8bc:	b8 10 00 00 00       	mov    $0x10,%eax
 804a8c1:	0f 44 d8             	cmove  %eax,%ebx
		unsigned int lsv = (unsigned int)(value % radix);
 804a8c4:	89 5d d0             	mov    %ebx,-0x30(%ebp)
	char *bp = bps + (bpe - bps);
 804a8c7:	8b 7d 0c             	mov    0xc(%ebp),%edi
		unsigned int lsv = (unsigned int)(value % radix);
 804a8ca:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
 804a8d1:	83 ec 0c             	sub    $0xc,%esp
 804a8d4:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804a8d7:	50                   	push   %eax
 804a8d8:	ff 75 d4             	pushl  -0x2c(%ebp)
 804a8db:	ff 75 d0             	pushl  -0x30(%ebp)
 804a8de:	ff 75 dc             	pushl  -0x24(%ebp)
 804a8e1:	ff 75 d8             	pushl  -0x28(%ebp)
 804a8e4:	e8 27 eb ff ff       	call   8049410 <__udivmoddi4@plt>
 804a8e9:	83 c4 20             	add    $0x20,%esp
 804a8ec:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804a8ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
 804a8f2:	89 55 c4             	mov    %edx,-0x3c(%ebp)
 804a8f5:	8d 50 30             	lea    0x30(%eax),%edx
 804a8f8:	83 f8 09             	cmp    $0x9,%eax
 804a8fb:	76 0d                	jbe    804a90a <encode_uint+0x94>
 804a8fd:	66 83 7d ce 00       	cmpw   $0x0,-0x32(%ebp)
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
 804a902:	8d 50 57             	lea    0x57(%eax),%edx
		*--bp = (lsv <= 9) ? ('0' + lsv)
 804a905:	74 03                	je     804a90a <encode_uint+0x94>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
 804a907:	8d 50 37             	lea    0x37(%eax),%edx
	} while ((value != 0) && (bps < bp));
 804a90a:	8b 45 d0             	mov    -0x30(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
 804a90d:	4f                   	dec    %edi
	} while ((value != 0) && (bps < bp));
 804a90e:	39 45 d8             	cmp    %eax,-0x28(%ebp)
		*--bp = (lsv <= 9) ? ('0' + lsv)
 804a911:	88 17                	mov    %dl,(%edi)
	} while ((value != 0) && (bps < bp));
 804a913:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a916:	1b 45 d4             	sbb    -0x2c(%ebp),%eax
 804a919:	72 13                	jb     804a92e <encode_uint+0xb8>
 804a91b:	3b 7d 08             	cmp    0x8(%ebp),%edi
 804a91e:	76 0e                	jbe    804a92e <encode_uint+0xb8>
		value /= radix;
 804a920:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804a923:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804a926:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804a929:	89 55 dc             	mov    %edx,-0x24(%ebp)
 804a92c:	eb a3                	jmp    804a8d1 <encode_uint+0x5b>
	if (conv->flag_hash) {
 804a92e:	f6 06 20             	testb  $0x20,(%esi)
 804a931:	74 14                	je     804a947 <encode_uint+0xd1>
		if (radix == 8) {
 804a933:	83 fb 08             	cmp    $0x8,%ebx
 804a936:	75 06                	jne    804a93e <encode_uint+0xc8>
			conv->altform_0 = true;
 804a938:	80 4e 02 08          	orb    $0x8,0x2(%esi)
 804a93c:	eb 09                	jmp    804a947 <encode_uint+0xd1>
		} else if (radix == 16) {
 804a93e:	83 fb 10             	cmp    $0x10,%ebx
 804a941:	75 04                	jne    804a947 <encode_uint+0xd1>
			conv->altform_0c = true;
 804a943:	80 4e 02 10          	orb    $0x10,0x2(%esi)
}
 804a947:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a94a:	89 f8                	mov    %edi,%eax
 804a94c:	5b                   	pop    %ebx
 804a94d:	5e                   	pop    %esi
 804a94e:	5f                   	pop    %edi
 804a94f:	5d                   	pop    %ebp
 804a950:	c3                   	ret    

0804a951 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
 804a951:	f3 0f 1e fb          	endbr32 
 804a955:	55                   	push   %ebp
 804a956:	89 e5                	mov    %esp,%ebp
 804a958:	57                   	push   %edi
 804a959:	56                   	push   %esi
 804a95a:	53                   	push   %ebx
 804a95b:	83 ec 6c             	sub    $0x6c,%esp
 804a95e:	8b 45 08             	mov    0x8(%ebp),%eax
 804a961:	8b 5d 14             	mov    0x14(%ebp),%ebx
 804a964:	89 45 98             	mov    %eax,-0x68(%ebp)
 804a967:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a96a:	89 45 94             	mov    %eax,-0x6c(%ebp)
 804a96d:	8b 45 10             	mov    0x10(%ebp),%eax
 804a970:	89 45 9c             	mov    %eax,-0x64(%ebp)
 804a973:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a979:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804a97c:	31 c0                	xor    %eax,%eax
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
 804a97e:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
 804a985:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a988:	0f be 00             	movsbl (%eax),%eax
 804a98b:	84 c0                	test   %al,%al
 804a98d:	0f 84 81 07 00 00    	je     804b114 <cbvprintf+0x7c3>
		if (*fp != '%') {
 804a993:	8b 7d 9c             	mov    -0x64(%ebp),%edi
 804a996:	47                   	inc    %edi
 804a997:	89 7d 90             	mov    %edi,-0x70(%ebp)
 804a99a:	3c 25                	cmp    $0x25,%al
 804a99c:	74 0b                	je     804a9a9 <cbvprintf+0x58>
			OUTC(*fp++);
 804a99e:	56                   	push   %esi
 804a99f:	56                   	push   %esi
 804a9a0:	ff 75 94             	pushl  -0x6c(%ebp)
 804a9a3:	50                   	push   %eax
 804a9a4:	e9 5b 04 00 00       	jmp    804ae04 <cbvprintf+0x4b3>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
 804a9a9:	31 c0                	xor    %eax,%eax
 804a9ab:	8d 7d b4             	lea    -0x4c(%ebp),%edi
 804a9ae:	b9 03 00 00 00       	mov    $0x3,%ecx
 804a9b3:	f3 ab                	rep stos %eax,%es:(%edi)
	*conv = (struct conversion) {
 804a9b5:	8d 7d c0             	lea    -0x40(%ebp),%edi
 804a9b8:	b9 03 00 00 00       	mov    $0x3,%ecx
 804a9bd:	f3 ab                	rep stos %eax,%es:(%edi)
	if (*sp == '%') {
 804a9bf:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a9c2:	80 78 01 25          	cmpb   $0x25,0x1(%eax)
 804a9c6:	75 1c                	jne    804a9e4 <cbvprintf+0x93>
		conv->specifier = *sp++;
 804a9c8:	83 c0 02             	add    $0x2,%eax
 804a9cb:	c6 45 c3 25          	movb   $0x25,-0x3d(%ebp)
 804a9cf:	89 45 90             	mov    %eax,-0x70(%ebp)
		return sp;
 804a9d2:	e9 52 02 00 00       	jmp    804ac29 <cbvprintf+0x2d8>
		switch (*sp) {
 804a9d7:	7e 16                	jle    804a9ef <cbvprintf+0x9e>
 804a9d9:	3c 2d                	cmp    $0x2d,%al
 804a9db:	75 1c                	jne    804a9f9 <cbvprintf+0xa8>
			conv->flag_dash = true;
 804a9dd:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
			++sp;
 804a9e1:	ff 45 90             	incl   -0x70(%ebp)
		switch (*sp) {
 804a9e4:	8b 45 90             	mov    -0x70(%ebp),%eax
 804a9e7:	8a 00                	mov    (%eax),%al
 804a9e9:	3c 2b                	cmp    $0x2b,%al
 804a9eb:	75 ea                	jne    804a9d7 <cbvprintf+0x86>
 804a9ed:	eb 23                	jmp    804aa12 <cbvprintf+0xc1>
 804a9ef:	3c 20                	cmp    $0x20,%al
 804a9f1:	74 25                	je     804aa18 <cbvprintf+0xc7>
 804a9f3:	3c 23                	cmp    $0x23,%al
 804a9f5:	74 27                	je     804aa1e <cbvprintf+0xcd>
 804a9f7:	eb 04                	jmp    804a9fd <cbvprintf+0xac>
 804a9f9:	3c 30                	cmp    $0x30,%al
 804a9fb:	74 27                	je     804aa24 <cbvprintf+0xd3>
	if (conv->flag_zero && conv->flag_dash) {
 804a9fd:	8a 45 c0             	mov    -0x40(%ebp),%al
 804aa00:	89 c2                	mov    %eax,%edx
 804aa02:	83 e2 44             	and    $0x44,%edx
 804aa05:	80 fa 44             	cmp    $0x44,%dl
 804aa08:	75 20                	jne    804aa2a <cbvprintf+0xd9>
		conv->flag_zero = false;
 804aa0a:	83 e0 bf             	and    $0xffffffbf,%eax
 804aa0d:	88 45 c0             	mov    %al,-0x40(%ebp)
 804aa10:	eb 18                	jmp    804aa2a <cbvprintf+0xd9>
			conv->flag_plus = true;
 804aa12:	80 4d c0 08          	orb    $0x8,-0x40(%ebp)
			break;
 804aa16:	eb c9                	jmp    804a9e1 <cbvprintf+0x90>
			conv->flag_space = true;
 804aa18:	80 4d c0 10          	orb    $0x10,-0x40(%ebp)
			break;
 804aa1c:	eb c3                	jmp    804a9e1 <cbvprintf+0x90>
			conv->flag_hash = true;
 804aa1e:	80 4d c0 20          	orb    $0x20,-0x40(%ebp)
			break;
 804aa22:	eb bd                	jmp    804a9e1 <cbvprintf+0x90>
			conv->flag_zero = true;
 804aa24:	80 4d c0 40          	orb    $0x40,-0x40(%ebp)
			break;
 804aa28:	eb b7                	jmp    804a9e1 <cbvprintf+0x90>
	sp = extract_width(conv, sp);
 804aa2a:	8b 45 90             	mov    -0x70(%ebp),%eax
	conv->width_present = true;
 804aa2d:	80 4d c0 80          	orb    $0x80,-0x40(%ebp)
 804aa31:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (*sp == '*') {
 804aa34:	80 38 2a             	cmpb   $0x2a,(%eax)
 804aa37:	75 09                	jne    804aa42 <cbvprintf+0xf1>
		return ++sp;
 804aa39:	89 c2                	mov    %eax,%edx
		conv->width_star = true;
 804aa3b:	80 4d c1 01          	orb    $0x1,-0x3f(%ebp)
		return ++sp;
 804aa3f:	42                   	inc    %edx
 804aa40:	eb 30                	jmp    804aa72 <cbvprintf+0x121>
	size_t width = extract_decimal(&sp);
 804aa42:	8d 45 b0             	lea    -0x50(%ebp),%eax
 804aa45:	e8 f5 fd ff ff       	call   804a83f <extract_decimal>
	if (sp != wp) {
 804aa4a:	8b 55 b0             	mov    -0x50(%ebp),%edx
 804aa4d:	3b 55 90             	cmp    -0x70(%ebp),%edx
 804aa50:	74 20                	je     804aa72 <cbvprintf+0x121>
		conv->unsupported |= ((conv->width_value < 0)
 804aa52:	8a 4d c0             	mov    -0x40(%ebp),%cl
		conv->width_value = width;
 804aa55:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				      || (width != (size_t)conv->width_value));
 804aa58:	c1 e8 1f             	shr    $0x1f,%eax
		conv->unsupported |= ((conv->width_value < 0)
 804aa5b:	d0 e9                	shr    %cl
 804aa5d:	83 e1 01             	and    $0x1,%ecx
 804aa60:	09 c8                	or     %ecx,%eax
 804aa62:	8a 4d c0             	mov    -0x40(%ebp),%cl
 804aa65:	01 c0                	add    %eax,%eax
 804aa67:	83 c8 80             	or     $0xffffff80,%eax
 804aa6a:	83 e1 7d             	and    $0x7d,%ecx
 804aa6d:	09 c8                	or     %ecx,%eax
 804aa6f:	88 45 c0             	mov    %al,-0x40(%ebp)
	sp = extract_prec(conv, sp);
 804aa72:	89 55 b0             	mov    %edx,-0x50(%ebp)
	conv->prec_present = (*sp == '.');
 804aa75:	8a 0a                	mov    (%edx),%cl
 804aa77:	80 f9 2e             	cmp    $0x2e,%cl
 804aa7a:	0f 94 c0             	sete   %al
 804aa7d:	8d 34 00             	lea    (%eax,%eax,1),%esi
 804aa80:	8a 45 c1             	mov    -0x3f(%ebp),%al
 804aa83:	83 e0 fd             	and    $0xfffffffd,%eax
 804aa86:	09 f0                	or     %esi,%eax
 804aa88:	88 45 c1             	mov    %al,-0x3f(%ebp)
	if (!conv->prec_present) {
 804aa8b:	80 f9 2e             	cmp    $0x2e,%cl
 804aa8e:	75 3e                	jne    804aace <cbvprintf+0x17d>
	++sp;
 804aa90:	8d 4a 01             	lea    0x1(%edx),%ecx
 804aa93:	89 4d b0             	mov    %ecx,-0x50(%ebp)
	if (*sp == '*') {
 804aa96:	80 7a 01 2a          	cmpb   $0x2a,0x1(%edx)
 804aa9a:	75 0b                	jne    804aaa7 <cbvprintf+0x156>
		conv->prec_star = true;
 804aa9c:	83 c8 04             	or     $0x4,%eax
		return ++sp;
 804aa9f:	83 c2 02             	add    $0x2,%edx
		conv->prec_star = true;
 804aaa2:	88 45 c1             	mov    %al,-0x3f(%ebp)
		return ++sp;
 804aaa5:	eb 27                	jmp    804aace <cbvprintf+0x17d>
	size_t prec = extract_decimal(&sp);
 804aaa7:	8d 45 b0             	lea    -0x50(%ebp),%eax
 804aaaa:	e8 90 fd ff ff       	call   804a83f <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
 804aaaf:	8a 55 c0             	mov    -0x40(%ebp),%dl
	conv->prec_value = prec;
 804aab2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			      || (prec != (size_t)conv->prec_value));
 804aab5:	c1 e8 1f             	shr    $0x1f,%eax
	conv->unsupported |= ((conv->prec_value < 0)
 804aab8:	89 d1                	mov    %edx,%ecx
 804aaba:	83 e2 fd             	and    $0xfffffffd,%edx
 804aabd:	d0 e9                	shr    %cl
 804aabf:	83 e1 01             	and    $0x1,%ecx
 804aac2:	09 c8                	or     %ecx,%eax
 804aac4:	01 c0                	add    %eax,%eax
 804aac6:	09 c2                	or     %eax,%edx
 804aac8:	88 55 c0             	mov    %dl,-0x40(%ebp)
	return sp;
 804aacb:	8b 55 b0             	mov    -0x50(%ebp),%edx
	switch (*sp) {
 804aace:	8a 0a                	mov    (%edx),%cl
 804aad0:	8d 72 01             	lea    0x1(%edx),%esi
 804aad3:	80 f9 6c             	cmp    $0x6c,%cl
 804aad6:	74 50                	je     804ab28 <cbvprintf+0x1d7>
 804aad8:	7f 20                	jg     804aafa <cbvprintf+0x1a9>
 804aada:	80 f9 68             	cmp    $0x68,%cl
 804aadd:	74 30                	je     804ab0f <cbvprintf+0x1be>
 804aadf:	80 f9 6a             	cmp    $0x6a,%cl
 804aae2:	74 66                	je     804ab4a <cbvprintf+0x1f9>
 804aae4:	80 f9 4c             	cmp    $0x4c,%cl
 804aae7:	75 74                	jne    804ab5d <cbvprintf+0x20c>
		conv->unsupported = true;
 804aae9:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804aaec:	66 25 fd 87          	and    $0x87fd,%ax
 804aaf0:	66 0d 02 40          	or     $0x4002,%ax
 804aaf4:	66 89 45 c0          	mov    %ax,-0x40(%ebp)
		break;
 804aaf8:	eb 69                	jmp    804ab63 <cbvprintf+0x212>
	switch (*sp) {
 804aafa:	80 f9 74             	cmp    $0x74,%cl
 804aafd:	8a 45 c1             	mov    -0x3f(%ebp),%al
 804ab00:	74 53                	je     804ab55 <cbvprintf+0x204>
 804ab02:	80 f9 7a             	cmp    $0x7a,%cl
 804ab05:	75 56                	jne    804ab5d <cbvprintf+0x20c>
		conv->length_mod = LENGTH_Z;
 804ab07:	83 e0 87             	and    $0xffffff87,%eax
 804ab0a:	83 c8 30             	or     $0x30,%eax
 804ab0d:	eb 36                	jmp    804ab45 <cbvprintf+0x1f4>
		if (*++sp == 'h') {
 804ab0f:	80 7a 01 68          	cmpb   $0x68,0x1(%edx)
 804ab13:	8a 45 c1             	mov    -0x3f(%ebp),%al
 804ab16:	75 08                	jne    804ab20 <cbvprintf+0x1cf>
			conv->length_mod = LENGTH_HH;
 804ab18:	83 e0 87             	and    $0xffffff87,%eax
 804ab1b:	83 c8 08             	or     $0x8,%eax
 804ab1e:	eb 17                	jmp    804ab37 <cbvprintf+0x1e6>
			conv->length_mod = LENGTH_H;
 804ab20:	83 e0 87             	and    $0xffffff87,%eax
 804ab23:	83 c8 10             	or     $0x10,%eax
 804ab26:	eb 1d                	jmp    804ab45 <cbvprintf+0x1f4>
		if (*++sp == 'l') {
 804ab28:	80 7a 01 6c          	cmpb   $0x6c,0x1(%edx)
 804ab2c:	8a 45 c1             	mov    -0x3f(%ebp),%al
 804ab2f:	75 0e                	jne    804ab3f <cbvprintf+0x1ee>
			conv->length_mod = LENGTH_LL;
 804ab31:	83 e0 87             	and    $0xffffff87,%eax
 804ab34:	83 c8 20             	or     $0x20,%eax
 804ab37:	88 45 c1             	mov    %al,-0x3f(%ebp)
			++sp;
 804ab3a:	8d 72 02             	lea    0x2(%edx),%esi
 804ab3d:	eb 24                	jmp    804ab63 <cbvprintf+0x212>
			conv->length_mod = LENGTH_L;
 804ab3f:	83 e0 87             	and    $0xffffff87,%eax
 804ab42:	83 c8 18             	or     $0x18,%eax
 804ab45:	88 45 c1             	mov    %al,-0x3f(%ebp)
 804ab48:	eb 19                	jmp    804ab63 <cbvprintf+0x212>
		conv->length_mod = LENGTH_J;
 804ab4a:	8a 45 c1             	mov    -0x3f(%ebp),%al
 804ab4d:	83 e0 87             	and    $0xffffff87,%eax
 804ab50:	83 c8 28             	or     $0x28,%eax
 804ab53:	eb f0                	jmp    804ab45 <cbvprintf+0x1f4>
		conv->length_mod = LENGTH_T;
 804ab55:	83 e0 87             	and    $0xffffff87,%eax
 804ab58:	83 c8 38             	or     $0x38,%eax
 804ab5b:	eb e8                	jmp    804ab45 <cbvprintf+0x1f4>
		conv->length_mod = LENGTH_NONE;
 804ab5d:	80 65 c1 87          	andb   $0x87,-0x3f(%ebp)
		break;
 804ab61:	89 d6                	mov    %edx,%esi
	conv->specifier = *sp++;
 804ab63:	8d 46 01             	lea    0x1(%esi),%eax
 804ab66:	8a 55 c1             	mov    -0x3f(%ebp),%dl
 804ab69:	89 45 90             	mov    %eax,-0x70(%ebp)
 804ab6c:	8a 06                	mov    (%esi),%al
 804ab6e:	88 45 c3             	mov    %al,-0x3d(%ebp)
	switch (conv->specifier) {
 804ab71:	3c 78                	cmp    $0x78,%al
 804ab73:	0f 8f 94 00 00 00    	jg     804ac0d <cbvprintf+0x2bc>
 804ab79:	3c 57                	cmp    $0x57,%al
 804ab7b:	7f 11                	jg     804ab8e <cbvprintf+0x23d>
 804ab7d:	3c 41                	cmp    $0x41,%al
 804ab7f:	74 51                	je     804abd2 <cbvprintf+0x281>
 804ab81:	83 e8 45             	sub    $0x45,%eax
 804ab84:	3c 02                	cmp    $0x2,%al
 804ab86:	0f 87 81 00 00 00    	ja     804ac0d <cbvprintf+0x2bc>
 804ab8c:	eb 44                	jmp    804abd2 <cbvprintf+0x281>
 804ab8e:	8d 48 a8             	lea    -0x58(%eax),%ecx
 804ab91:	80 f9 20             	cmp    $0x20,%cl
 804ab94:	77 77                	ja     804ac0d <cbvprintf+0x2bc>
 804ab96:	0f b6 c9             	movzbl %cl,%ecx
 804ab99:	3e ff 24 8d 68 11 05 	notrack jmp *0x8051168(,%ecx,4)
 804aba0:	08 
		conv->specifier_cat = SPECIFIER_SINT;
 804aba1:	8a 4d c2             	mov    -0x3e(%ebp),%cl
 804aba4:	83 e1 f8             	and    $0xfffffff8,%ecx
 804aba7:	83 c9 01             	or     $0x1,%ecx
 804abaa:	eb 09                	jmp    804abb5 <cbvprintf+0x264>
		conv->specifier_cat = SPECIFIER_UINT;
 804abac:	8a 4d c2             	mov    -0x3e(%ebp),%cl
 804abaf:	83 e1 f8             	and    $0xfffffff8,%ecx
 804abb2:	83 c9 02             	or     $0x2,%ecx
 804abb5:	f3 0f 1e fb          	endbr32 
		if (conv->length_mod == LENGTH_UPPER_L) {
 804abb9:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_UINT;
 804abbc:	88 4d c2             	mov    %cl,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
 804abbf:	80 fa 40             	cmp    $0x40,%dl
 804abc2:	75 04                	jne    804abc8 <cbvprintf+0x277>
			conv->invalid = true;
 804abc4:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
 804abc8:	31 c9                	xor    %ecx,%ecx
		if (conv->specifier == 'c') {
 804abca:	3c 63                	cmp    $0x63,%al
 804abcc:	75 45                	jne    804ac13 <cbvprintf+0x2c2>
			unsupported = (conv->length_mod != LENGTH_NONE);
 804abce:	84 d2                	test   %dl,%dl
 804abd0:	eb 36                	jmp    804ac08 <cbvprintf+0x2b7>
		conv->specifier_cat = SPECIFIER_FP;
 804abd2:	8a 45 c2             	mov    -0x3e(%ebp),%al
			unsupported = true;
 804abd5:	b1 01                	mov    $0x1,%cl
		conv->specifier_cat = SPECIFIER_FP;
 804abd7:	83 e0 f8             	and    $0xfffffff8,%eax
 804abda:	83 c8 04             	or     $0x4,%eax
 804abdd:	88 45 c2             	mov    %al,-0x3e(%ebp)
			break;
 804abe0:	eb 31                	jmp    804ac13 <cbvprintf+0x2c2>
		conv->specifier_cat = SPECIFIER_PTR;
 804abe2:	8a 45 c2             	mov    -0x3e(%ebp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
 804abe5:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_PTR;
 804abe8:	83 e0 f8             	and    $0xfffffff8,%eax
 804abeb:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
 804abee:	80 fa 40             	cmp    $0x40,%dl
		conv->specifier_cat = SPECIFIER_PTR;
 804abf1:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
 804abf4:	0f 94 c1             	sete   %cl
 804abf7:	eb 1a                	jmp    804ac13 <cbvprintf+0x2c2>
		conv->specifier_cat = SPECIFIER_PTR;
 804abf9:	8a 45 c2             	mov    -0x3e(%ebp),%al
 804abfc:	83 e0 f8             	and    $0xfffffff8,%eax
 804abff:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
 804ac02:	80 e2 78             	and    $0x78,%dl
		conv->specifier_cat = SPECIFIER_PTR;
 804ac05:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod != LENGTH_NONE) {
 804ac08:	0f 95 c1             	setne  %cl
 804ac0b:	eb 06                	jmp    804ac13 <cbvprintf+0x2c2>
		conv->invalid = true;
 804ac0d:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
 804ac11:	31 c9                	xor    %ecx,%ecx
	conv->unsupported |= unsupported;
 804ac13:	8a 55 c0             	mov    -0x40(%ebp),%dl
 804ac16:	89 d0                	mov    %edx,%eax
 804ac18:	83 e2 fd             	and    $0xfffffffd,%edx
 804ac1b:	d0 e8                	shr    %al
 804ac1d:	83 e0 01             	and    $0x1,%eax
 804ac20:	09 c8                	or     %ecx,%eax
 804ac22:	01 c0                	add    %eax,%eax
 804ac24:	09 d0                	or     %edx,%eax
 804ac26:	88 45 c0             	mov    %al,-0x40(%ebp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
 804ac29:	8a 55 c1             	mov    -0x3f(%ebp),%dl
 804ac2c:	f6 c2 01             	test   $0x1,%dl
 804ac2f:	74 15                	je     804ac46 <cbvprintf+0x2f5>
			width = va_arg(ap, int);
 804ac31:	8d 43 04             	lea    0x4(%ebx),%eax
 804ac34:	8b 1b                	mov    (%ebx),%ebx
 804ac36:	89 5d a0             	mov    %ebx,-0x60(%ebp)

			if (width < 0) {
 804ac39:	85 db                	test   %ebx,%ebx
 804ac3b:	79 22                	jns    804ac5f <cbvprintf+0x30e>
				conv->flag_dash = true;
 804ac3d:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
				width = -width;
 804ac41:	f7 5d a0             	negl   -0x60(%ebp)
 804ac44:	eb 19                	jmp    804ac5f <cbvprintf+0x30e>
			}
		} else if (conv->width_present) {
 804ac46:	80 7d c0 00          	cmpb   $0x0,-0x40(%ebp)
 804ac4a:	79 0a                	jns    804ac56 <cbvprintf+0x305>
			width = conv->width_value;
 804ac4c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804ac4f:	89 45 a0             	mov    %eax,-0x60(%ebp)
 804ac52:	89 d8                	mov    %ebx,%eax
 804ac54:	eb 09                	jmp    804ac5f <cbvprintf+0x30e>
		int width = -1;
 804ac56:	c7 45 a0 ff ff ff ff 	movl   $0xffffffff,-0x60(%ebp)
 804ac5d:	89 d8                	mov    %ebx,%eax

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
 804ac5f:	f6 c2 04             	test   $0x4,%dl
 804ac62:	74 0f                	je     804ac73 <cbvprintf+0x322>
			int arg = va_arg(ap, int);
 804ac64:	8b 38                	mov    (%eax),%edi
 804ac66:	8d 58 04             	lea    0x4(%eax),%ebx

			if (arg < 0) {
 804ac69:	85 ff                	test   %edi,%edi
 804ac6b:	79 17                	jns    804ac84 <cbvprintf+0x333>
				conv->prec_present = false;
 804ac6d:	80 65 c1 fd          	andb   $0xfd,-0x3f(%ebp)
 804ac71:	eb 0e                	jmp    804ac81 <cbvprintf+0x330>
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
 804ac73:	80 e2 02             	and    $0x2,%dl
 804ac76:	74 07                	je     804ac7f <cbvprintf+0x32e>
			precision = conv->prec_value;
 804ac78:	8b 7d c8             	mov    -0x38(%ebp),%edi
 804ac7b:	89 c3                	mov    %eax,%ebx
 804ac7d:	eb 05                	jmp    804ac84 <cbvprintf+0x333>
 804ac7f:	89 c3                	mov    %eax,%ebx
		int precision = -1;
 804ac81:	83 cf ff             	or     $0xffffffff,%edi
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
 804ac84:	8a 45 c1             	mov    -0x3f(%ebp),%al
			= (enum specifier_cat_enum)conv->specifier_cat;
 804ac87:	8a 55 c2             	mov    -0x3e(%ebp),%dl
		conv->pad0_value = 0;
 804ac8a:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		conv->pad0_pre_exp = 0;
 804ac91:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
			= (enum length_mod_enum)conv->length_mod;
 804ac98:	c0 e8 03             	shr    $0x3,%al
		enum specifier_cat_enum specifier_cat
 804ac9b:	83 e2 07             	and    $0x7,%edx
			= (enum length_mod_enum)conv->length_mod;
 804ac9e:	83 e0 0f             	and    $0xf,%eax
		enum length_mod_enum length_mod
 804aca1:	0f b6 c8             	movzbl %al,%ecx
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
 804aca4:	83 fa 01             	cmp    $0x1,%edx
 804aca7:	75 1f                	jne    804acc8 <cbvprintf+0x377>
			switch (length_mod) {
 804aca9:	3c 05                	cmp    $0x5,%al
 804acab:	74 28                	je     804acd5 <cbvprintf+0x384>
 804acad:	77 39                	ja     804ace8 <cbvprintf+0x397>
 804acaf:	3c 03                	cmp    $0x3,%al
 804acb1:	74 06                	je     804acb9 <cbvprintf+0x368>
 804acb3:	3c 04                	cmp    $0x4,%al
 804acb5:	74 1e                	je     804acd5 <cbvprintf+0x384>
 804acb7:	eb 2f                	jmp    804ace8 <cbvprintf+0x397>
				if (WCHAR_IS_SIGNED
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->sint = va_arg(ap, long);
 804acb9:	8b 0b                	mov    (%ebx),%ecx
 804acbb:	8d 53 04             	lea    0x4(%ebx),%edx
 804acbe:	89 cb                	mov    %ecx,%ebx
 804acc0:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
 804acc3:	c1 fb 1f             	sar    $0x1f,%ebx
 804acc6:	eb 18                	jmp    804ace0 <cbvprintf+0x38f>
			if (length_mod == LENGTH_HH) {
				value->sint = (char)value->sint;
			} else if (length_mod == LENGTH_H) {
				value->sint = (short)value->sint;
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
 804acc8:	83 fa 02             	cmp    $0x2,%edx
 804accb:	0f 85 97 00 00 00    	jne    804ad68 <cbvprintf+0x417>
			switch (length_mod) {
 804acd1:	3c 05                	cmp    $0x5,%al
 804acd3:	75 44                	jne    804ad19 <cbvprintf+0x3c8>
				value->sint =
 804acd5:	8b 0b                	mov    (%ebx),%ecx
					(sint_value_type)va_arg(ap, long long);
 804acd7:	8d 53 08             	lea    0x8(%ebx),%edx
				value->sint =
 804acda:	8b 5b 04             	mov    0x4(%ebx),%ebx
 804acdd:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
 804ace0:	89 5d b8             	mov    %ebx,-0x48(%ebp)
				break;
 804ace3:	e9 31 04 00 00       	jmp    804b119 <cbvprintf+0x7c8>
					(sint_value_type)va_arg(ap, ptrdiff_t);
 804ace8:	8b 13                	mov    (%ebx),%edx
 804acea:	83 c3 04             	add    $0x4,%ebx
 804aced:	89 55 b4             	mov    %edx,-0x4c(%ebp)
 804acf0:	c1 fa 1f             	sar    $0x1f,%edx
 804acf3:	89 55 b8             	mov    %edx,-0x48(%ebp)
			if (length_mod == LENGTH_HH) {
 804acf6:	83 f9 01             	cmp    $0x1,%ecx
 804acf9:	75 06                	jne    804ad01 <cbvprintf+0x3b0>
				value->sint = (char)value->sint;
 804acfb:	0f be 55 b4          	movsbl -0x4c(%ebp),%edx
 804acff:	eb 0d                	jmp    804ad0e <cbvprintf+0x3bd>
			} else if (length_mod == LENGTH_H) {
 804ad01:	83 f9 02             	cmp    $0x2,%ecx
 804ad04:	0f 85 89 00 00 00    	jne    804ad93 <cbvprintf+0x442>
				value->sint = (short)value->sint;
 804ad0a:	0f bf 55 b4          	movswl -0x4c(%ebp),%edx
 804ad0e:	89 55 b4             	mov    %edx,-0x4c(%ebp)
 804ad11:	c1 fa 1f             	sar    $0x1f,%edx
 804ad14:	89 55 b8             	mov    %edx,-0x48(%ebp)
 804ad17:	eb 7a                	jmp    804ad93 <cbvprintf+0x442>
			switch (length_mod) {
 804ad19:	77 1e                	ja     804ad39 <cbvprintf+0x3e8>
 804ad1b:	3c 03                	cmp    $0x3,%al
 804ad1d:	74 06                	je     804ad25 <cbvprintf+0x3d4>
 804ad1f:	3c 04                	cmp    $0x4,%al
 804ad21:	74 b2                	je     804acd5 <cbvprintf+0x384>
 804ad23:	eb 14                	jmp    804ad39 <cbvprintf+0x3e8>
				if ((!WCHAR_IS_SIGNED)
				    && (conv->specifier == 'c')) {
					value->uint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->uint = va_arg(ap, unsigned long);
 804ad25:	8d 53 04             	lea    0x4(%ebx),%edx
 804ad28:	8b 1b                	mov    (%ebx),%ebx
 804ad2a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 804ad31:	89 5d b4             	mov    %ebx,-0x4c(%ebp)
				}
				break;
 804ad34:	e9 e0 03 00 00       	jmp    804b119 <cbvprintf+0x7c8>
								uintmax_t);
				break;
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
 804ad39:	8b 33                	mov    (%ebx),%esi
 804ad3b:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 804ad42:	83 c3 04             	add    $0x4,%ebx
 804ad45:	89 75 b4             	mov    %esi,-0x4c(%ebp)
				break;
			}
			if (length_mod == LENGTH_HH) {
 804ad48:	83 f9 01             	cmp    $0x1,%ecx
 804ad4b:	75 06                	jne    804ad53 <cbvprintf+0x402>
				value->uint = (unsigned char)value->uint;
 804ad4d:	0f b6 55 b4          	movzbl -0x4c(%ebp),%edx
 804ad51:	eb 09                	jmp    804ad5c <cbvprintf+0x40b>
			} else if (length_mod == LENGTH_H) {
 804ad53:	83 f9 02             	cmp    $0x2,%ecx
 804ad56:	75 3b                	jne    804ad93 <cbvprintf+0x442>
				value->uint = (unsigned short)value->uint;
 804ad58:	0f b7 55 b4          	movzwl -0x4c(%ebp),%edx
 804ad5c:	89 55 b4             	mov    %edx,-0x4c(%ebp)
 804ad5f:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 804ad66:	eb 2b                	jmp    804ad93 <cbvprintf+0x442>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
 804ad68:	83 fa 04             	cmp    $0x4,%edx
 804ad6b:	75 19                	jne    804ad86 <cbvprintf+0x435>
			if (length_mod == LENGTH_UPPER_L) {
 804ad6d:	83 f9 08             	cmp    $0x8,%ecx
 804ad70:	75 0a                	jne    804ad7c <cbvprintf+0x42b>
				value->ldbl = va_arg(ap, long double);
 804ad72:	db 2b                	fldt   (%ebx)
 804ad74:	83 c3 0c             	add    $0xc,%ebx
 804ad77:	db 7d b4             	fstpt  -0x4c(%ebp)
 804ad7a:	eb 17                	jmp    804ad93 <cbvprintf+0x442>
			} else {
				value->dbl = va_arg(ap, double);
 804ad7c:	dd 03                	fldl   (%ebx)
 804ad7e:	83 c3 08             	add    $0x8,%ebx
 804ad81:	dd 5d b4             	fstpl  -0x4c(%ebp)
 804ad84:	eb 0d                	jmp    804ad93 <cbvprintf+0x442>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
 804ad86:	83 fa 03             	cmp    $0x3,%edx
 804ad89:	75 08                	jne    804ad93 <cbvprintf+0x442>
			value->ptr = va_arg(ap, void *);
 804ad8b:	8b 13                	mov    (%ebx),%edx
 804ad8d:	83 c3 04             	add    $0x4,%ebx
 804ad90:	89 55 b4             	mov    %edx,-0x4c(%ebp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
 804ad93:	8a 55 c0             	mov    -0x40(%ebp),%dl
 804ad96:	f6 c2 03             	test   $0x3,%dl
 804ad99:	74 27                	je     804adc2 <cbvprintf+0x471>
			OUTS(sp, fp);
 804ad9b:	83 ec 0c             	sub    $0xc,%esp
 804ad9e:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
 804ada1:	8b 55 94             	mov    -0x6c(%ebp),%edx
 804ada4:	ff 75 90             	pushl  -0x70(%ebp)
 804ada7:	8b 45 98             	mov    -0x68(%ebp),%eax
 804adaa:	e8 45 fa ff ff       	call   804a7f4 <outs>
 804adaf:	83 c4 10             	add    $0x10,%esp
 804adb2:	85 c0                	test   %eax,%eax
 804adb4:	0f 88 66 03 00 00    	js     804b120 <cbvprintf+0x7cf>
 804adba:	01 45 a4             	add    %eax,-0x5c(%ebp)
			continue;
 804adbd:	e9 47 03 00 00       	jmp    804b109 <cbvprintf+0x7b8>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
 804adc2:	8a 4d c3             	mov    -0x3d(%ebp),%cl
 804adc5:	80 f9 78             	cmp    $0x78,%cl
 804adc8:	0f 87 3b 03 00 00    	ja     804b109 <cbvprintf+0x7b8>
 804adce:	80 f9 62             	cmp    $0x62,%cl
 804add1:	77 13                	ja     804ade6 <cbvprintf+0x495>
 804add3:	80 f9 25             	cmp    $0x25,%cl
 804add6:	74 25                	je     804adfd <cbvprintf+0x4ac>
 804add8:	80 f9 58             	cmp    $0x58,%cl
 804addb:	0f 84 bb 00 00 00    	je     804ae9c <cbvprintf+0x54b>
 804ade1:	e9 23 03 00 00       	jmp    804b109 <cbvprintf+0x7b8>
 804ade6:	83 e9 63             	sub    $0x63,%ecx
 804ade9:	80 f9 15             	cmp    $0x15,%cl
 804adec:	0f 87 17 03 00 00    	ja     804b109 <cbvprintf+0x7b8>
 804adf2:	0f b6 c9             	movzbl %cl,%ecx
 804adf5:	3e ff 24 8d ec 11 05 	notrack jmp *0x80511ec(,%ecx,4)
 804adfc:	08 
		case '%':
			OUTC('%');
 804adfd:	51                   	push   %ecx
 804adfe:	51                   	push   %ecx
 804adff:	ff 75 94             	pushl  -0x6c(%ebp)
 804ae02:	6a 25                	push   $0x25
 804ae04:	8b 45 98             	mov    -0x68(%ebp),%eax
 804ae07:	ff d0                	call   *%eax
 804ae09:	83 c4 10             	add    $0x10,%esp
 804ae0c:	85 c0                	test   %eax,%eax
 804ae0e:	0f 88 0c 03 00 00    	js     804b120 <cbvprintf+0x7cf>
 804ae14:	ff 45 a4             	incl   -0x5c(%ebp)
			break;
 804ae17:	e9 ed 02 00 00       	jmp    804b109 <cbvprintf+0x7b8>
		case 's': {
			bps = (const char *)value->ptr;
 804ae1c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804ae1f:	89 45 9c             	mov    %eax,-0x64(%ebp)

			size_t len;

			if (precision >= 0) {
 804ae22:	85 ff                	test   %edi,%edi
 804ae24:	78 0e                	js     804ae34 <cbvprintf+0x4e3>
				len = strnlen(bps, precision);
 804ae26:	52                   	push   %edx
 804ae27:	52                   	push   %edx
 804ae28:	57                   	push   %edi
 804ae29:	50                   	push   %eax
 804ae2a:	e8 b1 e6 ff ff       	call   80494e0 <strnlen@plt>
 804ae2f:	83 c4 10             	add    $0x10,%esp
 804ae32:	eb 0f                	jmp    804ae43 <cbvprintf+0x4f2>
			} else {
				len = strlen(bps);
 804ae34:	8b 7d 9c             	mov    -0x64(%ebp),%edi
 804ae37:	31 c0                	xor    %eax,%eax
 804ae39:	83 c9 ff             	or     $0xffffffff,%ecx
 804ae3c:	f2 ae                	repnz scas %es:(%edi),%al
 804ae3e:	89 c8                	mov    %ecx,%eax
 804ae40:	f7 d0                	not    %eax
 804ae42:	48                   	dec    %eax
			}

			bpe = bps + len;
 804ae43:	03 45 9c             	add    -0x64(%ebp),%eax
		char sign = 0;
 804ae46:	31 f6                	xor    %esi,%esi
			bpe = bps + len;
 804ae48:	89 45 8c             	mov    %eax,-0x74(%ebp)
			precision = -1;

			break;
 804ae4b:	e9 16 01 00 00       	jmp    804af66 <cbvprintf+0x615>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 804ae50:	8b 45 b4             	mov    -0x4c(%ebp),%eax
			bpe = buf + 1;
			break;
 804ae53:	31 f6                	xor    %esi,%esi
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 804ae55:	88 45 ce             	mov    %al,-0x32(%ebp)
			bpe = buf + 1;
 804ae58:	8d 45 cf             	lea    -0x31(%ebp),%eax
 804ae5b:	89 45 8c             	mov    %eax,-0x74(%ebp)
			bps = buf;
 804ae5e:	8d 45 ce             	lea    -0x32(%ebp),%eax
 804ae61:	89 45 9c             	mov    %eax,-0x64(%ebp)
			break;
 804ae64:	e9 18 01 00 00       	jmp    804af81 <cbvprintf+0x630>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
				sign = '+';
 804ae69:	be 2b 00 00 00       	mov    $0x2b,%esi
			if (conv->flag_plus) {
 804ae6e:	f6 c2 08             	test   $0x8,%dl
 804ae71:	75 0b                	jne    804ae7e <cbvprintf+0x52d>
			} else if (conv->flag_space) {
				sign = ' ';
 804ae73:	80 e2 10             	and    $0x10,%dl
 804ae76:	0f 95 c0             	setne  %al
 804ae79:	c1 e0 05             	shl    $0x5,%eax
 804ae7c:	89 c6                	mov    %eax,%esi

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
 804ae7e:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804ae81:	8b 45 b4             	mov    -0x4c(%ebp),%eax
			if (sint < 0) {
 804ae84:	85 d2                	test   %edx,%edx
 804ae86:	79 16                	jns    804ae9e <cbvprintf+0x54d>
				sign = '-';
				value->uint = (uint_value_type)-sint;
 804ae88:	f7 d8                	neg    %eax
				sign = '-';
 804ae8a:	be 2d 00 00 00       	mov    $0x2d,%esi
				value->uint = (uint_value_type)-sint;
 804ae8f:	83 d2 00             	adc    $0x0,%edx
 804ae92:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 804ae95:	f7 da                	neg    %edx
 804ae97:	89 55 b8             	mov    %edx,-0x48(%ebp)
 804ae9a:	eb 02                	jmp    804ae9e <cbvprintf+0x54d>
		switch (conv->specifier) {
 804ae9c:	31 f6                	xor    %esi,%esi
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
 804ae9e:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 804aea1:	50                   	push   %eax
 804aea2:	8d 4d c0             	lea    -0x40(%ebp),%ecx
 804aea5:	50                   	push   %eax
 804aea6:	8d 45 ce             	lea    -0x32(%ebp),%eax
 804aea9:	52                   	push   %edx
 804aeaa:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804aead:	50                   	push   %eax
 804aeae:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804aeb1:	e8 c0 f9 ff ff       	call   804a876 <encode_uint>
 804aeb6:	83 c4 10             	add    $0x10,%esp
 804aeb9:	89 45 9c             	mov    %eax,-0x64(%ebp)
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
 804aebc:	85 ff                	test   %edi,%edi
 804aebe:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804aec1:	0f 88 9c 00 00 00    	js     804af63 <cbvprintf+0x612>
				size_t len = bpe - bps;
 804aec7:	89 c2                	mov    %eax,%edx
 804aec9:	2b 55 9c             	sub    -0x64(%ebp),%edx

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv->flag_zero = false;
 804aecc:	80 65 c0 bf          	andb   $0xbf,-0x40(%ebp)
		const char *bpe = buf + sizeof(buf);
 804aed0:	89 45 8c             	mov    %eax,-0x74(%ebp)

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
 804aed3:	39 d7                	cmp    %edx,%edi
 804aed5:	0f 86 8b 00 00 00    	jbe    804af66 <cbvprintf+0x615>
					conv->pad0_value = precision - (int)len;
 804aedb:	29 d7                	sub    %edx,%edi
 804aedd:	89 7d c4             	mov    %edi,-0x3c(%ebp)
 804aee0:	e9 81 00 00 00       	jmp    804af66 <cbvprintf+0x615>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
 804aee5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804aee8:	85 c0                	test   %eax,%eax
 804aeea:	0f 84 81 00 00 00    	je     804af71 <cbvprintf+0x620>
				bps = encode_uint((uintptr_t)value->ptr, conv,
 804aef0:	8d 75 e4             	lea    -0x1c(%ebp),%esi
 804aef3:	51                   	push   %ecx
 804aef4:	31 d2                	xor    %edx,%edx
 804aef6:	51                   	push   %ecx
 804aef7:	8d 4d ce             	lea    -0x32(%ebp),%ecx
 804aefa:	56                   	push   %esi
		char sign = 0;
 804aefb:	31 f6                	xor    %esi,%esi
				bps = encode_uint((uintptr_t)value->ptr, conv,
 804aefd:	51                   	push   %ecx
 804aefe:	8d 4d c0             	lea    -0x40(%ebp),%ecx
 804af01:	e8 70 f9 ff ff       	call   804a876 <encode_uint>
 804af06:	83 c4 10             	add    $0x10,%esp
 804af09:	89 45 9c             	mov    %eax,-0x64(%ebp)
						  buf, bpe);

				/* Use 0x prefix */
				conv->altform_0c = true;
 804af0c:	66 8b 45 c2          	mov    -0x3e(%ebp),%ax
 804af10:	66 25 ef 00          	and    $0xef,%ax
 804af14:	66 0d 10 78          	or     $0x7810,%ax
 804af18:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
				conv->specifier = 'x';

				goto prec_int_pad0;
 804af1c:	eb 9e                	jmp    804aebc <cbvprintf+0x56b>
			bpe = bps + 5;

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
 804af1e:	8b 55 b4             	mov    -0x4c(%ebp),%edx
	switch ((enum length_mod_enum)conv->length_mod) {
 804af21:	3c 07                	cmp    $0x7,%al
 804af23:	0f 87 e0 01 00 00    	ja     804b109 <cbvprintf+0x7b8>
 804af29:	0f b6 c0             	movzbl %al,%eax
 804af2c:	3e ff 24 85 44 12 05 	notrack jmp *0x8051244(,%eax,4)
 804af33:	08 
		*(signed char *)dp = (signed char)count;
 804af34:	8a 45 a4             	mov    -0x5c(%ebp),%al
 804af37:	88 02                	mov    %al,(%edx)
		break;
 804af39:	e9 cb 01 00 00       	jmp    804b109 <cbvprintf+0x7b8>
		*(short *)dp = (short)count;
 804af3e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804af41:	66 89 02             	mov    %ax,(%edx)
		break;
 804af44:	e9 c0 01 00 00       	jmp    804b109 <cbvprintf+0x7b8>
		*(intmax_t *)dp = (intmax_t)count;
 804af49:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804af4c:	89 02                	mov    %eax,(%edx)
 804af4e:	c1 f8 1f             	sar    $0x1f,%eax
 804af51:	89 42 04             	mov    %eax,0x4(%edx)
		break;
 804af54:	e9 b0 01 00 00       	jmp    804b109 <cbvprintf+0x7b8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
 804af59:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804af5c:	89 02                	mov    %eax,(%edx)
		break;
 804af5e:	e9 a6 01 00 00       	jmp    804b109 <cbvprintf+0x7b8>
		const char *bpe = buf + sizeof(buf);
 804af63:	89 45 8c             	mov    %eax,-0x74(%ebp)
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
 804af66:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
 804af6a:	75 15                	jne    804af81 <cbvprintf+0x630>
 804af6c:	e9 98 01 00 00       	jmp    804b109 <cbvprintf+0x7b8>
			bpe = bps + 5;
 804af71:	c7 45 8c f3 1c 05 08 	movl   $0x8051cf3,-0x74(%ebp)
 804af78:	31 f6                	xor    %esi,%esi
			bps = "(nil)";
 804af7a:	c7 45 9c ee 1c 05 08 	movl   $0x8051cee,-0x64(%ebp)
		 */
		size_t nj_len = (bpe - bps);
		int pad_len = 0;

		if (sign != 0) {
			nj_len += 1U;
 804af81:	89 f1                	mov    %esi,%ecx
		}

		if (conv->altform_0c) {
 804af83:	8a 55 c2             	mov    -0x3e(%ebp),%dl
		size_t nj_len = (bpe - bps);
 804af86:	8b 45 8c             	mov    -0x74(%ebp),%eax
 804af89:	2b 45 9c             	sub    -0x64(%ebp),%eax
			nj_len += 1U;
 804af8c:	80 f9 01             	cmp    $0x1,%cl
 804af8f:	83 d8 ff             	sbb    $0xffffffff,%eax
		if (conv->altform_0c) {
 804af92:	f6 c2 10             	test   $0x10,%dl
 804af95:	74 05                	je     804af9c <cbvprintf+0x64b>
			nj_len += 2U;
 804af97:	83 c0 02             	add    $0x2,%eax
 804af9a:	eb 0b                	jmp    804afa7 <cbvprintf+0x656>
		} else if (conv->altform_0) {
 804af9c:	89 d1                	mov    %edx,%ecx
 804af9e:	83 e1 08             	and    $0x8,%ecx
			nj_len += 1U;
 804afa1:	80 f9 01             	cmp    $0x1,%cl
 804afa4:	83 d8 ff             	sbb    $0xffffffff,%eax
		}

		nj_len += conv->pad0_value;
 804afa7:	03 45 c4             	add    -0x3c(%ebp),%eax
		if (conv->pad_fp) {
 804afaa:	80 e2 40             	and    $0x40,%dl
 804afad:	74 03                	je     804afb2 <cbvprintf+0x661>
			nj_len += conv->pad0_pre_exp;
 804afaf:	03 45 c8             	add    -0x38(%ebp),%eax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
 804afb2:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
 804afb6:	7e 7c                	jle    804b034 <cbvprintf+0x6e3>
			width -= (int)nj_len;
 804afb8:	8b 7d a0             	mov    -0x60(%ebp),%edi
 804afbb:	29 c7                	sub    %eax,%edi

			if (!conv->flag_dash) {
 804afbd:	8a 45 c0             	mov    -0x40(%ebp),%al
 804afc0:	a8 04                	test   $0x4,%al
 804afc2:	75 6d                	jne    804b031 <cbvprintf+0x6e0>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
 804afc4:	a8 40                	test   $0x40,%al
 804afc6:	74 26                	je     804afee <cbvprintf+0x69d>
					if (sign != 0) {
 804afc8:	89 f0                	mov    %esi,%eax
 804afca:	84 c0                	test   %al,%al
 804afcc:	74 27                	je     804aff5 <cbvprintf+0x6a4>
						OUTC(sign);
 804afce:	0f be f0             	movsbl %al,%esi
 804afd1:	52                   	push   %edx
 804afd2:	8b 45 98             	mov    -0x68(%ebp),%eax
 804afd5:	52                   	push   %edx
 804afd6:	ff 75 94             	pushl  -0x6c(%ebp)
 804afd9:	56                   	push   %esi
 804afda:	ff d0                	call   *%eax
 804afdc:	83 c4 10             	add    $0x10,%esp
 804afdf:	85 c0                	test   %eax,%eax
 804afe1:	0f 88 39 01 00 00    	js     804b120 <cbvprintf+0x7cf>
 804afe7:	ff 45 a4             	incl   -0x5c(%ebp)
						sign = 0;
 804afea:	31 f6                	xor    %esi,%esi
 804afec:	eb 07                	jmp    804aff5 <cbvprintf+0x6a4>
				char pad = ' ';
 804afee:	ba 20 00 00 00       	mov    $0x20,%edx
 804aff3:	eb 05                	jmp    804affa <cbvprintf+0x6a9>
					}
					pad = '0';
 804aff5:	ba 30 00 00 00       	mov    $0x30,%edx
 804affa:	89 7d a0             	mov    %edi,-0x60(%ebp)
 804affd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804b000:	8b 4d a0             	mov    -0x60(%ebp),%ecx
 804b003:	01 f8                	add    %edi,%eax
 804b005:	2b 45 a0             	sub    -0x60(%ebp),%eax
				}

				while (width-- > 0) {
 804b008:	ff 4d a0             	decl   -0x60(%ebp)
 804b00b:	85 c9                	test   %ecx,%ecx
 804b00d:	7e 1d                	jle    804b02c <cbvprintf+0x6db>
					OUTC(pad);
 804b00f:	50                   	push   %eax
 804b010:	50                   	push   %eax
 804b011:	8b 45 98             	mov    -0x68(%ebp),%eax
 804b014:	ff 75 94             	pushl  -0x6c(%ebp)
 804b017:	52                   	push   %edx
 804b018:	89 55 88             	mov    %edx,-0x78(%ebp)
 804b01b:	ff d0                	call   *%eax
 804b01d:	8b 55 88             	mov    -0x78(%ebp),%edx
 804b020:	83 c4 10             	add    $0x10,%esp
 804b023:	85 c0                	test   %eax,%eax
 804b025:	79 d6                	jns    804affd <cbvprintf+0x6ac>
 804b027:	e9 f4 00 00 00       	jmp    804b120 <cbvprintf+0x7cf>
 804b02c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804b02f:	eb 03                	jmp    804b034 <cbvprintf+0x6e3>
			width -= (int)nj_len;
 804b031:	89 7d a0             	mov    %edi,-0x60(%ebp)
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
 804b034:	89 f0                	mov    %esi,%eax
 804b036:	84 c0                	test   %al,%al
 804b038:	74 1c                	je     804b056 <cbvprintf+0x705>
			OUTC(sign);
 804b03a:	0f be f0             	movsbl %al,%esi
 804b03d:	57                   	push   %edi
 804b03e:	8b 45 98             	mov    -0x68(%ebp),%eax
 804b041:	57                   	push   %edi
 804b042:	ff 75 94             	pushl  -0x6c(%ebp)
 804b045:	56                   	push   %esi
 804b046:	ff d0                	call   *%eax
 804b048:	83 c4 10             	add    $0x10,%esp
 804b04b:	85 c0                	test   %eax,%eax
 804b04d:	0f 88 cd 00 00 00    	js     804b120 <cbvprintf+0x7cf>
 804b053:	ff 45 a4             	incl   -0x5c(%ebp)
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
 804b056:	8a 45 c2             	mov    -0x3e(%ebp),%al
 804b059:	a8 10                	test   $0x10,%al
 804b05b:	75 04                	jne    804b061 <cbvprintf+0x710>
 804b05d:	a8 08                	test   $0x8,%al
 804b05f:	74 1a                	je     804b07b <cbvprintf+0x72a>
				OUTC('0');
 804b061:	56                   	push   %esi
 804b062:	8b 45 98             	mov    -0x68(%ebp),%eax
 804b065:	56                   	push   %esi
 804b066:	ff 75 94             	pushl  -0x6c(%ebp)
 804b069:	6a 30                	push   $0x30
 804b06b:	ff d0                	call   *%eax
 804b06d:	83 c4 10             	add    $0x10,%esp
 804b070:	85 c0                	test   %eax,%eax
 804b072:	0f 88 a8 00 00 00    	js     804b120 <cbvprintf+0x7cf>
 804b078:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			if (conv->altform_0c) {
 804b07b:	f6 45 c2 10          	testb  $0x10,-0x3e(%ebp)
 804b07f:	74 1d                	je     804b09e <cbvprintf+0x74d>
				OUTC(conv->specifier);
 804b081:	0f b6 45 c3          	movzbl -0x3d(%ebp),%eax
 804b085:	51                   	push   %ecx
 804b086:	51                   	push   %ecx
 804b087:	ff 75 94             	pushl  -0x6c(%ebp)
 804b08a:	50                   	push   %eax
 804b08b:	8b 45 98             	mov    -0x68(%ebp),%eax
 804b08e:	ff d0                	call   *%eax
 804b090:	83 c4 10             	add    $0x10,%esp
 804b093:	85 c0                	test   %eax,%eax
 804b095:	0f 88 85 00 00 00    	js     804b120 <cbvprintf+0x7cf>
 804b09b:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			pad_len = conv->pad0_value;
 804b09e:	8b 7d c4             	mov    -0x3c(%ebp),%edi
			while (pad_len-- > 0) {
 804b0a1:	8b 75 a4             	mov    -0x5c(%ebp),%esi
 804b0a4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804b0a7:	01 f8                	add    %edi,%eax
 804b0a9:	29 f0                	sub    %esi,%eax
 804b0ab:	85 c0                	test   %eax,%eax
 804b0ad:	7e 16                	jle    804b0c5 <cbvprintf+0x774>
				OUTC('0');
 804b0af:	52                   	push   %edx
 804b0b0:	8b 45 98             	mov    -0x68(%ebp),%eax
 804b0b3:	52                   	push   %edx
 804b0b4:	ff 75 94             	pushl  -0x6c(%ebp)
 804b0b7:	6a 30                	push   $0x30
 804b0b9:	ff d0                	call   *%eax
 804b0bb:	83 c4 10             	add    $0x10,%esp
 804b0be:	85 c0                	test   %eax,%eax
 804b0c0:	78 5e                	js     804b120 <cbvprintf+0x7cf>
 804b0c2:	46                   	inc    %esi
 804b0c3:	eb df                	jmp    804b0a4 <cbvprintf+0x753>
			}

			OUTS(bps, bpe);
 804b0c5:	83 ec 0c             	sub    $0xc,%esp
 804b0c8:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
 804b0cb:	8b 55 94             	mov    -0x6c(%ebp),%edx
 804b0ce:	ff 75 8c             	pushl  -0x74(%ebp)
 804b0d1:	8b 45 98             	mov    -0x68(%ebp),%eax
 804b0d4:	e8 1b f7 ff ff       	call   804a7f4 <outs>
 804b0d9:	83 c4 10             	add    $0x10,%esp
 804b0dc:	85 c0                	test   %eax,%eax
 804b0de:	78 40                	js     804b120 <cbvprintf+0x7cf>
 804b0e0:	01 c6                	add    %eax,%esi
 804b0e2:	89 75 a4             	mov    %esi,-0x5c(%ebp)
		}

		/* Finish left justification */
		while (width > 0) {
 804b0e5:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804b0e8:	01 f0                	add    %esi,%eax
 804b0ea:	2b 45 a4             	sub    -0x5c(%ebp),%eax
 804b0ed:	85 c0                	test   %eax,%eax
 804b0ef:	7e 18                	jle    804b109 <cbvprintf+0x7b8>
			OUTC(' ');
 804b0f1:	50                   	push   %eax
 804b0f2:	50                   	push   %eax
 804b0f3:	8b 45 98             	mov    -0x68(%ebp),%eax
 804b0f6:	ff 75 94             	pushl  -0x6c(%ebp)
 804b0f9:	6a 20                	push   $0x20
 804b0fb:	ff d0                	call   *%eax
 804b0fd:	83 c4 10             	add    $0x10,%esp
 804b100:	85 c0                	test   %eax,%eax
 804b102:	78 1c                	js     804b120 <cbvprintf+0x7cf>
 804b104:	ff 45 a4             	incl   -0x5c(%ebp)
 804b107:	eb dc                	jmp    804b0e5 <cbvprintf+0x794>
			OUTS(bps, bpe);
 804b109:	8b 45 90             	mov    -0x70(%ebp),%eax
 804b10c:	89 45 9c             	mov    %eax,-0x64(%ebp)
 804b10f:	e9 71 f8 ff ff       	jmp    804a985 <cbvprintf+0x34>
			--width;
		}
	}

	return count;
 804b114:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804b117:	eb 07                	jmp    804b120 <cbvprintf+0x7cf>
					(uint_value_type)va_arg(ap, size_t);
 804b119:	89 d3                	mov    %edx,%ebx
 804b11b:	e9 73 fc ff ff       	jmp    804ad93 <cbvprintf+0x442>
#undef OUTS
#undef OUTC
}
 804b120:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
 804b123:	65 33 1d 14 00 00 00 	xor    %gs:0x14,%ebx
 804b12a:	74 05                	je     804b131 <cbvprintf+0x7e0>
 804b12c:	e8 8f e2 ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804b131:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b134:	5b                   	pop    %ebx
 804b135:	5e                   	pop    %esi
 804b136:	5f                   	pop    %edi
 804b137:	5d                   	pop    %ebp
 804b138:	c3                   	ret    

0804b139 <assert_print>:

	k_panic();
}

void assert_print(const char *fmt, ...)
{
 804b139:	f3 0f 1e fb          	endbr32 
 804b13d:	55                   	push   %ebp
 804b13e:	89 e5                	mov    %esp,%ebp
 804b140:	83 ec 10             	sub    $0x10,%esp
	va_list ap;

	va_start(ap, fmt);
 804b143:	8d 45 0c             	lea    0xc(%ebp),%eax

	vprintk(fmt, ap);
 804b146:	50                   	push   %eax
 804b147:	ff 75 08             	pushl  0x8(%ebp)
 804b14a:	e8 06 f6 ff ff       	call   804a755 <vprintk>
 804b14f:	83 c4 10             	add    $0x10,%esp

	va_end(ap);
}
 804b152:	c9                   	leave  
 804b153:	c3                   	ret    

0804b154 <assert_post_action>:
{
 804b154:	f3 0f 1e fb          	endbr32 
 804b158:	55                   	push   %ebp
 804b159:	89 e5                	mov    %esp,%ebp
 804b15b:	83 ec 0c             	sub    $0xc,%esp
	k_panic();
 804b15e:	6a 2b                	push   $0x2b
 804b160:	68 f4 1c 05 08       	push   $0x8051cf4
 804b165:	68 30 1c 05 08       	push   $0x8051c30
 804b16a:	e8 ca ff ff ff       	call   804b139 <assert_print>
 804b16f:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
 804b176:	83 c4 10             	add    $0x10,%esp
 804b179:	c7 45 08 04 00 00 00 	movl   $0x4,0x8(%ebp)
}
 804b180:	c9                   	leave  
	k_panic();
 804b181:	e9 a6 33 00 00       	jmp    804e52c <z_fatal_error>

0804b186 <_ConfigAbsSyms>:

/* file is auto-generated, do not modify ! */

#include <zephyr/toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
 804b186:	f3 0f 1e fb          	endbr32 
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_LEGACY_INCLUDE_PATH, 1);

GEN_ABS_SYM_END
 804b18a:	c3                   	ret    

0804b18b <log_backend_is_active>:
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
 804b18b:	8b 40 04             	mov    0x4(%eax),%eax
 804b18e:	8a 40 05             	mov    0x5(%eax),%al
}
 804b191:	c3                   	ret    

0804b192 <msg_process>:

static void msg_process(union log_msgs msg, bool bypass)
{
	struct log_backend const *backend;

	if (!bypass) {
 804b192:	84 d2                	test   %dl,%dl
 804b194:	75 7d                	jne    804b213 <msg_process+0x81>
{
 804b196:	55                   	push   %ebp
 804b197:	89 e5                	mov    %esp,%ebp
 804b199:	57                   	push   %edi
		    IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
		    !panic_mode) {
			detect_missed_strdup(msg.msg);
		}

		for (int i = 0; i < log_backend_count_get(); i++) {
 804b19a:	31 ff                	xor    %edi,%edi
{
 804b19c:	56                   	push   %esi
 804b19d:	89 c6                	mov    %eax,%esi
 804b19f:	53                   	push   %ebx
	return __log_backends_end - __log_backends_start;
 804b1a0:	bb e8 61 05 08       	mov    $0x80561e8,%ebx
 804b1a5:	81 eb d8 61 05 08    	sub    $0x80561d8,%ebx
 804b1ab:	c1 fb 04             	sar    $0x4,%ebx
 804b1ae:	83 ec 1c             	sub    $0x1c,%esp
 804b1b1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
 804b1b4:	bb d8 61 05 08       	mov    $0x80561d8,%ebx
		for (int i = 0; i < log_backend_count_get(); i++) {
 804b1b9:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
 804b1bc:	7d 4d                	jge    804b20b <msg_process+0x79>
			backend = log_backend_get(i);
			if (log_backend_is_active(backend) &&
 804b1be:	89 d8                	mov    %ebx,%eax
 804b1c0:	e8 c6 ff ff ff       	call   804b18b <log_backend_is_active>
 804b1c5:	84 c0                	test   %al,%al
 804b1c7:	74 3c                	je     804b205 <msg_process+0x73>
	__ASSERT_NO_MSG(msg != NULL);
 804b1c9:	85 f6                	test   %esi,%esi
 804b1cb:	75 2d                	jne    804b1fa <msg_process+0x68>
 804b1cd:	68 86 00 00 00       	push   $0x86
 804b1d2:	68 17 1d 05 08       	push   $0x8051d17
 804b1d7:	68 4f 1d 05 08       	push   $0x8051d4f
 804b1dc:	68 1c 1c 05 08       	push   $0x8051c1c
 804b1e1:	e8 53 ff ff ff       	call   804b139 <assert_print>
 804b1e6:	5a                   	pop    %edx
 804b1e7:	59                   	pop    %ecx
 804b1e8:	68 86 00 00 00       	push   $0x86
 804b1ed:	68 17 1d 05 08       	push   $0x8051d17
 804b1f2:	e8 5d ff ff ff       	call   804b154 <assert_post_action>
 804b1f7:	83 c4 10             	add    $0x10,%esp
	backend->api->process(backend, msg);
 804b1fa:	50                   	push   %eax
 804b1fb:	50                   	push   %eax
 804b1fc:	8b 03                	mov    (%ebx),%eax
 804b1fe:	56                   	push   %esi
 804b1ff:	53                   	push   %ebx
 804b200:	ff 10                	call   *(%eax)
 804b202:	83 c4 10             	add    $0x10,%esp
		for (int i = 0; i < log_backend_count_get(); i++) {
 804b205:	47                   	inc    %edi
 804b206:	83 c3 10             	add    $0x10,%ebx
 804b209:	eb ae                	jmp    804b1b9 <msg_process+0x27>
	if (IS_ENABLED(CONFIG_LOG2_DEFERRED)) {
		z_log_msg2_free(msg.msg2);
	} else if (IS_ENABLED(CONFIG_LOG1_DEFERRED)) {
		log_msg_put(msg.msg);
	}
}
 804b20b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b20e:	5b                   	pop    %ebx
 804b20f:	5e                   	pop    %esi
 804b210:	5f                   	pop    %edi
 804b211:	5d                   	pop    %ebp
 804b212:	c3                   	ret    
 804b213:	c3                   	ret    

0804b214 <default_get_timestamp>:
{
 804b214:	f3 0f 1e fb          	endbr32 

extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
 804b218:	e9 3e 32 00 00       	jmp    804e45b <sys_clock_cycle_get_32>

0804b21d <dummy_timestamp>:
 804b21d:	f3 0f 1e fb          	endbr32 
 804b221:	31 c0                	xor    %eax,%eax
 804b223:	c3                   	ret    

0804b224 <log_format_func_t_get>:
{
 804b224:	f3 0f 1e fb          	endbr32 
 804b228:	55                   	push   %ebp
 804b229:	89 e5                	mov    %esp,%ebp
	return format_table[log_type];
 804b22b:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804b22e:	5d                   	pop    %ebp
	return format_table[log_type];
 804b22f:	8b 04 85 64 12 05 08 	mov    0x8051264(,%eax,4),%eax
}
 804b236:	c3                   	ret    

0804b237 <log_core_init>:
{
 804b237:	f3 0f 1e fb          	endbr32 
 804b23b:	55                   	push   %ebp
 804b23c:	89 e5                	mov    %esp,%ebp
 804b23e:	83 ec 14             	sub    $0x14,%esp
	panic_mode = false;
 804b241:	c6 05 ea 6a 05 08 00 	movb   $0x0,0x8056aea
	log_output_timestamp_freq_set(freq);
 804b248:	68 40 42 0f 00       	push   $0xf4240
	dropped_cnt = 0;
 804b24d:	c7 05 2c 6a 05 08 00 	movl   $0x0,0x8056a2c
 804b254:	00 00 00 
	timestamp_func = timestamp_getter;
 804b257:	c7 05 74 52 05 08 14 	movl   $0x804b214,0x8055274
 804b25e:	b2 04 08 
	log_output_timestamp_freq_set(freq);
 804b261:	e8 16 07 00 00       	call   804b97c <log_output_timestamp_freq_set>
 804b266:	83 c4 10             	add    $0x10,%esp
}
 804b269:	c9                   	leave  
 804b26a:	c3                   	ret    

0804b26b <log_init>:
{
 804b26b:	f3 0f 1e fb          	endbr32 
 804b26f:	55                   	push   %ebp
	return __log_backends_end - __log_backends_start;
 804b270:	b8 e8 61 05 08       	mov    $0x80561e8,%eax
 804b275:	2d d8 61 05 08       	sub    $0x80561d8,%eax
 804b27a:	89 e5                	mov    %esp,%ebp
 804b27c:	57                   	push   %edi
 804b27d:	56                   	push   %esi
 804b27e:	89 c6                	mov    %eax,%esi
 804b280:	53                   	push   %ebx
 804b281:	c1 fe 04             	sar    $0x4,%esi
 804b284:	83 ec 0c             	sub    $0xc,%esp
	__ASSERT_NO_MSG(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
 804b287:	3d 9f 00 00 00       	cmp    $0x9f,%eax
 804b28c:	76 2d                	jbe    804b2bb <log_init+0x50>
 804b28e:	68 73 02 00 00       	push   $0x273
 804b293:	68 62 1d 05 08       	push   $0x8051d62
 804b298:	68 a7 1d 05 08       	push   $0x8051da7
 804b29d:	68 1c 1c 05 08       	push   $0x8051c1c
 804b2a2:	e8 92 fe ff ff       	call   804b139 <assert_print>
 804b2a7:	5a                   	pop    %edx
 804b2a8:	59                   	pop    %ecx
 804b2a9:	68 73 02 00 00       	push   $0x273
 804b2ae:	68 62 1d 05 08       	push   $0x8051d62
 804b2b3:	e8 9c fe ff ff       	call   804b154 <assert_post_action>
 804b2b8:	83 c4 10             	add    $0x10,%esp
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 804b2bb:	b8 01 00 00 00       	mov    $0x1,%eax
 804b2c0:	f0 0f c1 05 34 6a 05 	lock xadd %eax,0x8056a34
 804b2c7:	08 
	if (atomic_inc(&initialized) != 0) {
 804b2c8:	85 c0                	test   %eax,%eax
 804b2ca:	75 3a                	jne    804b306 <log_init+0x9b>
 804b2cc:	bb d8 61 05 08       	mov    $0x80561d8,%ebx
	for (i = 0; i < log_backend_count_get(); i++) {
 804b2d1:	31 ff                	xor    %edi,%edi
 804b2d3:	39 f7                	cmp    %esi,%edi
 804b2d5:	7d 2f                	jge    804b306 <log_init+0x9b>
		if (backend->autostart) {
 804b2d7:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
 804b2db:	74 23                	je     804b300 <log_init+0x95>
			if (backend->api->init != NULL) {
 804b2dd:	8b 03                	mov    (%ebx),%eax
 804b2df:	8b 40 18             	mov    0x18(%eax),%eax
 804b2e2:	85 c0                	test   %eax,%eax
 804b2e4:	74 09                	je     804b2ef <log_init+0x84>
				backend->api->init(backend);
 804b2e6:	83 ec 0c             	sub    $0xc,%esp
 804b2e9:	53                   	push   %ebx
 804b2ea:	ff d0                	call   *%eax
 804b2ec:	83 c4 10             	add    $0x10,%esp
			log_backend_enable(backend,
 804b2ef:	50                   	push   %eax
 804b2f0:	8b 43 04             	mov    0x4(%ebx),%eax
 804b2f3:	6a 04                	push   $0x4
 804b2f5:	ff 30                	pushl  (%eax)
 804b2f7:	53                   	push   %ebx
 804b2f8:	e8 ff 00 00 00       	call   804b3fc <log_backend_enable>
 804b2fd:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < log_backend_count_get(); i++) {
 804b300:	47                   	inc    %edi
 804b301:	83 c3 10             	add    $0x10,%ebx
 804b304:	eb cd                	jmp    804b2d3 <log_init+0x68>
}
 804b306:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b309:	5b                   	pop    %ebx
 804b30a:	5e                   	pop    %esi
 804b30b:	5f                   	pop    %edi
 804b30c:	5d                   	pop    %ebp
 804b30d:	c3                   	ret    

0804b30e <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
 804b30e:	f3 0f 1e fb          	endbr32 
 804b312:	55                   	push   %ebp
 804b313:	89 e5                	mov    %esp,%ebp
 804b315:	83 ec 08             	sub    $0x8,%esp
				COND_CODE_1(CONFIG_LOG_PROCESS_THREAD,
					K_MSEC(CONFIG_LOG_PROCESS_THREAD_STARTUP_DELAY_MS),
					K_NO_WAIT));
		k_thread_name_set(&logging_thread, "logging");
	} else {
		log_init();
 804b318:	e8 4e ff ff ff       	call   804b26b <log_init>
	}

	return 0;
}
 804b31d:	31 c0                	xor    %eax,%eax
 804b31f:	c9                   	leave  
 804b320:	c3                   	ret    

0804b321 <z_impl_log_panic>:
{
 804b321:	f3 0f 1e fb          	endbr32 
	if (panic_mode) {
 804b325:	80 3d ea 6a 05 08 00 	cmpb   $0x0,0x8056aea
 804b32c:	75 53                	jne    804b381 <z_impl_log_panic+0x60>
{
 804b32e:	55                   	push   %ebp
 804b32f:	89 e5                	mov    %esp,%ebp
 804b331:	57                   	push   %edi
	for (int i = 0; i < log_backend_count_get(); i++) {
 804b332:	31 ff                	xor    %edi,%edi
{
 804b334:	56                   	push   %esi
 804b335:	be d8 61 05 08       	mov    $0x80561d8,%esi
 804b33a:	53                   	push   %ebx
 804b33b:	bb e8 61 05 08       	mov    $0x80561e8,%ebx
 804b340:	81 eb d8 61 05 08    	sub    $0x80561d8,%ebx
 804b346:	c1 fb 04             	sar    $0x4,%ebx
 804b349:	83 ec 0c             	sub    $0xc,%esp
	log_init();
 804b34c:	e8 1a ff ff ff       	call   804b26b <log_init>
	for (int i = 0; i < log_backend_count_get(); i++) {
 804b351:	39 df                	cmp    %ebx,%edi
 804b353:	7d 1d                	jge    804b372 <z_impl_log_panic+0x51>
		if (log_backend_is_active(backend)) {
 804b355:	89 f0                	mov    %esi,%eax
 804b357:	e8 2f fe ff ff       	call   804b18b <log_backend_is_active>
 804b35c:	84 c0                	test   %al,%al
 804b35e:	74 0c                	je     804b36c <z_impl_log_panic+0x4b>
	backend->api->panic(backend);
 804b360:	83 ec 0c             	sub    $0xc,%esp
 804b363:	8b 06                	mov    (%esi),%eax
 804b365:	56                   	push   %esi
 804b366:	ff 50 14             	call   *0x14(%eax)
 804b369:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < log_backend_count_get(); i++) {
 804b36c:	47                   	inc    %edi
 804b36d:	83 c6 10             	add    $0x10,%esi
 804b370:	eb df                	jmp    804b351 <z_impl_log_panic+0x30>
	panic_mode = true;
 804b372:	c6 05 ea 6a 05 08 01 	movb   $0x1,0x8056aea
}
 804b379:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b37c:	5b                   	pop    %ebx
 804b37d:	5e                   	pop    %esi
 804b37e:	5f                   	pop    %edi
 804b37f:	5d                   	pop    %ebp
 804b380:	c3                   	ret    
 804b381:	c3                   	ret    

0804b382 <z_log_notify_backend_enabled>:
{
 804b382:	f3 0f 1e fb          	endbr32 
	backend_attached = true;
 804b386:	c6 05 e9 6a 05 08 01 	movb   $0x1,0x8056ae9
}
 804b38d:	c3                   	ret    

0804b38e <z_log_dropped>:
{
 804b38e:	f3 0f 1e fb          	endbr32 
 804b392:	55                   	push   %ebp
 804b393:	89 e5                	mov    %esp,%ebp
 804b395:	8b 45 08             	mov    0x8(%ebp),%eax
 804b398:	f0 ff 05 2c 6a 05 08 	lock incl 0x8056a2c
	if (buffered) {
 804b39f:	84 c0                	test   %al,%al
 804b3a1:	74 07                	je     804b3aa <z_log_dropped+0x1c>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 804b3a3:	f0 ff 0d 30 6a 05 08 	lock decl 0x8056a30
}
 804b3aa:	5d                   	pop    %ebp
 804b3ab:	c3                   	ret    

0804b3ac <z_log_msg2_commit>:
{
 804b3ac:	f3 0f 1e fb          	endbr32 
 804b3b0:	55                   	push   %ebp
 804b3b1:	89 e5                	mov    %esp,%ebp
 804b3b3:	53                   	push   %ebx
 804b3b4:	50                   	push   %eax
 804b3b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	msg->hdr.timestamp = timestamp_func();
 804b3b8:	ff 15 74 52 05 08    	call   *0x8055274
		msg_process(msgs, false);
 804b3be:	31 d2                	xor    %edx,%edx
	msg->hdr.timestamp = timestamp_func();
 804b3c0:	89 43 08             	mov    %eax,0x8(%ebx)
		msg_process(msgs, false);
 804b3c3:	89 d8                	mov    %ebx,%eax
}
 804b3c5:	59                   	pop    %ecx
 804b3c6:	5b                   	pop    %ebx
 804b3c7:	5d                   	pop    %ebp
		msg_process(msgs, false);
 804b3c8:	e9 c5 fd ff ff       	jmp    804b192 <msg_process>

0804b3cd <z_log_get_tag>:
{
 804b3cd:	f3 0f 1e fb          	endbr32 
}
 804b3d1:	31 c0                	xor    %eax,%eax
 804b3d3:	c3                   	ret    

0804b3d4 <log_source_name_get>:
{
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
 804b3d4:	f3 0f 1e fb          	endbr32 
 804b3d8:	55                   	push   %ebp
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
 804b3d9:	b8 d8 61 05 08       	mov    $0x80561d8,%eax
 804b3de:	2d c8 61 05 08       	sub    $0x80561c8,%eax
 804b3e3:	c1 e8 03             	shr    $0x3,%eax
 804b3e6:	89 e5                	mov    %esp,%ebp
 804b3e8:	89 c2                	mov    %eax,%edx
 804b3ea:	31 c0                	xor    %eax,%eax
 804b3ec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
 804b3ef:	39 d1                	cmp    %edx,%ecx
 804b3f1:	73 07                	jae    804b3fa <log_source_name_get+0x26>
	return __log_const_start[source_id].name;
 804b3f3:	8b 04 cd c8 61 05 08 	mov    0x80561c8(,%ecx,8),%eax
}
 804b3fa:	5d                   	pop    %ebp
 804b3fb:	c3                   	ret    

0804b3fc <log_backend_enable>:
}

void log_backend_enable(struct log_backend const *const backend,
			void *ctx,
			uint32_t level)
{
 804b3fc:	f3 0f 1e fb          	endbr32 
 804b400:	55                   	push   %ebp
 804b401:	89 e5                	mov    %esp,%ebp
 804b403:	57                   	push   %edi
 804b404:	56                   	push   %esi
 804b405:	53                   	push   %ebx
 804b406:	83 ec 0c             	sub    $0xc,%esp
 804b409:	8b 75 08             	mov    0x8(%ebp),%esi
 804b40c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
 804b40f:	89 f3                	mov    %esi,%ebx

	if (!IS_ENABLED(CONFIG_LOG1)) {
		__ASSERT(backend->api->process, "Backend does not support v2 API");
 804b411:	8b 06                	mov    (%esi),%eax
	id += backend - log_backend_get(0);
 804b413:	81 eb d8 61 05 08    	sub    $0x80561d8,%ebx
 804b419:	c1 fb 04             	sar    $0x4,%ebx
 804b41c:	43                   	inc    %ebx
		__ASSERT(backend->api->process, "Backend does not support v2 API");
 804b41d:	83 38 00             	cmpl   $0x0,(%eax)
 804b420:	75 39                	jne    804b45b <log_backend_enable+0x5f>
 804b422:	68 bb 00 00 00       	push   $0xbb
 804b427:	68 cf 1d 05 08       	push   $0x8051dcf
 804b42c:	68 27 1e 05 08       	push   $0x8051e27
 804b431:	68 1c 1c 05 08       	push   $0x8051c1c
 804b436:	e8 fe fc ff ff       	call   804b139 <assert_print>
 804b43b:	c7 04 24 3d 1e 05 08 	movl   $0x8051e3d,(%esp)
 804b442:	e8 f2 fc ff ff       	call   804b139 <assert_print>
 804b447:	58                   	pop    %eax
 804b448:	5a                   	pop    %edx
 804b449:	68 bb 00 00 00       	push   $0xbb
 804b44e:	68 cf 1d 05 08       	push   $0x8051dcf
 804b453:	e8 fc fc ff ff       	call   804b154 <assert_post_action>
 804b458:	83 c4 10             	add    $0x10,%esp
	backend->cb->id = id;
 804b45b:	8b 46 04             	mov    0x4(%esi),%eax
 804b45e:	88 58 04             	mov    %bl,0x4(%eax)
	backend->cb->ctx = ctx;
 804b461:	89 38                	mov    %edi,(%eax)
	backend->cb->active = true;
 804b463:	c6 40 05 01          	movb   $0x1,0x5(%eax)
	log_backend_id_set(backend, id);
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
}
 804b467:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b46a:	5b                   	pop    %ebx
 804b46b:	5e                   	pop    %esi
 804b46c:	5f                   	pop    %edi
 804b46d:	5d                   	pop    %ebp
	z_log_notify_backend_enabled();
 804b46e:	e9 0f ff ff ff       	jmp    804b382 <z_log_notify_backend_enabled>

0804b473 <out_func>:

	return ret;
}

static int out_func(int c, void *ctx)
{
 804b473:	f3 0f 1e fb          	endbr32 
 804b477:	55                   	push   %ebp
 804b478:	89 e5                	mov    %esp,%ebp
 804b47a:	83 ec 1c             	sub    $0x1c,%esp
 804b47d:	65 8b 0d 14 00 00 00 	mov    %gs:0x14,%ecx
 804b484:	89 4d f4             	mov    %ecx,-0xc(%ebp)
 804b487:	31 c9                	xor    %ecx,%ecx
	int idx;

	if (IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE)) {
		/* Backend must be thread safe in synchronous operation. */
		/* Need that step for big endian */
		char x = (char)c;
 804b489:	8b 55 08             	mov    0x8(%ebp),%edx
{
 804b48c:	8b 45 0c             	mov    0xc(%ebp),%eax
		char x = (char)c;
 804b48f:	88 55 f3             	mov    %dl,-0xd(%ebp)

		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
 804b492:	8b 50 04             	mov    0x4(%eax),%edx
 804b495:	ff 72 04             	pushl  0x4(%edx)
 804b498:	8d 55 f3             	lea    -0xd(%ebp),%edx
 804b49b:	6a 01                	push   $0x1
 804b49d:	52                   	push   %edx
 804b49e:	ff 10                	call   *(%eax)
 804b4a0:	83 c4 10             	add    $0x10,%esp
	out_ctx->buf[idx] = (uint8_t)c;

	__ASSERT_NO_MSG(out_ctx->control_block->offset <= out_ctx->size);

	return 0;
}
 804b4a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b4a6:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804b4ad:	74 05                	je     804b4b4 <out_func+0x41>
 804b4af:	e8 0c df ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804b4b4:	c9                   	leave  
 804b4b5:	31 c0                	xor    %eax,%eax
 804b4b7:	c3                   	ret    

0804b4b8 <cr_out_func>:

static int cr_out_func(int c, void *ctx)
{
 804b4b8:	f3 0f 1e fb          	endbr32 
 804b4bc:	55                   	push   %ebp
 804b4bd:	89 e5                	mov    %esp,%ebp
 804b4bf:	56                   	push   %esi
 804b4c0:	8b 75 08             	mov    0x8(%ebp),%esi
 804b4c3:	53                   	push   %ebx
 804b4c4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	out_func(c, ctx);
 804b4c7:	52                   	push   %edx
 804b4c8:	52                   	push   %edx
 804b4c9:	53                   	push   %ebx
 804b4ca:	56                   	push   %esi
 804b4cb:	e8 a3 ff ff ff       	call   804b473 <out_func>
 804b4d0:	83 c4 10             	add    $0x10,%esp
	if (c == '\n') {
 804b4d3:	83 fe 0a             	cmp    $0xa,%esi
 804b4d6:	75 0d                	jne    804b4e5 <cr_out_func+0x2d>
		out_func((int)'\r', ctx);
 804b4d8:	50                   	push   %eax
 804b4d9:	50                   	push   %eax
 804b4da:	53                   	push   %ebx
 804b4db:	6a 0d                	push   $0xd
 804b4dd:	e8 91 ff ff ff       	call   804b473 <out_func>
 804b4e2:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
}
 804b4e5:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804b4e8:	31 c0                	xor    %eax,%eax
 804b4ea:	5b                   	pop    %ebx
 804b4eb:	5e                   	pop    %esi
 804b4ec:	5d                   	pop    %ebp
 804b4ed:	c3                   	ret    

0804b4ee <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, uint8_t *buf, size_t len,
			 void *ctx)
{
 804b4ee:	55                   	push   %ebp
 804b4ef:	89 e5                	mov    %esp,%ebp
 804b4f1:	57                   	push   %edi
 804b4f2:	89 d7                	mov    %edx,%edi
 804b4f4:	56                   	push   %esi
 804b4f5:	89 c6                	mov    %eax,%esi
 804b4f7:	53                   	push   %ebx
 804b4f8:	89 cb                	mov    %ecx,%ebx
 804b4fa:	83 ec 0c             	sub    $0xc,%esp
	int processed;

	do {
		processed = outf(buf, len, ctx);
 804b4fd:	50                   	push   %eax
 804b4fe:	ff 75 08             	pushl  0x8(%ebp)
 804b501:	53                   	push   %ebx
 804b502:	57                   	push   %edi
 804b503:	ff d6                	call   *%esi
		len -= processed;
		buf += processed;
 804b505:	01 c7                	add    %eax,%edi
		processed = outf(buf, len, ctx);
 804b507:	83 c4 10             	add    $0x10,%esp
	} while (len != 0);
 804b50a:	29 c3                	sub    %eax,%ebx
 804b50c:	75 ef                	jne    804b4fd <buffer_write+0xf>
}
 804b50e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b511:	5b                   	pop    %ebx
 804b512:	5e                   	pop    %esi
 804b513:	5f                   	pop    %edi
 804b514:	5d                   	pop    %ebp
 804b515:	c3                   	ret    

0804b516 <print_formatted>:
{
 804b516:	55                   	push   %ebp
 804b517:	89 e5                	mov    %esp,%ebp
 804b519:	83 ec 08             	sub    $0x8,%esp
	va_start(args, fmt);
 804b51c:	8d 45 10             	lea    0x10(%ebp),%eax
	length = cbvprintf(out_func, (void *)output, fmt, args);
 804b51f:	50                   	push   %eax
 804b520:	ff 75 0c             	pushl  0xc(%ebp)
 804b523:	ff 75 08             	pushl  0x8(%ebp)
 804b526:	68 73 b4 04 08       	push   $0x804b473
 804b52b:	e8 21 f4 ff ff       	call   804a951 <cbvprintf>
 804b530:	83 c4 10             	add    $0x10,%esp
}
 804b533:	c9                   	leave  
 804b534:	c3                   	ret    

0804b535 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, log_timestamp_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
 804b535:	55                   	push   %ebp
 804b536:	89 e5                	mov    %esp,%ebp
 804b538:	57                   	push   %edi
 804b539:	89 d7                	mov    %edx,%edi
 804b53b:	56                   	push   %esi
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
 804b53c:	89 d6                	mov    %edx,%esi
{
 804b53e:	53                   	push   %ebx
 804b53f:	89 c3                	mov    %eax,%ebx
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
 804b541:	83 e6 02             	and    $0x2,%esi
{
 804b544:	83 ec 2c             	sub    $0x2c,%esp
 804b547:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b54a:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
 804b54d:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804b550:	8b 45 10             	mov    0x10(%ebp),%eax
 804b553:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804b556:	8b 45 14             	mov    0x14(%ebp),%eax
 804b559:	89 45 dc             	mov    %eax,-0x24(%ebp)
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
 804b55c:	89 d0                	mov    %edx,%eax
 804b55e:	83 e0 08             	and    $0x8,%eax
 804b561:	89 45 d8             	mov    %eax,-0x28(%ebp)
	const char *tag = z_log_get_tag();
 804b564:	e8 64 fe ff ff       	call   804b3cd <z_log_get_tag>
	uint32_t length = 0U;
 804b569:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (tag) {
 804b570:	85 c0                	test   %eax,%eax
 804b572:	74 13                	je     804b587 <prefix_print+0x52>
		length += print_formatted(output, "%s ", tag);
 804b574:	52                   	push   %edx
 804b575:	50                   	push   %eax
 804b576:	68 6d 1e 05 08       	push   $0x8051e6d
 804b57b:	53                   	push   %ebx
 804b57c:	e8 95 ff ff ff       	call   804b516 <print_formatted>
 804b581:	83 c4 10             	add    $0x10,%esp
 804b584:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	}

	if (stamp) {
 804b587:	85 f6                	test   %esi,%esi
 804b589:	0f 84 85 00 00 00    	je     804b614 <prefix_print+0xdf>
	if (!format) {
 804b58f:	f7 c7 44 00 00 00    	test   $0x44,%edi
 804b595:	75 14                	jne    804b5ab <prefix_print+0x76>
		length = print_formatted(output, "[%08lu] ", timestamp);
 804b597:	50                   	push   %eax
 804b598:	ff 75 08             	pushl  0x8(%ebp)
 804b59b:	68 71 1e 05 08       	push   $0x8051e71
 804b5a0:	53                   	push   %ebx
 804b5a1:	e8 70 ff ff ff       	call   804b516 <print_formatted>
 804b5a6:	83 c4 10             	add    $0x10,%esp
 804b5a9:	eb 66                	jmp    804b611 <prefix_print+0xdc>
	} else if (freq != 0U) {
 804b5ab:	8b 35 3c 6a 05 08    	mov    0x8056a3c,%esi
		length = 0;
 804b5b1:	31 c0                	xor    %eax,%eax
	} else if (freq != 0U) {
 804b5b3:	85 f6                	test   %esi,%esi
 804b5b5:	74 5a                	je     804b611 <prefix_print+0xdc>
		timestamp /= timestamp_div;
 804b5b7:	8b 45 08             	mov    0x8(%ebp),%eax
 804b5ba:	31 d2                	xor    %edx,%edx
 804b5bc:	b9 10 0e 00 00       	mov    $0xe10,%ecx
 804b5c1:	f7 35 38 6a 05 08    	divl   0x8056a38
 804b5c7:	31 d2                	xor    %edx,%edx
 804b5c9:	f7 f6                	div    %esi
 804b5cb:	89 55 cc             	mov    %edx,-0x34(%ebp)
		seconds -= hours * 3600U;
 804b5ce:	31 d2                	xor    %edx,%edx
 804b5d0:	f7 f1                	div    %ecx
 804b5d2:	89 c1                	mov    %eax,%ecx
		ms = (remainder * 1000U) / freq;
 804b5d4:	69 45 cc e8 03 00 00 	imul   $0x3e8,-0x34(%ebp),%eax
 804b5db:	89 55 c8             	mov    %edx,-0x38(%ebp)
 804b5de:	31 d2                	xor    %edx,%edx
 804b5e0:	f7 f6                	div    %esi
 804b5e2:	89 45 cc             	mov    %eax,-0x34(%ebp)
				length = print_formatted(output,
 804b5e5:	50                   	push   %eax
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 804b5e6:	69 c2 e8 03 00 00    	imul   $0x3e8,%edx,%eax
 804b5ec:	31 d2                	xor    %edx,%edx
 804b5ee:	f7 f6                	div    %esi
				length = print_formatted(output,
 804b5f0:	be 3c 00 00 00       	mov    $0x3c,%esi
 804b5f5:	31 d2                	xor    %edx,%edx
 804b5f7:	50                   	push   %eax
 804b5f8:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804b5fb:	ff 75 cc             	pushl  -0x34(%ebp)
 804b5fe:	f7 f6                	div    %esi
 804b600:	52                   	push   %edx
 804b601:	50                   	push   %eax
 804b602:	51                   	push   %ecx
 804b603:	68 7a 1e 05 08       	push   $0x8051e7a
 804b608:	53                   	push   %ebx
 804b609:	e8 08 ff ff ff       	call   804b516 <print_formatted>
 804b60e:	83 c4 20             	add    $0x20,%esp
		length += timestamp_print(output, flags, timestamp);
 804b611:	01 45 e4             	add    %eax,-0x1c(%ebp)
	if (color) {
 804b614:	83 e7 01             	and    $0x1,%edi
			output, "%s - - - - ",
			output->control_block->hostname ?
			output->control_block->hostname :
			"zephyr");
	} else {
		color_prefix(output, colors_on, level);
 804b617:	0f b6 75 e0          	movzbl -0x20(%ebp),%esi
	if (color) {
 804b61b:	74 20                	je     804b63d <prefix_print+0x108>
		const char *log_color = start && (colors[level] != NULL) ?
 804b61d:	8b 04 b5 70 12 05 08 	mov    0x8051270(,%esi,4),%eax
 804b624:	85 c0                	test   %eax,%eax
 804b626:	75 05                	jne    804b62d <prefix_print+0xf8>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
 804b628:	b8 5f 1e 05 08       	mov    $0x8051e5f,%eax
		print_formatted(output, "%s", log_color);
 804b62d:	52                   	push   %edx
 804b62e:	50                   	push   %eax
 804b62f:	68 57 28 05 08       	push   $0x8052857
 804b634:	53                   	push   %ebx
 804b635:	e8 dc fe ff ff       	call   804b516 <print_formatted>
 804b63a:	83 c4 10             	add    $0x10,%esp
	if (level_on) {
 804b63d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
	int total = 0;
 804b641:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	if (level_on) {
 804b648:	74 19                	je     804b663 <prefix_print+0x12e>
		total += print_formatted(output, "<%s> ", severity[level]);
 804b64a:	50                   	push   %eax
 804b64b:	ff 34 b5 84 12 05 08 	pushl  0x8051284(,%esi,4)
 804b652:	68 96 1e 05 08       	push   $0x8051e96
 804b657:	53                   	push   %ebx
 804b658:	e8 b9 fe ff ff       	call   804b516 <print_formatted>
 804b65d:	83 c4 10             	add    $0x10,%esp
 804b660:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (source_id >= 0) {
 804b663:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%ebp)
 804b668:	78 42                	js     804b6ac <prefix_print+0x177>
		total += print_formatted(output,
 804b66a:	0f bf 45 dc          	movswl -0x24(%ebp),%eax
 804b66e:	57                   	push   %edi
 804b66f:	57                   	push   %edi
 804b670:	50                   	push   %eax
	}

	length += ids_print(output, level_on, func_on,
 804b671:	0f b6 45 d0          	movzbl -0x30(%ebp),%eax
		total += print_formatted(output,
 804b675:	50                   	push   %eax
 804b676:	e8 59 fd ff ff       	call   804b3d4 <log_source_name_get>
 804b67b:	83 c4 10             	add    $0x10,%esp
 804b67e:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
 804b682:	ba 64 1e 05 08       	mov    $0x8051e64,%edx
 804b687:	74 14                	je     804b69d <prefix_print+0x168>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
 804b689:	89 f1                	mov    %esi,%ecx
 804b68b:	bf 01 00 00 00       	mov    $0x1,%edi
 804b690:	d3 e7                	shl    %cl,%edi
		total += print_formatted(output,
 804b692:	b9 69 1e 05 08       	mov    $0x8051e69,%ecx
 804b697:	83 e7 10             	and    $0x10,%edi
 804b69a:	0f 45 d1             	cmovne %ecx,%edx
 804b69d:	51                   	push   %ecx
 804b69e:	50                   	push   %eax
 804b69f:	52                   	push   %edx
 804b6a0:	53                   	push   %ebx
 804b6a1:	e8 70 fe ff ff       	call   804b516 <print_formatted>
 804b6a6:	01 45 e0             	add    %eax,-0x20(%ebp)
 804b6a9:	83 c4 10             	add    $0x10,%esp
	length += ids_print(output, level_on, func_on,
 804b6ac:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b6af:	03 45 e4             	add    -0x1c(%ebp),%eax
			domain_id, source_id, level);


	return length;
}
 804b6b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b6b5:	5b                   	pop    %ebx
 804b6b6:	5e                   	pop    %esi
 804b6b7:	5f                   	pop    %edi
 804b6b8:	5d                   	pop    %ebp
 804b6b9:	c3                   	ret    

0804b6ba <hexdump_line_print>:
{
 804b6ba:	55                   	push   %ebp
 804b6bb:	89 e5                	mov    %esp,%ebp
 804b6bd:	57                   	push   %edi
 804b6be:	89 d7                	mov    %edx,%edi
 804b6c0:	56                   	push   %esi
 804b6c1:	53                   	push   %ebx
 804b6c2:	89 c3                	mov    %eax,%ebx
 804b6c4:	83 ec 1c             	sub    $0x1c,%esp
 804b6c7:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b6ca:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 804b6cd:	a8 10                	test   $0x10,%al
 804b6cf:	75 1d                	jne    804b6ee <hexdump_line_print+0x34>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 804b6d1:	a8 20                	test   $0x20,%al
 804b6d3:	74 09                	je     804b6de <hexdump_line_print+0x24>
		print_formatted(ctx, "\n");
 804b6d5:	56                   	push   %esi
 804b6d6:	56                   	push   %esi
 804b6d7:	68 37 30 05 08       	push   $0x8053037
 804b6dc:	eb 07                	jmp    804b6e5 <hexdump_line_print+0x2b>
		print_formatted(ctx, "\r\n");
 804b6de:	51                   	push   %ecx
 804b6df:	51                   	push   %ecx
 804b6e0:	68 9c 1e 05 08       	push   $0x8051e9c
 804b6e5:	53                   	push   %ebx
 804b6e6:	e8 2b fe ff ff       	call   804b516 <print_formatted>
 804b6eb:	83 c4 10             	add    $0x10,%esp
{
 804b6ee:	31 f6                	xor    %esi,%esi
	for (int i = 0; i < prefix_offset; i++) {
 804b6f0:	3b 75 08             	cmp    0x8(%ebp),%esi
 804b6f3:	7d 13                	jge    804b708 <hexdump_line_print+0x4e>
		print_formatted(output, " ");
 804b6f5:	52                   	push   %edx
	for (int i = 0; i < prefix_offset; i++) {
 804b6f6:	46                   	inc    %esi
		print_formatted(output, " ");
 804b6f7:	52                   	push   %edx
 804b6f8:	68 a7 1e 05 08       	push   $0x8051ea7
 804b6fd:	53                   	push   %ebx
 804b6fe:	e8 13 fe ff ff       	call   804b516 <print_formatted>
 804b703:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < prefix_offset; i++) {
 804b706:	eb e8                	jmp    804b6f0 <hexdump_line_print+0x36>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 804b708:	31 f6                	xor    %esi,%esi
		if (i < length) {
 804b70a:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
 804b70d:	73 0d                	jae    804b71c <hexdump_line_print+0x62>
			print_formatted(output, "%02x ", data[i]);
 804b70f:	50                   	push   %eax
 804b710:	0f b6 04 37          	movzbl (%edi,%esi,1),%eax
 804b714:	50                   	push   %eax
 804b715:	68 9f 1e 05 08       	push   $0x8051e9f
 804b71a:	eb 07                	jmp    804b723 <hexdump_line_print+0x69>
			print_formatted(output, "   ");
 804b71c:	50                   	push   %eax
 804b71d:	50                   	push   %eax
 804b71e:	68 a5 1e 05 08       	push   $0x8051ea5
 804b723:	53                   	push   %ebx
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 804b724:	46                   	inc    %esi
			print_formatted(output, "   ");
 804b725:	e8 ec fd ff ff       	call   804b516 <print_formatted>
 804b72a:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 804b72d:	83 fe 10             	cmp    $0x10,%esi
 804b730:	74 1a                	je     804b74c <hexdump_line_print+0x92>
		if (i > 0 && !(i % 8)) {
 804b732:	f7 c6 07 00 00 00    	test   $0x7,%esi
 804b738:	75 d0                	jne    804b70a <hexdump_line_print+0x50>
			print_formatted(output, " ");
 804b73a:	50                   	push   %eax
 804b73b:	50                   	push   %eax
 804b73c:	68 a7 1e 05 08       	push   $0x8051ea7
 804b741:	53                   	push   %ebx
 804b742:	e8 cf fd ff ff       	call   804b516 <print_formatted>
 804b747:	83 c4 10             	add    $0x10,%esp
 804b74a:	eb be                	jmp    804b70a <hexdump_line_print+0x50>
	print_formatted(output, "|");
 804b74c:	50                   	push   %eax
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 804b74d:	31 f6                	xor    %esi,%esi
	print_formatted(output, "|");
 804b74f:	50                   	push   %eax
 804b750:	68 a9 1e 05 08       	push   $0x8051ea9
 804b755:	53                   	push   %ebx
 804b756:	e8 bb fd ff ff       	call   804b516 <print_formatted>
 804b75b:	83 c4 10             	add    $0x10,%esp
		if (i < length) {
 804b75e:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
 804b761:	76 29                	jbe    804b78c <hexdump_line_print+0xd2>
			char c = (char)data[i];
 804b763:	8a 14 37             	mov    (%edi,%esi,1),%dl
 804b766:	88 55 e3             	mov    %dl,-0x1d(%ebp)
			      isprint((int)c) ? c : '.');
 804b769:	e8 32 de ff ff       	call   80495a0 <__ctype_b_loc@plt>
 804b76e:	0f be 4d e3          	movsbl -0x1d(%ebp),%ecx
 804b772:	8b 00                	mov    (%eax),%eax
 804b774:	89 ca                	mov    %ecx,%edx
 804b776:	f6 44 48 01 40       	testb  $0x40,0x1(%eax,%ecx,2)
 804b77b:	b8 2e 00 00 00       	mov    $0x2e,%eax
			print_formatted(output, "%c",
 804b780:	51                   	push   %ecx
 804b781:	0f 44 d0             	cmove  %eax,%edx
 804b784:	52                   	push   %edx
 804b785:	68 ab 1e 05 08       	push   $0x8051eab
 804b78a:	eb 07                	jmp    804b793 <hexdump_line_print+0xd9>
			print_formatted(output, " ");
 804b78c:	50                   	push   %eax
 804b78d:	50                   	push   %eax
 804b78e:	68 a7 1e 05 08       	push   $0x8051ea7
 804b793:	53                   	push   %ebx
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 804b794:	46                   	inc    %esi
			print_formatted(output, " ");
 804b795:	e8 7c fd ff ff       	call   804b516 <print_formatted>
 804b79a:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 804b79d:	83 fe 10             	cmp    $0x10,%esi
 804b7a0:	74 1a                	je     804b7bc <hexdump_line_print+0x102>
		if (i > 0 && !(i % 8)) {
 804b7a2:	f7 c6 07 00 00 00    	test   $0x7,%esi
 804b7a8:	75 b4                	jne    804b75e <hexdump_line_print+0xa4>
			print_formatted(output, " ");
 804b7aa:	50                   	push   %eax
 804b7ab:	50                   	push   %eax
 804b7ac:	68 a7 1e 05 08       	push   $0x8051ea7
 804b7b1:	53                   	push   %ebx
 804b7b2:	e8 5f fd ff ff       	call   804b516 <print_formatted>
 804b7b7:	83 c4 10             	add    $0x10,%esp
 804b7ba:	eb a2                	jmp    804b75e <hexdump_line_print+0xa4>
}
 804b7bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b7bf:	5b                   	pop    %ebx
 804b7c0:	5e                   	pop    %esi
 804b7c1:	5f                   	pop    %edi
 804b7c2:	5d                   	pop    %ebp
 804b7c3:	c3                   	ret    

0804b7c4 <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
 804b7c4:	55                   	push   %ebp
 804b7c5:	89 e5                	mov    %esp,%ebp
 804b7c7:	56                   	push   %esi
 804b7c8:	89 d6                	mov    %edx,%esi
	if (color) {
 804b7ca:	83 e2 01             	and    $0x1,%edx
{
 804b7cd:	53                   	push   %ebx
 804b7ce:	89 c3                	mov    %eax,%ebx
	if (color) {
 804b7d0:	74 14                	je     804b7e6 <postfix_print+0x22>
		print_formatted(output, "%s", log_color);
 804b7d2:	51                   	push   %ecx
 804b7d3:	68 5f 1e 05 08       	push   $0x8051e5f
 804b7d8:	68 57 28 05 08       	push   $0x8052857
 804b7dd:	50                   	push   %eax
 804b7de:	e8 33 fd ff ff       	call   804b516 <print_formatted>
 804b7e3:	83 c4 10             	add    $0x10,%esp
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 804b7e6:	f7 c6 10 00 00 00    	test   $0x10,%esi
 804b7ec:	75 1e                	jne    804b80c <postfix_print+0x48>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 804b7ee:	83 e6 20             	and    $0x20,%esi
 804b7f1:	74 09                	je     804b7fc <postfix_print+0x38>
		print_formatted(ctx, "\n");
 804b7f3:	52                   	push   %edx
 804b7f4:	52                   	push   %edx
 804b7f5:	68 37 30 05 08       	push   $0x8053037
 804b7fa:	eb 07                	jmp    804b803 <postfix_print+0x3f>
		print_formatted(ctx, "\r\n");
 804b7fc:	50                   	push   %eax
 804b7fd:	50                   	push   %eax
 804b7fe:	68 9c 1e 05 08       	push   $0x8051e9c
 804b803:	53                   	push   %ebx
 804b804:	e8 0d fd ff ff       	call   804b516 <print_formatted>
 804b809:	83 c4 10             	add    $0x10,%esp
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
 804b80c:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804b80f:	5b                   	pop    %ebx
 804b810:	5e                   	pop    %esi
 804b811:	5d                   	pop    %ebp
 804b812:	c3                   	ret    

0804b813 <log_output_flush>:
{
 804b813:	f3 0f 1e fb          	endbr32 
 804b817:	55                   	push   %ebp
 804b818:	89 e5                	mov    %esp,%ebp
 804b81a:	53                   	push   %ebx
 804b81b:	83 ec 10             	sub    $0x10,%esp
 804b81e:	8b 5d 08             	mov    0x8(%ebp),%ebx
		     output->control_block->ctx);
 804b821:	8b 43 04             	mov    0x4(%ebx),%eax
	buffer_write(output->func, output->buf,
 804b824:	8b 53 08             	mov    0x8(%ebx),%edx
 804b827:	ff 70 04             	pushl  0x4(%eax)
 804b82a:	8b 08                	mov    (%eax),%ecx
 804b82c:	8b 03                	mov    (%ebx),%eax
 804b82e:	e8 bb fc ff ff       	call   804b4ee <buffer_write>
	output->control_block->offset = 0;
 804b833:	8b 43 04             	mov    0x4(%ebx),%eax
	buffer_write(output->func, output->buf,
 804b836:	83 c4 10             	add    $0x10,%esp
}
 804b839:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	output->control_block->offset = 0;
 804b83c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
 804b842:	c9                   	leave  
 804b843:	c3                   	ret    

0804b844 <log_output_msg2_process>:
	log_output_flush(output);
}

void log_output_msg2_process(const struct log_output *output,
			     struct log_msg2 *msg, uint32_t flags)
{
 804b844:	f3 0f 1e fb          	endbr32 
 804b848:	55                   	push   %ebp
 804b849:	89 e5                	mov    %esp,%ebp
 804b84b:	57                   	push   %edi
 804b84c:	56                   	push   %esi
 804b84d:	53                   	push   %ebx
 804b84e:	83 ec 1c             	sub    $0x1c,%esp
 804b851:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 804b854:	8b 45 10             	mov    0x10(%ebp),%eax
			-1;

		prefix_offset = prefix_print(output, flags, 0, timestamp,
					 level, domain_id, source_id);
	} else {
		prefix_offset = 0;
 804b857:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
{
 804b85e:	8b 75 08             	mov    0x8(%ebp),%esi
 *
 * @return Log level.
 */
static inline uint8_t log_msg2_get_level(struct log_msg2 *msg)
{
	return msg->hdr.desc.level;
 804b861:	8b 0b                	mov    (%ebx),%ecx
 804b863:	89 45 dc             	mov    %eax,-0x24(%ebp)
 804b866:	66 c1 e9 06          	shr    $0x6,%cx
	if (!raw_string) {
 804b86a:	89 c8                	mov    %ecx,%eax
 804b86c:	24 07                	and    $0x7,%al
 804b86e:	88 45 e7             	mov    %al,-0x19(%ebp)
 804b871:	74 41                	je     804b8b4 <log_output_msg2_process+0x70>
 *
 * @return Pointer to the source data.
 */
static inline const void *log_msg2_get_source(struct log_msg2 *msg)
{
	return msg->hdr.source;
 804b873:	8b 7b 04             	mov    0x4(%ebx),%edi
	return msg->hdr.desc.domain;
 804b876:	8a 03                	mov    (%ebx),%al
		int16_t source_id = source ?
 804b878:	89 fa                	mov    %edi,%edx
 804b87a:	c0 e8 03             	shr    $0x3,%al
 804b87d:	81 ea c8 61 05 08    	sub    $0x80561c8,%edx
 804b883:	89 d1                	mov    %edx,%ecx
 804b885:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 804b88a:	c1 e9 03             	shr    $0x3,%ecx
 804b88d:	85 ff                	test   %edi,%edi
 804b88f:	0f 45 d1             	cmovne %ecx,%edx
		prefix_offset = prefix_print(output, flags, 0, timestamp,
 804b892:	83 e0 07             	and    $0x7,%eax
 804b895:	31 c9                	xor    %ecx,%ecx
 804b897:	0f bf d2             	movswl %dx,%edx
 804b89a:	52                   	push   %edx
 804b89b:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804b89e:	50                   	push   %eax
 804b89f:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
 804b8a3:	50                   	push   %eax
 804b8a4:	89 f0                	mov    %esi,%eax
 804b8a6:	ff 73 08             	pushl  0x8(%ebx)
 804b8a9:	e8 87 fc ff ff       	call   804b535 <prefix_print>
 804b8ae:	83 c4 10             	add    $0x10,%esp
 804b8b1:	89 45 d8             	mov    %eax,-0x28(%ebp)
 */
static inline uint8_t *log_msg2_get_package(struct log_msg2 *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;

	return msg->data;
 804b8b4:	8d 7b 10             	lea    0x10(%ebx),%edi
	}

	size_t len;
	uint8_t *data = log_msg2_get_package(msg, &len);

	if (len) {
 804b8b7:	f7 03 00 fe 07 00    	testl  $0x7fe00,(%ebx)
 804b8bd:	74 52                	je     804b911 <log_output_msg2_process+0xcd>
		int err = cbpprintf(raw_string ? cr_out_func :  out_func,
 804b8bf:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
 804b8c3:	ba 73 b4 04 08       	mov    $0x804b473,%edx
 804b8c8:	b8 b8 b4 04 08       	mov    $0x804b4b8,%eax
 * returned from invoking @p out.
 */
static inline
int cbpprintf(cbprintf_cb out, void *ctx, void *packaged)
{
	return cbpprintf_external(out, cbvprintf, ctx, packaged);
 804b8cd:	57                   	push   %edi
 804b8ce:	0f 45 c2             	cmovne %edx,%eax
 804b8d1:	56                   	push   %esi
 804b8d2:	68 51 a9 04 08       	push   $0x804a951
 804b8d7:	50                   	push   %eax
 804b8d8:	e8 bd ed ff ff       	call   804a69a <cbpprintf_external>
 804b8dd:	83 c4 10             	add    $0x10,%esp
				    (void *)output, data);

		(void)err;
		__ASSERT_NO_MSG(err >= 0);
 804b8e0:	85 c0                	test   %eax,%eax
 804b8e2:	79 2d                	jns    804b911 <log_output_msg2_process+0xcd>
 804b8e4:	68 b9 02 00 00       	push   $0x2b9
 804b8e9:	68 ae 1e 05 08       	push   $0x8051eae
 804b8ee:	68 ec 1e 05 08       	push   $0x8051eec
 804b8f3:	68 1c 1c 05 08       	push   $0x8051c1c
 804b8f8:	e8 3c f8 ff ff       	call   804b139 <assert_print>
 804b8fd:	5a                   	pop    %edx
 804b8fe:	59                   	pop    %ecx
 804b8ff:	68 b9 02 00 00       	push   $0x2b9
 804b904:	68 ae 1e 05 08       	push   $0x8051eae
 804b909:	e8 46 f8 ff ff       	call   804b154 <assert_post_action>
 804b90e:	83 c4 10             	add    $0x10,%esp
	*len = msg->hdr.desc.data_len;
 804b911:	66 8b 43 02          	mov    0x2(%ebx),%ax
 804b915:	66 c1 e8 03          	shr    $0x3,%ax
	}

	data = log_msg2_get_data(msg, &len);
	if (len) {
 804b919:	25 ff 0f 00 00       	and    $0xfff,%eax
 804b91e:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804b921:	74 36                	je     804b959 <log_output_msg2_process+0x115>
	return msg->data + msg->hdr.desc.package_len;
 804b923:	8b 03                	mov    (%ebx),%eax
 804b925:	c1 e8 09             	shr    $0x9,%eax
 804b928:	25 ff 03 00 00       	and    $0x3ff,%eax
 804b92d:	01 c7                	add    %eax,%edi
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 804b92f:	83 7d e0 10          	cmpl   $0x10,-0x20(%ebp)
 804b933:	bb 10 00 00 00       	mov    $0x10,%ebx
		hexdump_line_print(output, data, length,
 804b938:	50                   	push   %eax
 804b939:	89 fa                	mov    %edi,%edx
 804b93b:	50                   	push   %eax
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 804b93c:	0f 46 5d e0          	cmovbe -0x20(%ebp),%ebx
		hexdump_line_print(output, data, length,
 804b940:	89 f0                	mov    %esi,%eax
 804b942:	ff 75 dc             	pushl  -0x24(%ebp)
 804b945:	ff 75 d8             	pushl  -0x28(%ebp)
 804b948:	89 d9                	mov    %ebx,%ecx
		data += length;
 804b94a:	01 df                	add    %ebx,%edi
		hexdump_line_print(output, data, length,
 804b94c:	e8 69 fd ff ff       	call   804b6ba <hexdump_line_print>
 804b951:	83 c4 10             	add    $0x10,%esp
	} while (len);
 804b954:	29 5d e0             	sub    %ebx,-0x20(%ebp)
 804b957:	75 d6                	jne    804b92f <log_output_msg2_process+0xeb>
		log_msg2_hexdump(output, data, len, prefix_offset, flags);
	}

	if (!raw_string) {
 804b959:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
 804b95d:	74 0e                	je     804b96d <log_output_msg2_process+0x129>
		postfix_print(output, flags, level);
 804b95f:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
 804b963:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804b966:	89 f0                	mov    %esi,%eax
 804b968:	e8 57 fe ff ff       	call   804b7c4 <postfix_print>
	}

	log_output_flush(output);
 804b96d:	89 75 08             	mov    %esi,0x8(%ebp)
}
 804b970:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b973:	5b                   	pop    %ebx
 804b974:	5e                   	pop    %esi
 804b975:	5f                   	pop    %edi
 804b976:	5d                   	pop    %ebp
	log_output_flush(output);
 804b977:	e9 97 fe ff ff       	jmp    804b813 <log_output_flush>

0804b97c <log_output_timestamp_freq_set>:
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
		     output->control_block->ctx);
}

void log_output_timestamp_freq_set(uint32_t frequency)
{
 804b97c:	f3 0f 1e fb          	endbr32 
 804b980:	55                   	push   %ebp
	timestamp_div = 1U;
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
 804b981:	31 c9                	xor    %ecx,%ecx
 804b983:	ba 01 00 00 00       	mov    $0x1,%edx
	timestamp_div = 1U;
 804b988:	c7 05 38 6a 05 08 01 	movl   $0x1,0x8056a38
 804b98f:	00 00 00 
{
 804b992:	89 e5                	mov    %esp,%ebp
 804b994:	8b 45 08             	mov    0x8(%ebp),%eax
	while (frequency > 1000000) {
 804b997:	3d 40 42 0f 00       	cmp    $0xf4240,%eax
 804b99c:	76 08                	jbe    804b9a6 <log_output_timestamp_freq_set+0x2a>
		frequency /= 2U;
 804b99e:	d1 e8                	shr    %eax
		timestamp_div *= 2U;
 804b9a0:	01 d2                	add    %edx,%edx
 804b9a2:	b1 01                	mov    $0x1,%cl
 804b9a4:	eb f1                	jmp    804b997 <log_output_timestamp_freq_set+0x1b>
 804b9a6:	84 c9                	test   %cl,%cl
 804b9a8:	74 06                	je     804b9b0 <log_output_timestamp_freq_set+0x34>
 804b9aa:	89 15 38 6a 05 08    	mov    %edx,0x8056a38
	}

	freq = frequency;
 804b9b0:	a3 3c 6a 05 08       	mov    %eax,0x8056a3c
}
 804b9b5:	5d                   	pop    %ebp
 804b9b6:	c3                   	ret    

0804b9b7 <z_log_msg2_finalize>:
	!(IS_ENABLED(CONFIG_LOG_FRONTEND) && \
	 (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY) || log_backend_count_get() == 0))

void z_log_msg2_finalize(struct log_msg2 *msg, const void *source,
			 const struct log_msg2_desc desc, const void *data)
{
 804b9b7:	f3 0f 1e fb          	endbr32 
 804b9bb:	55                   	push   %ebp
 804b9bc:	89 e5                	mov    %esp,%ebp
 804b9be:	57                   	push   %edi
 804b9bf:	8b 45 08             	mov    0x8(%ebp),%eax
 804b9c2:	8b 55 10             	mov    0x10(%ebp),%edx
 804b9c5:	56                   	push   %esi
 804b9c6:	8b 75 14             	mov    0x14(%ebp),%esi
 804b9c9:	53                   	push   %ebx
 804b9ca:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (!msg) {
 804b9cd:	85 c0                	test   %eax,%eax
 804b9cf:	75 09                	jne    804b9da <z_log_msg2_finalize+0x23>
	}

	msg->hdr.desc = desc;
	msg->hdr.source = source;
	z_log_msg2_commit(msg);
}
 804b9d1:	5b                   	pop    %ebx
 804b9d2:	5e                   	pop    %esi
 804b9d3:	5f                   	pop    %edi
 804b9d4:	5d                   	pop    %ebp
		z_log_dropped(false);
 804b9d5:	e9 b4 f9 ff ff       	jmp    804b38e <z_log_dropped>
	if (data) {
 804b9da:	85 f6                	test   %esi,%esi
 804b9dc:	74 1c                	je     804b9fa <z_log_msg2_finalize+0x43>
		uint8_t *d = msg->data + desc.package_len;
 804b9de:	89 d1                	mov    %edx,%ecx
 804b9e0:	c1 e9 09             	shr    $0x9,%ecx
 804b9e3:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
 804b9e9:	8d 7c 08 10          	lea    0x10(%eax,%ecx,1),%edi
		memcpy(d, data, desc.data_len);
 804b9ed:	89 d1                	mov    %edx,%ecx
 804b9ef:	c1 e9 13             	shr    $0x13,%ecx
 804b9f2:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
 804b9f8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	msg->hdr.desc = desc;
 804b9fa:	89 10                	mov    %edx,(%eax)
	msg->hdr.source = source;
 804b9fc:	89 58 04             	mov    %ebx,0x4(%eax)
}
 804b9ff:	5b                   	pop    %ebx
	z_log_msg2_commit(msg);
 804ba00:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804ba03:	5e                   	pop    %esi
 804ba04:	5f                   	pop    %edi
 804ba05:	5d                   	pop    %ebp
	z_log_msg2_commit(msg);
 804ba06:	e9 a1 f9 ff ff       	jmp    804b3ac <z_log_msg2_commit>

0804ba0b <z_impl_z_log_msg2_runtime_vcreate>:
#endif

void z_impl_z_log_msg2_runtime_vcreate(uint8_t domain_id, const void *source,
				uint8_t level, const void *data, size_t dlen,
				uint32_t package_flags, const char *fmt, va_list ap)
{
 804ba0b:	f3 0f 1e fb          	endbr32 
 804ba0f:	55                   	push   %ebp
 804ba10:	89 e5                	mov    %esp,%ebp
 804ba12:	57                   	push   %edi
 804ba13:	56                   	push   %esi
 804ba14:	53                   	push   %ebx
 804ba15:	83 ec 2c             	sub    $0x2c,%esp
 804ba18:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ba1b:	8b 7d 20             	mov    0x20(%ebp),%edi
 804ba1e:	8b 75 08             	mov    0x8(%ebp),%esi
 804ba21:	8b 5d 10             	mov    0x10(%ebp),%ebx
 804ba24:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804ba27:	8b 45 14             	mov    0x14(%ebp),%eax
 804ba2a:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804ba2d:	8b 45 24             	mov    0x24(%ebp),%eax
 804ba30:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804ba33:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804ba39:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804ba3c:	31 c0                	xor    %eax,%eax
	int plen;

	if (fmt) {
 804ba3e:	85 ff                	test   %edi,%edi
 804ba40:	74 47                	je     804ba89 <z_impl_z_log_msg2_runtime_vcreate+0x7e>
		va_list ap2;

		va_copy(ap2, ap);
		plen = cbvprintf_package(NULL, Z_LOG_MSG2_ALIGN_OFFSET,
 804ba42:	83 ec 0c             	sub    $0xc,%esp
 804ba45:	ff 75 d4             	pushl  -0x2c(%ebp)
 804ba48:	57                   	push   %edi
 804ba49:	ff 75 1c             	pushl  0x1c(%ebp)
 804ba4c:	6a 10                	push   $0x10
 804ba4e:	6a 00                	push   $0x0
 804ba50:	e8 a9 e7 ff ff       	call   804a1fe <cbvprintf_package>
 804ba55:	83 c4 20             	add    $0x20,%esp
					 package_flags, fmt, ap2);
		__ASSERT_NO_MSG(plen >= 0);
 804ba58:	85 c0                	test   %eax,%eax
 804ba5a:	79 2d                	jns    804ba89 <z_impl_z_log_msg2_runtime_vcreate+0x7e>
 804ba5c:	6a 67                	push   $0x67
 804ba5e:	68 15 1f 05 08       	push   $0x8051f15
 804ba63:	68 42 1f 05 08       	push   $0x8051f42
 804ba68:	68 1c 1c 05 08       	push   $0x8051c1c
 804ba6d:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804ba70:	e8 c4 f6 ff ff       	call   804b139 <assert_print>
 804ba75:	59                   	pop    %ecx
 804ba76:	58                   	pop    %eax
 804ba77:	6a 67                	push   $0x67
 804ba79:	68 15 1f 05 08       	push   $0x8051f15
 804ba7e:	e8 d1 f6 ff ff       	call   804b154 <assert_post_action>
 804ba83:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804ba86:	83 c4 10             	add    $0x10,%esp
	}

	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
	struct log_msg2 *msg;
	uint8_t *pkg;
	struct log_msg2_desc desc =
 804ba89:	83 e3 07             	and    $0x7,%ebx
 804ba8c:	83 e6 07             	and    $0x7,%esi
 804ba8f:	8b 55 18             	mov    0x18(%ebp),%edx
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
 804ba92:	8b 4d 18             	mov    0x18(%ebp),%ecx
	struct log_msg2_desc desc =
 804ba95:	c1 e6 03             	shl    $0x3,%esi
 804ba98:	c1 e3 06             	shl    $0x6,%ebx
 804ba9b:	09 f3                	or     %esi,%ebx
 804ba9d:	89 c6                	mov    %eax,%esi
 804ba9f:	c1 e2 13             	shl    $0x13,%edx
 804baa2:	c1 e6 09             	shl    $0x9,%esi
 804baa5:	81 e2 00 00 f8 7f    	and    $0x7ff80000,%edx
 804baab:	81 e6 00 fe 07 00    	and    $0x7fe00,%esi
 804bab1:	09 f3                	or     %esi,%ebx
 804bab3:	09 d3                	or     %edx,%ebx
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
 804bab5:	8d 54 08 17          	lea    0x17(%eax,%ecx,1),%edx
			pkg = alloca(plen);
		} else {
			pkg = msg ? msg->data : NULL;
		}
	} else {
		msg = alloca(msg_wlen * sizeof(int));
 804bab9:	89 e1                	mov    %esp,%ecx
 804babb:	83 e2 f8             	and    $0xfffffff8,%edx
 804babe:	83 c2 1b             	add    $0x1b,%edx
 804bac1:	89 d6                	mov    %edx,%esi
 804bac3:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
 804bac9:	29 d1                	sub    %edx,%ecx
 804bacb:	83 e6 f0             	and    $0xfffffff0,%esi
 804bace:	89 ca                	mov    %ecx,%edx
 804bad0:	39 d4                	cmp    %edx,%esp
 804bad2:	74 10                	je     804bae4 <z_impl_z_log_msg2_runtime_vcreate+0xd9>
 804bad4:	81 ec 00 10 00 00    	sub    $0x1000,%esp
 804bada:	83 8c 24 fc 0f 00 00 	orl    $0x0,0xffc(%esp)
 804bae1:	00 
 804bae2:	eb ec                	jmp    804bad0 <z_impl_z_log_msg2_runtime_vcreate+0xc5>
 804bae4:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
 804baea:	29 f4                	sub    %esi,%esp
 804baec:	85 f6                	test   %esi,%esi
 804baee:	74 05                	je     804baf5 <z_impl_z_log_msg2_runtime_vcreate+0xea>
 804baf0:	83 4c 34 fc 00       	orl    $0x0,-0x4(%esp,%esi,1)
 804baf5:	8d 74 24 0f          	lea    0xf(%esp),%esi
 804baf9:	83 e6 f0             	and    $0xfffffff0,%esi
		pkg = msg->data;
	}

	if (pkg && fmt) {
 804bafc:	85 ff                	test   %edi,%edi
 804bafe:	74 48                	je     804bb48 <z_impl_z_log_msg2_runtime_vcreate+0x13d>
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
 804bb00:	83 ec 0c             	sub    $0xc,%esp
 804bb03:	ff 75 d4             	pushl  -0x2c(%ebp)
 804bb06:	57                   	push   %edi
 804bb07:	ff 75 1c             	pushl  0x1c(%ebp)
 804bb0a:	50                   	push   %eax
		pkg = msg->data;
 804bb0b:	8d 46 10             	lea    0x10(%esi),%eax
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
 804bb0e:	50                   	push   %eax
 804bb0f:	e8 ea e6 ff ff       	call   804a1fe <cbvprintf_package>
 804bb14:	83 c4 20             	add    $0x20,%esp
		__ASSERT_NO_MSG(plen >= 0);
 804bb17:	85 c0                	test   %eax,%eax
 804bb19:	79 2d                	jns    804bb48 <z_impl_z_log_msg2_runtime_vcreate+0x13d>
 804bb1b:	68 81 00 00 00       	push   $0x81
 804bb20:	68 15 1f 05 08       	push   $0x8051f15
 804bb25:	68 42 1f 05 08       	push   $0x8051f42
 804bb2a:	68 1c 1c 05 08       	push   $0x8051c1c
 804bb2f:	e8 05 f6 ff ff       	call   804b139 <assert_print>
 804bb34:	58                   	pop    %eax
 804bb35:	5a                   	pop    %edx
 804bb36:	68 81 00 00 00       	push   $0x81
 804bb3b:	68 15 1f 05 08       	push   $0x8051f15
 804bb40:	e8 0f f6 ff ff       	call   804b154 <assert_post_action>
 804bb45:	83 c4 10             	add    $0x10,%esp
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_msg(source, desc, pkg, data);
	}

	if (BACKENDS_IN_USE()) {
		z_log_msg2_finalize(msg, source, desc, data);
 804bb48:	ff 75 cc             	pushl  -0x34(%ebp)
 804bb4b:	53                   	push   %ebx
 804bb4c:	ff 75 d0             	pushl  -0x30(%ebp)
 804bb4f:	56                   	push   %esi
 804bb50:	e8 62 fe ff ff       	call   804b9b7 <z_log_msg2_finalize>
 804bb55:	83 c4 10             	add    $0x10,%esp
	}
}
 804bb58:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bb5b:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804bb62:	74 05                	je     804bb69 <z_impl_z_log_msg2_runtime_vcreate+0x15e>
 804bb64:	e8 57 d8 ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804bb69:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bb6c:	5b                   	pop    %ebx
 804bb6d:	5e                   	pop    %esi
 804bb6e:	5f                   	pop    %edi
 804bb6f:	5d                   	pop    %ebp
 804bb70:	c3                   	ret    

0804bb71 <format_set>:

	log_output_func(&log_output_posix, &msg->log, flags);
}

static int format_set(const struct log_backend *const backend, uint32_t log_type)
{
 804bb71:	f3 0f 1e fb          	endbr32 
 804bb75:	55                   	push   %ebp
 804bb76:	89 e5                	mov    %esp,%ebp
	log_format_current = log_type;
 804bb78:	8b 45 0c             	mov    0xc(%ebp),%eax
	return 0;
}
 804bb7b:	5d                   	pop    %ebp
	log_format_current = log_type;
 804bb7c:	a3 54 6a 05 08       	mov    %eax,0x8056a54
}
 804bb81:	31 c0                	xor    %eax,%eax
 804bb83:	c3                   	ret    

0804bb84 <panic>:
{
 804bb84:	f3 0f 1e fb          	endbr32 
 804bb88:	55                   	push   %ebp
 804bb89:	89 e5                	mov    %esp,%ebp
	log_output_flush(&log_output_posix);
 804bb8b:	c7 45 08 98 12 05 08 	movl   $0x8051298,0x8(%ebp)
}
 804bb92:	5d                   	pop    %ebp
	log_output_flush(&log_output_posix);
 804bb93:	e9 7b fc ff ff       	jmp    804b813 <log_output_flush>

0804bb98 <char_out>:
{
 804bb98:	f3 0f 1e fb          	endbr32 
 804bb9c:	55                   	push   %ebp
 804bb9d:	89 e5                	mov    %esp,%ebp
 804bb9f:	56                   	push   %esi
 804bba0:	8b 75 0c             	mov    0xc(%ebp),%esi
 804bba3:	53                   	push   %ebx
 804bba4:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804bba7:	01 de                	add    %ebx,%esi
	for (size_t i = 0; i < length; i++) {
 804bba9:	39 f3                	cmp    %esi,%ebx
 804bbab:	74 5d                	je     804bc0a <char_out+0x72>
		preprint_char(data[i]);
 804bbad:	0f b6 13             	movzbl (%ebx),%edx
 804bbb0:	89 d0                	mov    %edx,%eax
	if (c == '\r') {
 804bbb2:	80 fa 0d             	cmp    $0xd,%dl
 804bbb5:	74 50                	je     804bc07 <char_out+0x6f>
	if (c != '\n') {
 804bbb7:	83 fa 0a             	cmp    $0xa,%edx
 804bbba:	75 27                	jne    804bbe3 <char_out+0x4b>
		posix_print_trace("%s\n", stdout_buff);
 804bbbc:	50                   	push   %eax
 804bbbd:	50                   	push   %eax
 804bbbe:	68 20 64 05 08       	push   $0x8056420
 804bbc3:	68 b0 2b 05 08       	push   $0x8052bb0
 804bbc8:	e8 c3 17 00 00       	call   804d390 <posix_print_trace>
		stdout_buff[0] = 0;
 804bbcd:	c6 05 20 64 05 08 00 	movb   $0x0,0x8056420
		posix_print_trace("%s\n", stdout_buff);
 804bbd4:	83 c4 10             	add    $0x10,%esp
		n_pend = 0;
 804bbd7:	c7 05 58 6a 05 08 00 	movl   $0x0,0x8056a58
 804bbde:	00 00 00 
		stdout_buff[0] = 0;
 804bbe1:	eb 24                	jmp    804bc07 <char_out+0x6f>
		stdout_buff[n_pend++] = c;
 804bbe3:	8b 0d 58 6a 05 08    	mov    0x8056a58,%ecx
 804bbe9:	8d 51 01             	lea    0x1(%ecx),%edx
 804bbec:	88 81 20 64 05 08    	mov    %al,0x8056420(%ecx)
 804bbf2:	89 15 58 6a 05 08    	mov    %edx,0x8056a58
		stdout_buff[n_pend] = 0;
 804bbf8:	c6 81 21 64 05 08 00 	movb   $0x0,0x8056421(%ecx)
	if (printnow) {
 804bbff:	81 fa fe 00 00 00    	cmp    $0xfe,%edx
 804bc05:	7f b5                	jg     804bbbc <char_out+0x24>
	for (size_t i = 0; i < length; i++) {
 804bc07:	43                   	inc    %ebx
 804bc08:	eb 9f                	jmp    804bba9 <char_out+0x11>
}
 804bc0a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc0d:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804bc10:	5b                   	pop    %ebx
 804bc11:	5e                   	pop    %esi
 804bc12:	5d                   	pop    %ebp
 804bc13:	c3                   	ret    

0804bc14 <process>:
{
 804bc14:	f3 0f 1e fb          	endbr32 
 804bc18:	55                   	push   %ebp
 804bc19:	89 e5                	mov    %esp,%ebp
 804bc1b:	83 ec 14             	sub    $0x14,%esp
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
 804bc1e:	ff 35 54 6a 05 08    	pushl  0x8056a54
 804bc24:	e8 fb f5 ff ff       	call   804b224 <log_format_func_t_get>
 804bc29:	83 c4 0c             	add    $0xc,%esp
	log_output_func(&log_output_posix, &msg->log, flags);
 804bc2c:	6a 0f                	push   $0xf
 804bc2e:	ff 75 0c             	pushl  0xc(%ebp)
 804bc31:	68 98 12 05 08       	push   $0x8051298
 804bc36:	ff d0                	call   *%eax
 804bc38:	83 c4 10             	add    $0x10,%esp
}
 804bc3b:	c9                   	leave  
 804bc3c:	c3                   	ret    

0804bc3d <__cxa_atexit>:
 * do not need to be deleted
 *
 * @retval 0 on success.
 */
int __cxa_atexit(void (*destructor)(void *), void *objptr, void *dso)
{
 804bc3d:	f3 0f 1e fb          	endbr32 
	ARG_UNUSED(destructor);
	ARG_UNUSED(objptr);
	ARG_UNUSED(dso);
	return 0;
}
 804bc41:	31 c0                	xor    %eax,%eax
 804bc43:	c3                   	ret    

0804bc44 <sys_trace_isr_enter>:

#include <zephyr/init.h>
#include <string.h>
#include <zephyr/kernel.h>

void sys_trace_isr_enter(void) {}
 804bc44:	f3 0f 1e fb          	endbr32 
 804bc48:	c3                   	ret    

0804bc49 <sys_trace_isr_exit>:
 804bc49:	f3 0f 1e fb          	endbr32 
 804bc4d:	c3                   	ret    

0804bc4e <sys_trace_idle>:
 804bc4e:	f3 0f 1e fb          	endbr32 
 804bc52:	c3                   	ret    

0804bc53 <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
 804bc53:	f3 0f 1e fb          	endbr32 
 804bc57:	55                   	push   %ebp
 804bc58:	89 e5                	mov    %esp,%ebp
 804bc5a:	83 ec 08             	sub    $0x8,%esp
	sys_trace_idle();
 804bc5d:	e8 ec ff ff ff       	call   804bc4e <sys_trace_idle>
	posix_irq_full_unlock();
 804bc62:	e8 44 12 00 00       	call   804ceab <posix_irq_full_unlock>
	posix_halt_cpu();
}
 804bc67:	c9                   	leave  
	posix_halt_cpu();
 804bc68:	e9 95 06 00 00       	jmp    804c302 <posix_halt_cpu>

0804bc6d <arch_system_halt>:
#include <inttypes.h>
#include <zephyr/logging/log_ctrl.h>
#include <zephyr/arch/posix/posix_soc_if.h>

FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
 804bc6d:	f3 0f 1e fb          	endbr32 
 804bc71:	55                   	push   %ebp
 804bc72:	89 e5                	mov    %esp,%ebp
 804bc74:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(reason);

	posix_print_error_and_exit("Exiting due to fatal error\n");
 804bc77:	68 65 1f 05 08       	push   $0x8051f65
 804bc7c:	e8 bd 16 00 00       	call   804d33e <posix_print_error_and_exit>
 804bc81:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 804bc84:	6a 15                	push   $0x15
 804bc86:	68 81 1f 05 08       	push   $0x8051f81
 804bc8b:	68 c9 1c 05 08       	push   $0x8051cc9
 804bc90:	e8 a9 16 00 00       	call   804d33e <posix_print_error_and_exit>
 804bc95:	83 c4 10             	add    $0x10,%esp

0804bc98 <arch_irq_enable>:
	posix_irq_offload(routine, parameter);
}
#endif

void arch_irq_enable(unsigned int irq)
{
 804bc98:	f3 0f 1e fb          	endbr32 
	posix_irq_enable(irq);
 804bc9c:	e9 20 12 00 00       	jmp    804cec1 <posix_irq_enable>

0804bca1 <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
 804bca1:	85 c0                	test   %eax,%eax
 804bca3:	74 16                	je     804bcbb <pc_safe_call+0x1a>
{
 804bca5:	55                   	push   %ebp
 804bca6:	89 e5                	mov    %esp,%ebp
 804bca8:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804bcab:	52                   	push   %edx
 804bcac:	68 ac 1f 05 08       	push   $0x8051fac
 804bcb1:	e8 88 16 00 00       	call   804d33e <posix_print_error_and_exit>
 804bcb6:	83 c4 10             	add    $0x10,%esp
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
 804bcb9:	c9                   	leave  
 804bcba:	c3                   	ret    
 804bcbb:	c3                   	ret    

0804bcbc <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
 804bcbc:	55                   	push   %ebp
 804bcbd:	89 e5                	mov    %esp,%ebp
 804bcbf:	83 ec 14             	sub    $0x14,%esp
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
 804bcc2:	68 60 6a 05 08       	push   $0x8056a60
 804bcc7:	e8 34 d6 ff ff       	call   8049300 <pthread_mutex_unlock@plt>
 804bccc:	83 c4 10             	add    $0x10,%esp
 804bccf:	ba c6 1f 05 08       	mov    $0x8051fc6,%edx
 804bcd4:	e8 c8 ff ff ff       	call   804bca1 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
 804bcd9:	e8 b2 d6 ff ff       	call   8049390 <pthread_self@plt>
 804bcde:	83 ec 0c             	sub    $0xc,%esp
 804bce1:	50                   	push   %eax
 804bce2:	e8 79 d8 ff ff       	call   8049560 <pthread_detach@plt>
 804bce7:	83 c4 10             	add    $0x10,%esp
}
 804bcea:	c9                   	leave  
 804bceb:	c3                   	ret    

0804bcec <abort_tail>:
{
 804bcec:	55                   	push   %ebp
	threads_table[this_th_nbr].running = false;
 804bced:	6b c0 14             	imul   $0x14,%eax,%eax
{
 804bcf0:	89 e5                	mov    %esp,%ebp
 804bcf2:	83 ec 08             	sub    $0x8,%esp
	threads_table[this_th_nbr].running = false;
 804bcf5:	03 05 7c 6a 05 08    	add    0x8056a7c,%eax
 804bcfb:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	threads_table[this_th_nbr].state = ABORTED;
 804bcff:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
	posix_preexit_cleanup();
 804bd05:	e8 b2 ff ff ff       	call   804bcbc <posix_preexit_cleanup>
	pthread_exit(NULL);
 804bd0a:	83 ec 0c             	sub    $0xc,%esp
 804bd0d:	6a 00                	push   $0x0
 804bd0f:	e8 bc d7 ff ff       	call   80494d0 <pthread_exit@plt>

0804bd14 <posix_wait_until_allowed>:
{
 804bd14:	55                   	push   %ebp
 804bd15:	89 e5                	mov    %esp,%ebp
 804bd17:	56                   	push   %esi
	threads_table[this_th_nbr].running = false;
 804bd18:	6b f0 14             	imul   $0x14,%eax,%esi
{
 804bd1b:	53                   	push   %ebx
 804bd1c:	89 c3                	mov    %eax,%ebx
	threads_table[this_th_nbr].running = false;
 804bd1e:	a1 7c 6a 05 08       	mov    0x8056a7c,%eax
 804bd23:	c6 44 30 04 00       	movb   $0x0,0x4(%eax,%esi,1)
	while (this_th_nbr != currently_allowed_thread) {
 804bd28:	39 1d 5c 6a 05 08    	cmp    %ebx,0x8056a5c
 804bd2e:	74 2a                	je     804bd5a <posix_wait_until_allowed+0x46>
		pthread_cond_wait(&cond_threads, &mtx_threads);
 804bd30:	50                   	push   %eax
 804bd31:	50                   	push   %eax
 804bd32:	68 60 6a 05 08       	push   $0x8056a60
 804bd37:	68 20 65 05 08       	push   $0x8056520
 804bd3c:	e8 5f d6 ff ff       	call   80493a0 <pthread_cond_wait@plt>
		if (threads_table &&
 804bd41:	a1 7c 6a 05 08       	mov    0x8056a7c,%eax
		pthread_cond_wait(&cond_threads, &mtx_threads);
 804bd46:	83 c4 10             	add    $0x10,%esp
		if (threads_table &&
 804bd49:	85 c0                	test   %eax,%eax
 804bd4b:	74 db                	je     804bd28 <posix_wait_until_allowed+0x14>
 804bd4d:	83 3c 30 02          	cmpl   $0x2,(%eax,%esi,1)
 804bd51:	75 d5                	jne    804bd28 <posix_wait_until_allowed+0x14>
			abort_tail(this_th_nbr);
 804bd53:	89 d8                	mov    %ebx,%eax
 804bd55:	e8 92 ff ff ff       	call   804bcec <abort_tail>
	threads_table[this_th_nbr].running = true;
 804bd5a:	a1 7c 6a 05 08       	mov    0x8056a7c,%eax
 804bd5f:	c6 44 30 04 01       	movb   $0x1,0x4(%eax,%esi,1)
}
 804bd64:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804bd67:	5b                   	pop    %ebx
 804bd68:	5e                   	pop    %esi
 804bd69:	5d                   	pop    %ebp
 804bd6a:	c3                   	ret    

0804bd6b <posix_cleanup_handler>:

/**
 * Handler called when any thread is cancelled or exits
 */
static void posix_cleanup_handler(void *arg)
{
 804bd6b:	f3 0f 1e fb          	endbr32 
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
 804bd6f:	80 3d eb 6a 05 08 00 	cmpb   $0x0,0x8056aeb
 804bd76:	74 2b                	je     804bda3 <posix_cleanup_handler+0x38>
{
 804bd78:	55                   	push   %ebp
 804bd79:	89 e5                	mov    %esp,%ebp
 804bd7b:	83 ec 14             	sub    $0x14,%esp
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
 804bd7e:	68 60 6a 05 08       	push   $0x8056a60
 804bd83:	e8 78 d5 ff ff       	call   8049300 <pthread_mutex_unlock@plt>
 804bd88:	83 c4 10             	add    $0x10,%esp
 804bd8b:	ba c6 1f 05 08       	mov    $0x8051fc6,%edx
 804bd90:	e8 0c ff ff ff       	call   804bca1 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
 804bd95:	e8 f6 d5 ff ff       	call   8049390 <pthread_self@plt>
 804bd9a:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804bd9d:	c9                   	leave  
	pthread_detach(pthread_self());
 804bd9e:	e9 bd d7 ff ff       	jmp    8049560 <pthread_detach@plt>
 804bda3:	c3                   	ret    

0804bda4 <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
 804bda4:	f3 0f 1e fb          	endbr32 
 804bda8:	55                   	push   %ebp
 804bda9:	89 e5                	mov    %esp,%ebp
 804bdab:	83 ec 54             	sub    $0x54,%esp
 804bdae:	8b 45 08             	mov    0x8(%ebp),%eax
 804bdb1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 804bdb4:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804bdba:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804bdbd:	31 c0                	xor    %eax,%eax

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804bdbf:	68 60 6a 05 08       	push   $0x8056a60
 804bdc4:	e8 07 d6 ff ff       	call   80493d0 <pthread_mutex_lock@plt>
 804bdc9:	83 c4 10             	add    $0x10,%esp
 804bdcc:	ba e9 1f 05 08       	mov    $0x8051fe9,%edx
 804bdd1:	e8 cb fe ff ff       	call   804bca1 <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
 804bdd6:	83 3d 7c 6a 05 08 00 	cmpl   $0x0,0x8056a7c
 804bddd:	75 17                	jne    804bdf6 <posix_thread_starter+0x52>
		posix_cleanup_handler(arg);
 804bddf:	83 ec 0c             	sub    $0xc,%esp
 804bde2:	ff 75 c4             	pushl  -0x3c(%ebp)
 804bde5:	e8 81 ff ff ff       	call   804bd6b <posix_cleanup_handler>
		pthread_exit(NULL);
 804bdea:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804bdf1:	e8 da d6 ff ff       	call   80494d0 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
 804bdf6:	50                   	push   %eax
 804bdf7:	50                   	push   %eax
 804bdf8:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804bdfb:	6a 00                	push   $0x0
 804bdfd:	50                   	push   %eax
 804bdfe:	e8 ed d6 ff ff       	call   80494f0 <__sigsetjmp@plt>
 804be03:	f3 0f 1e fb          	endbr32 
 804be07:	83 c4 10             	add    $0x10,%esp
 804be0a:	85 c0                	test   %eax,%eax
 804be0c:	74 16                	je     804be24 <posix_thread_starter+0x80>
 804be0e:	83 ec 0c             	sub    $0xc,%esp
 804be11:	ff 75 c4             	pushl  -0x3c(%ebp)
 804be14:	e8 52 ff ff ff       	call   804bd6b <posix_cleanup_handler>
 804be19:	83 c4 10             	add    $0x10,%esp
 804be1c:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804be1f:	e8 ec d6 ff ff       	call   8049510 <__pthread_unwind_next@plt>
 804be24:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804be27:	e8 44 d5 ff ff       	call   8049370 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
 804be2c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804be2f:	e8 e0 fe ff ff       	call   804bd14 <posix_wait_until_allowed>

	posix_new_thread_pre_start();
 804be34:	e8 9e 03 00 00       	call   804c1d7 <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
 804be39:	6b 45 c4 14          	imul   $0x14,-0x3c(%ebp),%eax
 804be3d:	03 05 7c 6a 05 08    	add    0x8056a7c,%eax
 804be43:	8b 40 10             	mov    0x10(%eax),%eax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
 804be46:	ff 70 0c             	pushl  0xc(%eax)
 804be49:	ff 70 08             	pushl  0x8(%eax)
 804be4c:	ff 70 04             	pushl  0x4(%eax)
 804be4f:	ff 30                	pushl  (%eax)
 804be51:	e8 60 e9 ff ff       	call   804a7b6 <z_thread_entry>

0804be56 <posix_swap>:
{
 804be56:	f3 0f 1e fb          	endbr32 
 804be5a:	55                   	push   %ebp
 804be5b:	89 e5                	mov    %esp,%ebp
 804be5d:	53                   	push   %ebx
 804be5e:	83 ec 10             	sub    $0x10,%esp
	currently_allowed_thread = next_allowed_th;
 804be61:	8b 45 08             	mov    0x8(%ebp),%eax
{
 804be64:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804be67:	68 20 65 05 08       	push   $0x8056520
	currently_allowed_thread = next_allowed_th;
 804be6c:	a3 5c 6a 05 08       	mov    %eax,0x8056a5c
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804be71:	e8 da d4 ff ff       	call   8049350 <pthread_cond_broadcast@plt>
 804be76:	83 c4 10             	add    $0x10,%esp
 804be79:	ba 0a 20 05 08       	mov    $0x805200a,%edx
 804be7e:	e8 1e fe ff ff       	call   804bca1 <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
 804be83:	6b c3 14             	imul   $0x14,%ebx,%eax
 804be86:	03 05 7c 6a 05 08    	add    0x8056a7c,%eax
 804be8c:	83 38 02             	cmpl   $0x2,(%eax)
		abort_tail(this_th_nbr);
 804be8f:	89 d8                	mov    %ebx,%eax
	if (threads_table[this_th_nbr].state == ABORTING) {
 804be91:	75 05                	jne    804be98 <posix_swap+0x42>
		abort_tail(this_th_nbr);
 804be93:	e8 54 fe ff ff       	call   804bcec <abort_tail>
}
 804be98:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804be9b:	c9                   	leave  
		posix_wait_until_allowed(this_th_nbr);
 804be9c:	e9 73 fe ff ff       	jmp    804bd14 <posix_wait_until_allowed>

0804bea1 <posix_main_thread_start>:
{
 804bea1:	f3 0f 1e fb          	endbr32 
 804bea5:	55                   	push   %ebp
 804bea6:	89 e5                	mov    %esp,%ebp
 804bea8:	83 ec 14             	sub    $0x14,%esp
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804beab:	68 20 65 05 08       	push   $0x8056520
	currently_allowed_thread = next_allowed_th;
 804beb0:	8b 45 08             	mov    0x8(%ebp),%eax
 804beb3:	a3 5c 6a 05 08       	mov    %eax,0x8056a5c
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804beb8:	e8 93 d4 ff ff       	call   8049350 <pthread_cond_broadcast@plt>
 804bebd:	83 c4 10             	add    $0x10,%esp
 804bec0:	ba 0a 20 05 08       	mov    $0x805200a,%edx
 804bec5:	e8 d7 fd ff ff       	call   804bca1 <pc_safe_call>
	posix_preexit_cleanup();
 804beca:	e8 ed fd ff ff       	call   804bcbc <posix_preexit_cleanup>
	pthread_exit(NULL);
 804becf:	83 ec 0c             	sub    $0xc,%esp
 804bed2:	6a 00                	push   $0x0
 804bed4:	e8 f7 d5 ff ff       	call   80494d0 <pthread_exit@plt>

0804bed9 <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
 804bed9:	f3 0f 1e fb          	endbr32 
 804bedd:	55                   	push   %ebp
	for (int i = 0; i < threads_table_size; i++) {
 804bede:	31 d2                	xor    %edx,%edx
{
 804bee0:	89 e5                	mov    %esp,%ebp
 804bee2:	57                   	push   %edi
 804bee3:	56                   	push   %esi
 804bee4:	53                   	push   %ebx
 804bee5:	83 ec 0c             	sub    $0xc,%esp
 804bee8:	8b 75 08             	mov    0x8(%ebp),%esi
	for (int i = 0; i < threads_table_size; i++) {
 804beeb:	a1 80 6a 05 08       	mov    0x8056a80,%eax
		if ((threads_table[i].state == NOTUSED)
 804bef0:	8b 0d 7c 6a 05 08    	mov    0x8056a7c,%ecx
	for (int i = 0; i < threads_table_size; i++) {
 804bef6:	39 c2                	cmp    %eax,%edx
 804bef8:	7d 0c                	jge    804bf06 <posix_new_thread+0x2d>
		if ((threads_table[i].state == NOTUSED)
 804befa:	6b da 14             	imul   $0x14,%edx,%ebx
 804befd:	83 3c 19 00          	cmpl   $0x0,(%ecx,%ebx,1)
 804bf01:	74 50                	je     804bf53 <posix_new_thread+0x7a>
	for (int i = 0; i < threads_table_size; i++) {
 804bf03:	42                   	inc    %edx
 804bf04:	eb f0                	jmp    804bef6 <posix_new_thread+0x1d>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
 804bf06:	83 c0 40             	add    $0x40,%eax
	threads_table = realloc(threads_table,
 804bf09:	52                   	push   %edx
 804bf0a:	6b c0 14             	imul   $0x14,%eax,%eax
 804bf0d:	52                   	push   %edx
 804bf0e:	50                   	push   %eax
 804bf0f:	51                   	push   %ecx
 804bf10:	e8 db d4 ff ff       	call   80493f0 <realloc@plt>
 804bf15:	83 c4 10             	add    $0x10,%esp
 804bf18:	a3 7c 6a 05 08       	mov    %eax,0x8056a7c
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
 804bf1d:	85 c0                	test   %eax,%eax
 804bf1f:	75 10                	jne    804bf31 <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
 804bf21:	83 ec 0c             	sub    $0xc,%esp
 804bf24:	68 30 20 05 08       	push   $0x8052030
 804bf29:	e8 10 14 00 00       	call   804d33e <posix_print_error_and_exit>
 804bf2e:	83 c4 10             	add    $0x10,%esp
	(void)memset(&threads_table[threads_table_size], 0,
 804bf31:	8b 15 80 6a 05 08    	mov    0x8056a80,%edx
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
 804bf37:	31 c0                	xor    %eax,%eax
 804bf39:	b9 40 01 00 00       	mov    $0x140,%ecx
 804bf3e:	6b da 14             	imul   $0x14,%edx,%ebx
 804bf41:	03 1d 7c 6a 05 08    	add    0x8056a7c,%ebx
 804bf47:	89 df                	mov    %ebx,%edi
 804bf49:	f3 ab                	rep stos %eax,%es:(%edi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
 804bf4b:	8d 42 40             	lea    0x40(%edx),%eax
 804bf4e:	a3 80 6a 05 08       	mov    %eax,0x8056a80
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804bf53:	8b 0d 78 6a 05 08    	mov    0x8056a78,%ecx
	threads_table[t_slot].state = USED;
 804bf59:	6b c2 14             	imul   $0x14,%edx,%eax
 804bf5c:	03 05 7c 6a 05 08    	add    0x8056a7c,%eax
	threads_table[t_slot].t_status = ptr;
 804bf62:	89 70 10             	mov    %esi,0x10(%eax)
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804bf65:	83 c0 08             	add    $0x8,%eax
	threads_table[t_slot].state = USED;
 804bf68:	c7 40 f8 01 00 00 00 	movl   $0x1,-0x8(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804bf6f:	8d 59 01             	lea    0x1(%ecx),%ebx
	threads_table[t_slot].running = false;
 804bf72:	c6 40 fc 00          	movb   $0x0,-0x4(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804bf76:	89 48 04             	mov    %ecx,0x4(%eax)
	ptr->thread_idx = t_slot;
 804bf79:	89 56 10             	mov    %edx,0x10(%esi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804bf7c:	52                   	push   %edx
 804bf7d:	68 a4 bd 04 08       	push   $0x804bda4
 804bf82:	6a 00                	push   $0x0
 804bf84:	50                   	push   %eax
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804bf85:	89 1d 78 6a 05 08    	mov    %ebx,0x8056a78
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804bf8b:	e8 b0 d5 ff ff       	call   8049540 <pthread_create@plt>
 804bf90:	83 c4 10             	add    $0x10,%esp
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
 804bf93:	8d 65 f4             	lea    -0xc(%ebp),%esp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804bf96:	ba 58 20 05 08       	mov    $0x8052058,%edx
}
 804bf9b:	5b                   	pop    %ebx
 804bf9c:	5e                   	pop    %esi
 804bf9d:	5f                   	pop    %edi
 804bf9e:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804bf9f:	e9 fd fc ff ff       	jmp    804bca1 <pc_safe_call>

0804bfa4 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
 804bfa4:	f3 0f 1e fb          	endbr32 
 804bfa8:	55                   	push   %ebp
 804bfa9:	89 e5                	mov    %esp,%ebp
 804bfab:	83 ec 10             	sub    $0x10,%esp
	thread_create_count = 0;
 804bfae:	c7 05 78 6a 05 08 00 	movl   $0x0,0x8056a78
 804bfb5:	00 00 00 

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
 804bfb8:	6a 14                	push   $0x14
 804bfba:	6a 40                	push   $0x40
	currently_allowed_thread = -1;
 804bfbc:	c7 05 5c 6a 05 08 ff 	movl   $0xffffffff,0x8056a5c
 804bfc3:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
 804bfc6:	e8 e5 d5 ff ff       	call   80495b0 <calloc@plt>
 804bfcb:	83 c4 10             	add    $0x10,%esp
 804bfce:	a3 7c 6a 05 08       	mov    %eax,0x8056a7c
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
 804bfd3:	85 c0                	test   %eax,%eax
 804bfd5:	75 10                	jne    804bfe7 <posix_init_multithreading+0x43>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
 804bfd7:	83 ec 0c             	sub    $0xc,%esp
 804bfda:	68 30 20 05 08       	push   $0x8052030
 804bfdf:	e8 5a 13 00 00       	call   804d33e <posix_print_error_and_exit>
 804bfe4:	83 c4 10             	add    $0x10,%esp
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;
 804bfe7:	c7 05 80 6a 05 08 40 	movl   $0x40,0x8056a80
 804bfee:	00 00 00 


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804bff1:	83 ec 0c             	sub    $0xc,%esp
 804bff4:	68 60 6a 05 08       	push   $0x8056a60
 804bff9:	e8 d2 d3 ff ff       	call   80493d0 <pthread_mutex_lock@plt>
 804bffe:	83 c4 10             	add    $0x10,%esp
 804c001:	ba e9 1f 05 08       	mov    $0x8051fe9,%edx
}
 804c006:	c9                   	leave  
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804c007:	e9 95 fc ff ff       	jmp    804bca1 <pc_safe_call>

0804c00c <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
 804c00c:	f3 0f 1e fb          	endbr32 

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
 804c010:	83 3d 7c 6a 05 08 00 	cmpl   $0x0,0x8056a7c
 804c017:	74 65                	je     804c07e <posix_core_clean_up+0x72>
{
 804c019:	55                   	push   %ebp
 804c01a:	89 e5                	mov    %esp,%ebp
 804c01c:	53                   	push   %ebx
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;

	for (int i = 0; i < threads_table_size; i++) {
 804c01d:	31 db                	xor    %ebx,%ebx
{
 804c01f:	52                   	push   %edx
	terminate = true;
 804c020:	c6 05 eb 6a 05 08 01 	movb   $0x1,0x8056aeb
	for (int i = 0; i < threads_table_size; i++) {
 804c027:	a1 7c 6a 05 08       	mov    0x8056a7c,%eax
 804c02c:	39 1d 80 6a 05 08    	cmp    %ebx,0x8056a80
 804c032:	7e 2f                	jle    804c063 <posix_core_clean_up+0x57>
		if (threads_table[i].state != USED) {
 804c034:	6b d3 14             	imul   $0x14,%ebx,%edx
 804c037:	01 d0                	add    %edx,%eax
 804c039:	83 38 01             	cmpl   $0x1,(%eax)
 804c03c:	75 22                	jne    804c060 <posix_core_clean_up+0x54>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
 804c03e:	83 ec 0c             	sub    $0xc,%esp
 804c041:	ff 70 08             	pushl  0x8(%eax)
 804c044:	e8 47 d4 ff ff       	call   8049490 <pthread_cancel@plt>
 804c049:	83 c4 10             	add    $0x10,%esp
 804c04c:	85 c0                	test   %eax,%eax
 804c04e:	74 10                	je     804c060 <posix_core_clean_up+0x54>
			posix_print_warning(
 804c050:	50                   	push   %eax
 804c051:	50                   	push   %eax
 804c052:	53                   	push   %ebx
 804c053:	68 bc 20 05 08       	push   $0x80520bc
 804c058:	e8 10 13 00 00       	call   804d36d <posix_print_warning>
 804c05d:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < threads_table_size; i++) {
 804c060:	43                   	inc    %ebx
 804c061:	eb c4                	jmp    804c027 <posix_core_clean_up+0x1b>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
 804c063:	83 ec 0c             	sub    $0xc,%esp
 804c066:	50                   	push   %eax
 804c067:	e8 f4 d2 ff ff       	call   8049360 <free@plt>
	threads_table = NULL;
}
 804c06c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	free(threads_table);
 804c06f:	83 c4 10             	add    $0x10,%esp
	threads_table = NULL;
 804c072:	c7 05 7c 6a 05 08 00 	movl   $0x0,0x8056a7c
 804c079:	00 00 00 
}
 804c07c:	c9                   	leave  
 804c07d:	c3                   	ret    
 804c07e:	c3                   	ret    

0804c07f <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
 804c07f:	f3 0f 1e fb          	endbr32 
 804c083:	55                   	push   %ebp
 804c084:	89 e5                	mov    %esp,%ebp
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
 804c086:	6b 45 08 14          	imul   $0x14,0x8(%ebp),%eax
 804c08a:	03 05 7c 6a 05 08    	add    0x8056a7c,%eax
 804c090:	83 38 01             	cmpl   $0x1,(%eax)
 804c093:	75 06                	jne    804c09b <posix_abort_thread+0x1c>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
 804c095:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
 804c09b:	5d                   	pop    %ebp
 804c09c:	c3                   	ret    

0804c09d <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
 804c09d:	f3 0f 1e fb          	endbr32 
 804c0a1:	55                   	push   %ebp
 804c0a2:	89 e5                	mov    %esp,%ebp
 804c0a4:	57                   	push   %edi
 804c0a5:	56                   	push   %esi
 804c0a6:	53                   	push   %ebx
 804c0a7:	83 ec 1c             	sub    $0x1c,%esp
 804c0aa:	8b 75 08             	mov    0x8(%ebp),%esi
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
 804c0ad:	8b 5e 34             	mov    0x34(%esi),%ebx
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
 804c0b0:	8b 7b 10             	mov    0x10(%ebx),%edi
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
 804c0b3:	e8 d4 0d 00 00       	call   804ce8c <posix_irq_lock>
 804c0b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	key = irq_lock();

	if (_current == thread) {
 804c0bb:	39 35 68 69 05 08    	cmp    %esi,0x8056968
 804c0c1:	75 2e                	jne    804c0f1 <z_impl_k_thread_abort+0x54>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
 804c0c3:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
 804c0c7:	75 09                	jne    804c0d2 <z_impl_k_thread_abort+0x35>
			tstatus->aborted = 1;
 804c0c9:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
 804c0d0:	eb 10                	jmp    804c0e2 <z_impl_k_thread_abort+0x45>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
 804c0d2:	50                   	push   %eax
 804c0d3:	50                   	push   %eax
 804c0d4:	57                   	push   %edi
 804c0d5:	68 f0 20 05 08       	push   $0x80520f0
 804c0da:	e8 8e 12 00 00       	call   804d36d <posix_print_warning>
 804c0df:	83 c4 10             	add    $0x10,%esp
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
 804c0e2:	6b c7 14             	imul   $0x14,%edi,%eax
 804c0e5:	03 05 7c 6a 05 08    	add    0x8056a7c,%eax
 804c0eb:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
 804c0f1:	83 ec 0c             	sub    $0xc,%esp
 804c0f4:	56                   	push   %esi
 804c0f5:	e8 69 38 00 00       	call   804f963 <z_thread_abort>
 804c0fa:	83 c4 10             	add    $0x10,%esp

	if (tstatus->aborted == 0) {
 804c0fd:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
 804c101:	75 13                	jne    804c116 <z_impl_k_thread_abort+0x79>
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
		posix_abort_thread(thread_idx);
 804c103:	83 ec 0c             	sub    $0xc,%esp
		tstatus->aborted = 1;
 804c106:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		posix_abort_thread(thread_idx);
 804c10d:	57                   	push   %edi
 804c10e:	e8 6c ff ff ff       	call   804c07f <posix_abort_thread>
 804c113:	83 c4 10             	add    $0x10,%esp
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
 804c116:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c119:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804c11c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c11f:	5b                   	pop    %ebx
 804c120:	5e                   	pop    %esi
 804c121:	5f                   	pop    %edi
 804c122:	5d                   	pop    %ebp
	z_reschedule_irqlock(key);
 804c123:	e9 1d 2d 00 00       	jmp    804ee45 <z_reschedule_irqlock>

0804c128 <arch_swap>:
#include "irq.h"
#include "kswap.h"
#include <zephyr/pm/pm.h>

int arch_swap(unsigned int key)
{
 804c128:	f3 0f 1e fb          	endbr32 
 804c12c:	55                   	push   %ebp
 804c12d:	89 e5                	mov    %esp,%ebp
 804c12f:	83 ec 10             	sub    $0x10,%esp
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
 804c132:	a1 68 69 05 08       	mov    0x8056968,%eax
 804c137:	8b 55 08             	mov    0x8(%ebp),%edx
	_current->callee_saved.retval = -EAGAIN;
 804c13a:	c7 40 30 f5 ff ff ff 	movl   $0xfffffff5,0x30(%eax)
	_current->callee_saved.key = key;
 804c141:	89 50 2c             	mov    %edx,0x2c(%eax)
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
 804c144:	8b 15 78 69 05 08    	mov    0x8056978,%edx

	posix_thread_status_t *this_thread_ptr  =
 804c14a:	8b 40 34             	mov    0x34(%eax),%eax
	posix_thread_status_t *ready_thread_ptr =
 804c14d:	8b 4a 34             	mov    0x34(%edx),%ecx
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
 804c150:	89 15 68 69 05 08    	mov    %edx,0x8056968
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
 804c156:	ff 70 10             	pushl  0x10(%eax)
 804c159:	ff 71 10             	pushl  0x10(%ecx)
 804c15c:	e8 f5 fc ff ff       	call   804be56 <posix_swap>
 804c161:	58                   	pop    %eax
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
 804c162:	a1 68 69 05 08       	mov    0x8056968,%eax
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
 804c167:	ff 70 2c             	pushl  0x2c(%eax)
 804c16a:	e8 33 0d 00 00       	call   804cea2 <posix_irq_unlock>

	return _current->callee_saved.retval;
 804c16f:	a1 68 69 05 08       	mov    0x8056968,%eax
 804c174:	83 c4 10             	add    $0x10,%esp
 804c177:	8b 40 30             	mov    0x30(%eax),%eax
}
 804c17a:	c9                   	leave  
 804c17b:	c3                   	ret    

0804c17c <arch_switch_to_main_thread>:
 * Note that we will never come back to this thread: posix_main_thread_start()
 * does never return.
 */
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
 804c17c:	f3 0f 1e fb          	endbr32 
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
 804c180:	a1 78 69 05 08       	mov    0x8056978,%eax
{
 804c185:	55                   	push   %ebp
	posix_thread_status_t *ready_thread_ptr =
 804c186:	8b 50 34             	mov    0x34(%eax),%edx

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
 804c189:	a3 68 69 05 08       	mov    %eax,0x8056968
{
 804c18e:	89 e5                	mov    %esp,%ebp

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
 804c190:	8b 42 10             	mov    0x10(%edx),%eax
 804c193:	89 45 08             	mov    %eax,0x8(%ebp)
} /* LCOV_EXCL_LINE */
 804c196:	5d                   	pop    %ebp
	posix_main_thread_start(ready_thread_ptr->thread_idx);
 804c197:	e9 05 fd ff ff       	jmp    804bea1 <posix_main_thread_start>

0804c19c <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
 804c19c:	f3 0f 1e fb          	endbr32 
 804c1a0:	55                   	push   %ebp
 804c1a1:	89 e5                	mov    %esp,%ebp
 804c1a3:	8b 45 10             	mov    0x10(%ebp),%eax
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
 804c1a6:	8b 4d 14             	mov    0x14(%ebp),%ecx
 804c1a9:	89 48 e8             	mov    %ecx,-0x18(%eax)
	thread_status->arg1 = p1;
 804c1ac:	8b 4d 18             	mov    0x18(%ebp),%ecx
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
 804c1af:	8d 50 e8             	lea    -0x18(%eax),%edx
	thread_status->arg2 = p2;
	thread_status->arg3 = p3;
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
 804c1b2:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	thread_status->arg1 = p1;
 804c1b9:	89 48 ec             	mov    %ecx,-0x14(%eax)
	thread_status->arg2 = p2;
 804c1bc:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
 804c1bf:	89 48 f0             	mov    %ecx,-0x10(%eax)
	thread_status->arg3 = p3;
 804c1c2:	8b 4d 20             	mov    0x20(%ebp),%ecx
 804c1c5:	89 48 f4             	mov    %ecx,-0xc(%eax)
#endif

	thread->callee_saved.thread_status = thread_status;
 804c1c8:	8b 45 08             	mov    0x8(%ebp),%eax
 804c1cb:	89 50 34             	mov    %edx,0x34(%eax)

	posix_new_thread(thread_status);
 804c1ce:	89 55 08             	mov    %edx,0x8(%ebp)
}
 804c1d1:	5d                   	pop    %ebp
	posix_new_thread(thread_status);
 804c1d2:	e9 02 fd ff ff       	jmp    804bed9 <posix_new_thread>

0804c1d7 <posix_new_thread_pre_start>:

void posix_new_thread_pre_start(void)
{
 804c1d7:	f3 0f 1e fb          	endbr32 
	posix_irq_full_unlock();
 804c1db:	e9 cb 0c 00 00       	jmp    804ceab <posix_irq_full_unlock>

0804c1e0 <pc_safe_call>:
	if (unlikely(test)) {
 804c1e0:	85 c0                	test   %eax,%eax
 804c1e2:	74 16                	je     804c1fa <pc_safe_call+0x1a>
{
 804c1e4:	55                   	push   %ebp
 804c1e5:	89 e5                	mov    %esp,%ebp
 804c1e7:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804c1ea:	52                   	push   %edx
 804c1eb:	68 ac 1f 05 08       	push   $0x8051fac
 804c1f0:	e8 49 11 00 00       	call   804d33e <posix_print_error_and_exit>
 804c1f5:	83 c4 10             	add    $0x10,%esp
}
 804c1f8:	c9                   	leave  
 804c1f9:	c3                   	ret    
 804c1fa:	c3                   	ret    

0804c1fb <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
 804c1fb:	f3 0f 1e fb          	endbr32 
 804c1ff:	55                   	push   %ebp
 804c200:	89 e5                	mov    %esp,%ebp
 804c202:	83 ec 14             	sub    $0x14,%esp
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804c205:	68 84 6a 05 08       	push   $0x8056a84
 804c20a:	e8 c1 d1 ff ff       	call   80493d0 <pthread_mutex_lock@plt>
 804c20f:	ba 6c 21 05 08       	mov    $0x805216c,%edx
 804c214:	83 c4 10             	add    $0x10,%esp
 804c217:	e8 c4 ff ff ff       	call   804c1e0 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804c21c:	83 ec 0c             	sub    $0xc,%esp
 804c21f:	68 84 6a 05 08       	push   $0x8056a84
 804c224:	e8 d7 d0 ff ff       	call   8049300 <pthread_mutex_unlock@plt>
 804c229:	83 c4 10             	add    $0x10,%esp
 804c22c:	ba 89 21 05 08       	mov    $0x8052189,%edx
 804c231:	e8 aa ff ff ff       	call   804c1e0 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
 804c236:	e8 69 fd ff ff       	call   804bfa4 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
 804c23b:	e8 4e 24 00 00       	call   804e68e <z_cstart>

0804c240 <posix_is_cpu_running>:
{
 804c240:	f3 0f 1e fb          	endbr32 
	return !cpu_halted;
 804c244:	a0 98 52 05 08       	mov    0x8055298,%al
 804c249:	83 f0 01             	xor    $0x1,%eax
 804c24c:	0f b6 c0             	movzbl %al,%eax
}
 804c24f:	c3                   	ret    

0804c250 <posix_change_cpu_state_and_wait>:
{
 804c250:	f3 0f 1e fb          	endbr32 
 804c254:	55                   	push   %ebp
 804c255:	89 e5                	mov    %esp,%ebp
 804c257:	56                   	push   %esi
 804c258:	53                   	push   %ebx
 804c259:	8b 75 08             	mov    0x8(%ebp),%esi
 804c25c:	89 f3                	mov    %esi,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804c25e:	83 ec 0c             	sub    $0xc,%esp
 804c261:	68 84 6a 05 08       	push   $0x8056a84
 804c266:	e8 65 d1 ff ff       	call   80493d0 <pthread_mutex_lock@plt>
 804c26b:	ba 6c 21 05 08       	mov    $0x805216c,%edx
 804c270:	83 c4 10             	add    $0x10,%esp
 804c273:	e8 68 ff ff ff       	call   804c1e0 <pc_safe_call>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804c278:	83 ec 0c             	sub    $0xc,%esp
	cpu_halted = halted;
 804c27b:	88 1d 98 52 05 08    	mov    %bl,0x8055298
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804c281:	68 60 65 05 08       	push   $0x8056560
 804c286:	e8 c5 d0 ff ff       	call   8049350 <pthread_cond_broadcast@plt>
 804c28b:	83 c4 10             	add    $0x10,%esp
 804c28e:	ba a8 21 05 08       	mov    $0x80521a8,%edx
 804c293:	e8 48 ff ff ff       	call   804c1e0 <pc_safe_call>
	while (cpu_halted == halted) {
 804c298:	38 1d 98 52 05 08    	cmp    %bl,0x8055298
 804c29e:	75 16                	jne    804c2b6 <posix_change_cpu_state_and_wait+0x66>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
 804c2a0:	50                   	push   %eax
 804c2a1:	50                   	push   %eax
 804c2a2:	68 84 6a 05 08       	push   $0x8056a84
 804c2a7:	68 60 65 05 08       	push   $0x8056560
 804c2ac:	e8 ef d0 ff ff       	call   80493a0 <pthread_cond_wait@plt>
 804c2b1:	83 c4 10             	add    $0x10,%esp
 804c2b4:	eb e2                	jmp    804c298 <posix_change_cpu_state_and_wait+0x48>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804c2b6:	83 ec 0c             	sub    $0xc,%esp
 804c2b9:	68 84 6a 05 08       	push   $0x8056a84
 804c2be:	e8 3d d0 ff ff       	call   8049300 <pthread_mutex_unlock@plt>
 804c2c3:	83 c4 10             	add    $0x10,%esp
}
 804c2c6:	8d 65 f8             	lea    -0x8(%ebp),%esp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804c2c9:	ba 89 21 05 08       	mov    $0x8052189,%edx
}
 804c2ce:	5b                   	pop    %ebx
 804c2cf:	5e                   	pop    %esi
 804c2d0:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804c2d1:	e9 0a ff ff ff       	jmp    804c1e0 <pc_safe_call>

0804c2d6 <posix_interrupt_raised>:
{
 804c2d6:	f3 0f 1e fb          	endbr32 
 804c2da:	55                   	push   %ebp
 804c2db:	89 e5                	mov    %esp,%ebp
 804c2dd:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(false);
 804c2e0:	6a 00                	push   $0x0
 804c2e2:	e8 69 ff ff ff       	call   804c250 <posix_change_cpu_state_and_wait>
 804c2e7:	83 c4 10             	add    $0x10,%esp
	if (soc_terminate) {
 804c2ea:	80 3d ec 6a 05 08 00 	cmpb   $0x0,0x8056aec
 804c2f1:	74 0d                	je     804c300 <posix_interrupt_raised+0x2a>
		posix_exit(0);
 804c2f3:	83 ec 0c             	sub    $0xc,%esp
 804c2f6:	6a 00                	push   $0x0
 804c2f8:	e8 04 0f 00 00       	call   804d201 <posix_exit>
 804c2fd:	83 c4 10             	add    $0x10,%esp
}
 804c300:	c9                   	leave  
 804c301:	c3                   	ret    

0804c302 <posix_halt_cpu>:
{
 804c302:	f3 0f 1e fb          	endbr32 
 804c306:	55                   	push   %ebp
 804c307:	89 e5                	mov    %esp,%ebp
 804c309:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(true);
 804c30c:	6a 01                	push   $0x1
 804c30e:	e8 3d ff ff ff       	call   804c250 <posix_change_cpu_state_and_wait>
 804c313:	83 c4 10             	add    $0x10,%esp
}
 804c316:	c9                   	leave  
	posix_irq_handler();
 804c317:	e9 1e 0a 00 00       	jmp    804cd3a <posix_irq_handler>

0804c31c <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
 804c31c:	f3 0f 1e fb          	endbr32 
 804c320:	55                   	push   %ebp
 804c321:	89 e5                	mov    %esp,%ebp
 804c323:	83 ec 24             	sub    $0x24,%esp
 804c326:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804c32c:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c32f:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804c331:	68 84 6a 05 08       	push   $0x8056a84
 804c336:	e8 95 d0 ff ff       	call   80493d0 <pthread_mutex_lock@plt>
 804c33b:	83 c4 10             	add    $0x10,%esp
 804c33e:	ba 6c 21 05 08       	mov    $0x805216c,%edx
 804c343:	e8 98 fe ff ff       	call   804c1e0 <pc_safe_call>
	cpu_halted = false;

	pthread_t zephyr_thread;

	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
 804c348:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804c34b:	6a 00                	push   $0x0
 804c34d:	68 fb c1 04 08       	push   $0x804c1fb
 804c352:	6a 00                	push   $0x0
 804c354:	50                   	push   %eax
	cpu_halted = false;
 804c355:	c6 05 98 52 05 08 00 	movb   $0x0,0x8055298
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
 804c35c:	e8 df d1 ff ff       	call   8049540 <pthread_create@plt>
 804c361:	83 c4 10             	add    $0x10,%esp
 804c364:	ba ca 21 05 08       	mov    $0x80521ca,%edx
 804c369:	e8 72 fe ff ff       	call   804c1e0 <pc_safe_call>

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
 804c36e:	80 3d 98 52 05 08 00 	cmpb   $0x0,0x8055298
 804c375:	75 16                	jne    804c38d <posix_boot_cpu+0x71>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
 804c377:	50                   	push   %eax
 804c378:	50                   	push   %eax
 804c379:	68 84 6a 05 08       	push   $0x8056a84
 804c37e:	68 60 65 05 08       	push   $0x8056560
 804c383:	e8 18 d0 ff ff       	call   80493a0 <pthread_cond_wait@plt>
 804c388:	83 c4 10             	add    $0x10,%esp
 804c38b:	eb e1                	jmp    804c36e <posix_boot_cpu+0x52>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804c38d:	83 ec 0c             	sub    $0xc,%esp
 804c390:	68 84 6a 05 08       	push   $0x8056a84
 804c395:	e8 66 cf ff ff       	call   8049300 <pthread_mutex_unlock@plt>
 804c39a:	83 c4 10             	add    $0x10,%esp
 804c39d:	ba 89 21 05 08       	mov    $0x8052189,%edx
 804c3a2:	e8 39 fe ff ff       	call   804c1e0 <pc_safe_call>

	if (soc_terminate) {
 804c3a7:	80 3d ec 6a 05 08 00 	cmpb   $0x0,0x8056aec
 804c3ae:	74 0d                	je     804c3bd <posix_boot_cpu+0xa1>
		posix_exit(0);
 804c3b0:	83 ec 0c             	sub    $0xc,%esp
 804c3b3:	6a 00                	push   $0x0
 804c3b5:	e8 47 0e 00 00       	call   804d201 <posix_exit>
 804c3ba:	83 c4 10             	add    $0x10,%esp
	}
}
 804c3bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c3c0:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804c3c7:	74 05                	je     804c3ce <posix_boot_cpu+0xb2>
 804c3c9:	e8 f2 cf ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804c3ce:	c9                   	leave  
 804c3cf:	c3                   	ret    

0804c3d0 <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
 804c3d0:	f3 0f 1e fb          	endbr32 
 804c3d4:	55                   	push   %ebp
 804c3d5:	89 e5                	mov    %esp,%ebp
 804c3d7:	56                   	push   %esi
 804c3d8:	8b 75 08             	mov    0x8(%ebp),%esi
 804c3db:	53                   	push   %ebx
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
 804c3dc:	8b 1c b5 a8 12 05 08 	mov    0x80512a8(,%esi,4),%ebx
 804c3e3:	39 1c b5 ac 12 05 08 	cmp    %ebx,0x80512ac(,%esi,4)
 804c3ea:	76 0d                	jbe    804c3f9 <run_native_tasks+0x29>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
 804c3ec:	8b 03                	mov    (%ebx),%eax
 804c3ee:	85 c0                	test   %eax,%eax
 804c3f0:	74 02                	je     804c3f4 <run_native_tasks+0x24>
			(*fptr)();
 804c3f2:	ff d0                	call   *%eax
		fptr++) {
 804c3f4:	83 c3 04             	add    $0x4,%ebx
 804c3f7:	eb ea                	jmp    804c3e3 <run_native_tasks+0x13>
		}
	}
}
 804c3f9:	5b                   	pop    %ebx
 804c3fa:	5e                   	pop    %esi
 804c3fb:	5d                   	pop    %ebp
 804c3fc:	c3                   	ret    

0804c3fd <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
 804c3fd:	f3 0f 1e fb          	endbr32 
 804c401:	55                   	push   %ebp
 804c402:	89 e5                	mov    %esp,%ebp
 804c404:	83 ec 08             	sub    $0x8,%esp
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
 804c407:	80 3d 98 52 05 08 00 	cmpb   $0x0,0x8055298
 804c40e:	74 14                	je     804c424 <posix_soc_clean_up+0x27>

		posix_core_clean_up();
 804c410:	e8 f7 fb ff ff       	call   804c00c <posix_core_clean_up>
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
 804c415:	83 ec 0c             	sub    $0xc,%esp
 804c418:	6a 04                	push   $0x4
 804c41a:	e8 b1 ff ff ff       	call   804c3d0 <run_native_tasks>
 804c41f:	83 c4 10             	add    $0x10,%esp
 804c422:	eb 74                	jmp    804c498 <posix_soc_clean_up+0x9b>

	} else if (soc_terminate == false) {
 804c424:	80 3d ec 6a 05 08 00 	cmpb   $0x0,0x8056aec
 804c42b:	75 6b                	jne    804c498 <posix_soc_clean_up+0x9b>

		soc_terminate = true;

		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804c42d:	83 ec 0c             	sub    $0xc,%esp
		soc_terminate = true;
 804c430:	c6 05 ec 6a 05 08 01 	movb   $0x1,0x8056aec
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804c437:	68 84 6a 05 08       	push   $0x8056a84
 804c43c:	e8 8f cf ff ff       	call   80493d0 <pthread_mutex_lock@plt>
 804c441:	ba 6c 21 05 08       	mov    $0x805216c,%edx
 804c446:	83 c4 10             	add    $0x10,%esp
 804c449:	e8 92 fd ff ff       	call   804c1e0 <pc_safe_call>

		cpu_halted = true;

		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804c44e:	83 ec 0c             	sub    $0xc,%esp
		cpu_halted = true;
 804c451:	c6 05 98 52 05 08 01 	movb   $0x1,0x8055298
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804c458:	68 60 65 05 08       	push   $0x8056560
 804c45d:	e8 ee ce ff ff       	call   8049350 <pthread_cond_broadcast@plt>
 804c462:	ba a8 21 05 08       	mov    $0x80521a8,%edx
 804c467:	83 c4 10             	add    $0x10,%esp
 804c46a:	e8 71 fd ff ff       	call   804c1e0 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804c46f:	83 ec 0c             	sub    $0xc,%esp
 804c472:	68 84 6a 05 08       	push   $0x8056a84
 804c477:	e8 84 ce ff ff       	call   8049300 <pthread_mutex_unlock@plt>
 804c47c:	83 c4 10             	add    $0x10,%esp
 804c47f:	ba 89 21 05 08       	mov    $0x8052189,%edx
 804c484:	e8 57 fd ff ff       	call   804c1e0 <pc_safe_call>

		while (1) {
			sleep(1);
 804c489:	83 ec 0c             	sub    $0xc,%esp
 804c48c:	6a 01                	push   $0x1
 804c48e:	e8 1d cf ff ff       	call   80493b0 <sleep@plt>
 804c493:	83 c4 10             	add    $0x10,%esp
		while (1) {
 804c496:	eb f1                	jmp    804c489 <posix_soc_clean_up+0x8c>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
 804c498:	c9                   	leave  
 804c499:	c3                   	ret    

0804c49a <hwm_signal_end_handler>:

/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
 804c49a:	f3 0f 1e fb          	endbr32 
	signaled_end = 1;
 804c49e:	c7 05 9c 6a 05 08 01 	movl   $0x1,0x8056a9c
 804c4a5:	00 00 00 
}
 804c4a8:	c3                   	ret    

0804c4a9 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
 804c4a9:	f3 0f 1e fb          	endbr32 
 804c4ad:	55                   	push   %ebp
 804c4ae:	89 e5                	mov    %esp,%ebp
 804c4b0:	53                   	push   %ebx
 804c4b1:	81 ec a0 00 00 00    	sub    $0xa0,%esp
 804c4b7:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804c4bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c4c0:	31 c0                	xor    %eax,%eax
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
 804c4c2:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
	act.sa_handler = hwm_signal_end_handler;
 804c4c8:	c7 85 68 ff ff ff 9a 	movl   $0x804c49a,-0x98(%ebp)
 804c4cf:	c4 04 08 
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
 804c4d2:	50                   	push   %eax
 804c4d3:	e8 28 d0 ff ff       	call   8049500 <sigemptyset@plt>
 804c4d8:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804c4db:	85 c0                	test   %eax,%eax
 804c4dd:	74 14                	je     804c4f3 <hwm_set_sig_handler+0x4a>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804c4df:	50                   	push   %eax
 804c4e0:	50                   	push   %eax
 804c4e1:	68 05 22 05 08       	push   $0x8052205
 804c4e6:	68 ac 1f 05 08       	push   $0x8051fac
 804c4eb:	e8 4e 0e 00 00       	call   804d33e <posix_print_error_and_exit>
 804c4f0:	83 c4 10             	add    $0x10,%esp

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
 804c4f3:	53                   	push   %ebx
 804c4f4:	8d 9d 68 ff ff ff    	lea    -0x98(%ebp),%ebx
 804c4fa:	6a 00                	push   $0x0
 804c4fc:	53                   	push   %ebx
 804c4fd:	6a 0f                	push   $0xf
	act.sa_flags = SA_RESETHAND;
 804c4ff:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
 804c506:	e8 45 d0 ff ff       	call   8049550 <sigaction@plt>
 804c50b:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804c50e:	85 c0                	test   %eax,%eax
 804c510:	74 14                	je     804c526 <hwm_set_sig_handler+0x7d>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804c512:	51                   	push   %ecx
 804c513:	51                   	push   %ecx
 804c514:	68 1f 22 05 08       	push   $0x805221f
 804c519:	68 ac 1f 05 08       	push   $0x8051fac
 804c51e:	e8 1b 0e 00 00       	call   804d33e <posix_print_error_and_exit>
 804c523:	83 c4 10             	add    $0x10,%esp
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
 804c526:	52                   	push   %edx
 804c527:	6a 00                	push   $0x0
 804c529:	53                   	push   %ebx
 804c52a:	6a 02                	push   $0x2
 804c52c:	e8 1f d0 ff ff       	call   8049550 <sigaction@plt>
 804c531:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804c534:	85 c0                	test   %eax,%eax
 804c536:	74 14                	je     804c54c <hwm_set_sig_handler+0xa3>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804c538:	50                   	push   %eax
 804c539:	50                   	push   %eax
 804c53a:	68 3e 22 05 08       	push   $0x805223e
 804c53f:	68 ac 1f 05 08       	push   $0x8051fac
 804c544:	e8 f5 0d 00 00       	call   804d33e <posix_print_error_and_exit>
 804c549:	83 c4 10             	add    $0x10,%esp
}
 804c54c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c54f:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804c556:	74 05                	je     804c55d <hwm_set_sig_handler+0xb4>
 804c558:	e8 63 ce ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804c55d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804c560:	c9                   	leave  
 804c561:	c3                   	ret    

0804c562 <hwm_find_next_timer>:
/**
 * Find in between all timers which is the next one
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
 804c562:	f3 0f 1e fb          	endbr32 
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
 804c566:	8b 15 68 52 05 08    	mov    0x8055268,%edx
 804c56c:	a1 6c 52 05 08       	mov    0x805526c,%eax
{
 804c571:	55                   	push   %ebp
	next_timer_time  = *Timer_list[0];
 804c572:	8b 0d d4 69 05 08    	mov    0x80569d4,%ecx
	next_timer_index = 0;
 804c578:	c7 05 78 52 05 08 00 	movl   $0x0,0x8055278
 804c57f:	00 00 00 
{
 804c582:	89 e5                	mov    %esp,%ebp
 804c584:	53                   	push   %ebx
	next_timer_time  = *Timer_list[0];
 804c585:	8b 1d d0 69 05 08    	mov    0x80569d0,%ebx
 804c58b:	89 0d 8c 69 05 08    	mov    %ecx,0x805698c
		if (next_timer_time > *Timer_list[i]) {
 804c591:	39 da                	cmp    %ebx,%edx
	next_timer_time  = *Timer_list[0];
 804c593:	89 1d 88 69 05 08    	mov    %ebx,0x8056988
		if (next_timer_time > *Timer_list[i]) {
 804c599:	89 c3                	mov    %eax,%ebx
 804c59b:	19 cb                	sbb    %ecx,%ebx
 804c59d:	73 15                	jae    804c5b4 <hwm_find_next_timer+0x52>
			next_timer_index = i;
 804c59f:	c7 05 78 52 05 08 01 	movl   $0x1,0x8055278
 804c5a6:	00 00 00 
			next_timer_time = *Timer_list[i];
 804c5a9:	89 15 88 69 05 08    	mov    %edx,0x8056988
 804c5af:	a3 8c 69 05 08       	mov    %eax,0x805698c
		if (next_timer_time > *Timer_list[i]) {
 804c5b4:	a1 0c 6a 05 08       	mov    0x8056a0c,%eax
 804c5b9:	8b 15 08 6a 05 08    	mov    0x8056a08,%edx
 804c5bf:	3b 15 88 69 05 08    	cmp    0x8056988,%edx
 804c5c5:	89 c1                	mov    %eax,%ecx
 804c5c7:	1b 0d 8c 69 05 08    	sbb    0x805698c,%ecx
 804c5cd:	73 15                	jae    804c5e4 <hwm_find_next_timer+0x82>
			next_timer_index = i;
 804c5cf:	c7 05 78 52 05 08 02 	movl   $0x2,0x8055278
 804c5d6:	00 00 00 
			next_timer_time = *Timer_list[i];
 804c5d9:	89 15 88 69 05 08    	mov    %edx,0x8056988
 804c5df:	a3 8c 69 05 08       	mov    %eax,0x805698c
		}
	}
}
 804c5e4:	5b                   	pop    %ebx
 804c5e5:	5d                   	pop    %ebp
 804c5e6:	c3                   	ret    

0804c5e7 <hwm_main_loop>:
/**
 * Entry point for the HW models
 * The HW models execute in an infinite loop until terminated
 */
void hwm_main_loop(void)
{
 804c5e7:	f3 0f 1e fb          	endbr32 
 804c5eb:	55                   	push   %ebp
 804c5ec:	89 e5                	mov    %esp,%ebp
 804c5ee:	56                   	push   %esi
 804c5ef:	53                   	push   %ebx
 804c5f0:	83 ec 10             	sub    $0x10,%esp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
 804c5f3:	a1 88 69 05 08       	mov    0x8056988,%eax
 804c5f8:	8b 15 8c 69 05 08    	mov    0x805698c,%edx
 804c5fe:	8b 0d 90 69 05 08    	mov    0x8056990,%ecx
 804c604:	8b 1d 94 69 05 08    	mov    0x8056994,%ebx
 804c60a:	89 d6                	mov    %edx,%esi
 804c60c:	39 c8                	cmp    %ecx,%eax
 804c60e:	19 de                	sbb    %ebx,%esi
 804c610:	72 0d                	jb     804c61f <hwm_main_loop+0x38>
		simu_time = next_timer_time;
 804c612:	a3 90 69 05 08       	mov    %eax,0x8056990
 804c617:	89 15 94 69 05 08    	mov    %edx,0x8056994
 804c61d:	eb 19                	jmp    804c638 <hwm_main_loop+0x51>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
 804c61f:	56                   	push   %esi
 804c620:	56                   	push   %esi
 804c621:	ff 35 78 52 05 08    	pushl  0x8055278
 804c627:	53                   	push   %ebx
 804c628:	51                   	push   %ecx
 804c629:	52                   	push   %edx
 804c62a:	50                   	push   %eax
 804c62b:	68 5c 22 05 08       	push   $0x805225c
 804c630:	e8 38 0d 00 00       	call   804d36d <posix_print_warning>
 804c635:	83 c4 20             	add    $0x20,%esp
	if (signaled_end || (simu_time > end_of_time)) {
 804c638:	8b 0d 9c 6a 05 08    	mov    0x8056a9c,%ecx
 804c63e:	a1 90 69 05 08       	mov    0x8056990,%eax
 804c643:	8b 15 94 69 05 08    	mov    0x8056994,%edx
 804c649:	85 c9                	test   %ecx,%ecx
 804c64b:	75 10                	jne    804c65d <hwm_main_loop+0x76>
 804c64d:	8b 0d 5c 52 05 08    	mov    0x805525c,%ecx
 804c653:	39 05 58 52 05 08    	cmp    %eax,0x8055258
 804c659:	19 d1                	sbb    %edx,%ecx
 804c65b:	73 38                	jae    804c695 <hwm_main_loop+0xae>
				((long double)simu_time)/1.0e6L);
 804c65d:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c660:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804c663:	df 6d f0             	fildll -0x10(%ebp)
 804c666:	85 d2                	test   %edx,%edx
 804c668:	79 06                	jns    804c670 <hwm_main_loop+0x89>
 804c66a:	d8 05 c0 12 05 08    	fadds  0x80512c0
		posix_print_trace("\nStopped at %.3Lfs\n",
 804c670:	d8 35 c4 12 05 08    	fdivs  0x80512c4
 804c676:	83 ec 0c             	sub    $0xc,%esp
 804c679:	db 3c 24             	fstpt  (%esp)
 804c67c:	68 93 22 05 08       	push   $0x8052293
 804c681:	e8 0a 0d 00 00       	call   804d390 <posix_print_trace>
		posix_exit(0);
 804c686:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804c68d:	e8 6f 0b 00 00       	call   804d201 <posix_exit>
 804c692:	83 c4 10             	add    $0x10,%esp
	while (1) {
		hwm_sleep_until_next_timer();

		switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
 804c695:	a1 78 52 05 08       	mov    0x8055278,%eax
 804c69a:	83 f8 01             	cmp    $0x1,%eax
 804c69d:	74 10                	je     804c6af <hwm_main_loop+0xc8>
 804c69f:	83 f8 02             	cmp    $0x2,%eax
 804c6a2:	74 12                	je     804c6b6 <hwm_main_loop+0xcf>
 804c6a4:	85 c0                	test   %eax,%eax
 804c6a6:	75 15                	jne    804c6bd <hwm_main_loop+0xd6>
		case HWTIMER:
			hwtimer_timer_reached();
 804c6a8:	e8 92 04 00 00       	call   804cb3f <hwtimer_timer_reached>
			break;
 804c6ad:	eb 1e                	jmp    804c6cd <hwm_main_loop+0xe6>
		case IRQCNT:
			hw_irq_ctrl_timer_triggered();
 804c6af:	e8 30 0b 00 00       	call   804d1e4 <hw_irq_ctrl_timer_triggered>
			break;
 804c6b4:	eb 17                	jmp    804c6cd <hwm_main_loop+0xe6>
		case HW_COUNTER:
			hw_counter_triggered();
 804c6b6:	e8 dc 15 00 00       	call   804dc97 <hw_counter_triggered>
			break;
 804c6bb:	eb 10                	jmp    804c6cd <hwm_main_loop+0xe6>
			sdl_handle_events();
			break;
#endif
		default:
			/* LCOV_EXCL_START */
			posix_print_error_and_exit(
 804c6bd:	83 ec 0c             	sub    $0xc,%esp
 804c6c0:	68 a7 22 05 08       	push   $0x80522a7
 804c6c5:	e8 74 0c 00 00       	call   804d33e <posix_print_error_and_exit>
 804c6ca:	83 c4 10             	add    $0x10,%esp
					"next_timer_index corrupted\n");
			break;
			/* LCOV_EXCL_STOP */
		}

		hwm_find_next_timer();
 804c6cd:	e8 90 fe ff ff       	call   804c562 <hwm_find_next_timer>
		hwm_sleep_until_next_timer();
 804c6d2:	e9 1c ff ff ff       	jmp    804c5f3 <hwm_main_loop+0xc>

0804c6d7 <hwm_set_end_of_time>:

/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
 804c6d7:	f3 0f 1e fb          	endbr32 
 804c6db:	55                   	push   %ebp
 804c6dc:	89 e5                	mov    %esp,%ebp
	end_of_time = new_end_of_time;
 804c6de:	8b 45 08             	mov    0x8(%ebp),%eax
 804c6e1:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804c6e4:	5d                   	pop    %ebp
	end_of_time = new_end_of_time;
 804c6e5:	a3 58 52 05 08       	mov    %eax,0x8055258
 804c6ea:	89 15 5c 52 05 08    	mov    %edx,0x805525c
}
 804c6f0:	c3                   	ret    

0804c6f1 <hwm_get_time>:

/**
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
 804c6f1:	f3 0f 1e fb          	endbr32 
	return simu_time;
}
 804c6f5:	a1 90 69 05 08       	mov    0x8056990,%eax
 804c6fa:	8b 15 94 69 05 08    	mov    0x8056994,%edx
 804c700:	c3                   	ret    

0804c701 <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
 804c701:	f3 0f 1e fb          	endbr32 
 804c705:	55                   	push   %ebp
 804c706:	89 e5                	mov    %esp,%ebp
 804c708:	83 ec 08             	sub    $0x8,%esp
	hwm_set_sig_handler();
 804c70b:	e8 99 fd ff ff       	call   804c4a9 <hwm_set_sig_handler>
	hwtimer_init();
 804c710:	e8 a4 02 00 00       	call   804c9b9 <hwtimer_init>
	hw_counter_init();
 804c715:	e8 21 15 00 00       	call   804dc3b <hw_counter_init>
	hw_irq_ctrl_init();
 804c71a:	e8 6b 08 00 00       	call   804cf8a <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
 804c71f:	c9                   	leave  
	hwm_find_next_timer();
 804c720:	e9 3d fe ff ff       	jmp    804c562 <hwm_find_next_timer>

0804c725 <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
 804c725:	f3 0f 1e fb          	endbr32 
 804c729:	55                   	push   %ebp
 804c72a:	89 e5                	mov    %esp,%ebp
 804c72c:	83 ec 08             	sub    $0x8,%esp
	hwtimer_cleanup();
 804c72f:	e8 c4 03 00 00       	call   804caf8 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
 804c734:	c9                   	leave  
	hw_irq_ctrl_cleanup();
 804c735:	e9 9a 08 00 00       	jmp    804cfd4 <hw_irq_ctrl_cleanup>

0804c73a <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804c73a:	8b 0d cc 69 05 08    	mov    0x80569cc,%ecx
 804c740:	a1 c4 69 05 08       	mov    0x80569c4,%eax
{
 804c745:	55                   	push   %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804c746:	8b 15 c0 69 05 08    	mov    0x80569c0,%edx
 804c74c:	39 15 c8 69 05 08    	cmp    %edx,0x80569c8
{
 804c752:	89 e5                	mov    %esp,%ebp
 804c754:	53                   	push   %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804c755:	89 cb                	mov    %ecx,%ebx
 804c757:	19 c3                	sbb    %eax,%ebx
 804c759:	0f 42 15 c8 69 05 08 	cmovb  0x80569c8,%edx
}
 804c760:	5b                   	pop    %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804c761:	0f 42 c1             	cmovb  %ecx,%eax
}
 804c764:	5d                   	pop    %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804c765:	89 15 d0 69 05 08    	mov    %edx,0x80569d0
 804c76b:	a3 d4 69 05 08       	mov    %eax,0x80569d4
}
 804c770:	c3                   	ret    

0804c771 <cmd_realtime_found>:
	}
	hwm_set_end_of_time(args.stop_at*1e6);
}

static void cmd_realtime_found(char *argv, int offset)
{
 804c771:	f3 0f 1e fb          	endbr32 
	real_time_mode = new_rt;
 804c775:	c6 05 ee 6a 05 08 01 	movb   $0x1,0x8056aee
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(true);
}
 804c77c:	c3                   	ret    

0804c77d <cmd_no_realtime_found>:

static void cmd_no_realtime_found(char *argv, int offset)
{
 804c77d:	f3 0f 1e fb          	endbr32 
	real_time_mode = new_rt;
 804c781:	c6 05 ee 6a 05 08 00 	movb   $0x0,0x8056aee
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(false);
}
 804c788:	c3                   	ret    

0804c789 <cmd_rtcoffset_found>:

static void cmd_rtcoffset_found(char *argv, int offset)
{
 804c789:	f3 0f 1e fb          	endbr32 
 804c78d:	55                   	push   %ebp
 804c78e:	89 e5                	mov    %esp,%ebp
 804c790:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
 804c793:	d9 05 c4 12 05 08    	flds   0x80512c4
 804c799:	d9 7d fe             	fnstcw -0x2(%ebp)
 804c79c:	dc 0d a8 65 05 08    	fmull  0x80565a8
 804c7a2:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
 804c7a6:	80 cc 0c             	or     $0xc,%ah
 804c7a9:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
 804c7ad:	d9 6d fc             	fldcw  -0x4(%ebp)
 804c7b0:	df 3d a8 69 05 08    	fistpll 0x80569a8
 804c7b6:	d9 6d fe             	fldcw  -0x2(%ebp)
}
 804c7b9:	c9                   	leave  
 804c7ba:	c3                   	ret    

0804c7bb <cmd_rtcreset_found>:
	}
	hwtimer_set_rt_ratio(args.rt_ratio);
}

static void cmd_rtcreset_found(char *argv, int offset)
{
 804c7bb:	f3 0f 1e fb          	endbr32 
	reset_rtc = true;
 804c7bf:	c6 05 ed 6a 05 08 01 	movb   $0x1,0x8056aed
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_reset_rtc();
}
 804c7c6:	c3                   	ret    

0804c7c7 <native_add_time_options>:

static void native_add_time_options(void)
{
 804c7c7:	f3 0f 1e fb          	endbr32 
 804c7cb:	55                   	push   %ebp
 804c7cc:	89 e5                	mov    %esp,%ebp
 804c7ce:	83 ec 14             	sub    $0x14,%esp
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
 804c7d1:	68 c0 50 05 08       	push   $0x80550c0
 804c7d6:	e8 f2 12 00 00       	call   804dacd <native_add_command_line_opts>
 804c7db:	83 c4 10             	add    $0x10,%esp
}
 804c7de:	c9                   	leave  
 804c7df:	c3                   	ret    

0804c7e0 <cmd_rt_ratio_found>:
{
 804c7e0:	f3 0f 1e fb          	endbr32 
	if ((args.rt_ratio <= 0)) {
 804c7e4:	dd 05 b8 65 05 08    	fldl   0x80565b8
 804c7ea:	d9 ee                	fldz   
 804c7ec:	df f1                	fcomip %st(1),%st
 804c7ee:	dd d8                	fstp   %st(0)
 804c7f0:	72 21                	jb     804c813 <cmd_rt_ratio_found+0x33>
{
 804c7f2:	55                   	push   %ebp
 804c7f3:	89 e5                	mov    %esp,%ebp
 804c7f5:	83 ec 14             	sub    $0x14,%esp
		posix_print_error_and_exit("The ratio needs to be > 0. "
 804c7f8:	68 c3 22 05 08       	push   $0x80522c3
 804c7fd:	e8 3c 0b 00 00       	call   804d33e <posix_print_error_and_exit>
	clock_ratio = ratio;
 804c802:	dd 05 b8 65 05 08    	fldl   0x80565b8
		posix_print_error_and_exit("The ratio needs to be > 0. "
 804c808:	83 c4 10             	add    $0x10,%esp
	clock_ratio = ratio;
 804c80b:	dd 1d 60 52 05 08    	fstpl  0x8055260
}
 804c811:	c9                   	leave  
 804c812:	c3                   	ret    
	clock_ratio = ratio;
 804c813:	dd 05 b8 65 05 08    	fldl   0x80565b8
 804c819:	dd 1d 60 52 05 08    	fstpl  0x8055260
 804c81f:	c3                   	ret    

0804c820 <cmd_rt_drift_found>:
{
 804c820:	f3 0f 1e fb          	endbr32 
 804c824:	55                   	push   %ebp
	if (!(args.rt_drift > -1)) {
 804c825:	d9 e8                	fld1   
 804c827:	d9 e0                	fchs   
{
 804c829:	89 e5                	mov    %esp,%ebp
 804c82b:	83 ec 18             	sub    $0x18,%esp
	if (!(args.rt_drift > -1)) {
 804c82e:	dd 05 b0 65 05 08    	fldl   0x80565b0
 804c834:	df f1                	fcomip %st(1),%st
 804c836:	dd d8                	fstp   %st(0)
 804c838:	77 10                	ja     804c84a <cmd_rt_drift_found+0x2a>
		posix_print_error_and_exit("The drift needs to be > -1. "
 804c83a:	83 ec 0c             	sub    $0xc,%esp
 804c83d:	68 ff 22 05 08       	push   $0x80522ff
 804c842:	e8 f7 0a 00 00       	call   804d33e <posix_print_error_and_exit>
 804c847:	83 c4 10             	add    $0x10,%esp
	args.rt_ratio = args.rt_drift + 1;
 804c84a:	d9 e8                	fld1   
 804c84c:	dc 05 b0 65 05 08    	faddl  0x80565b0
 804c852:	dd 5d f0             	fstpl  -0x10(%ebp)
 804c855:	dd 45 f0             	fldl   -0x10(%ebp)
 804c858:	dd 15 b8 65 05 08    	fstl   0x80565b8
	clock_ratio = ratio;
 804c85e:	dd 1d 60 52 05 08    	fstpl  0x8055260
}
 804c864:	c9                   	leave  
 804c865:	c3                   	ret    

0804c866 <cmd_stop_at_found>:
{
 804c866:	f3 0f 1e fb          	endbr32 
 804c86a:	55                   	push   %ebp
	if (args.stop_at < 0) {
 804c86b:	d9 ee                	fldz   
{
 804c86d:	89 e5                	mov    %esp,%ebp
 804c86f:	53                   	push   %ebx
 804c870:	83 ec 14             	sub    $0x14,%esp
	if (args.stop_at < 0) {
 804c873:	dd 05 a0 65 05 08    	fldl   0x80565a0
 804c879:	d9 c9                	fxch   %st(1)
{
 804c87b:	8b 45 08             	mov    0x8(%ebp),%eax
	if (args.stop_at < 0) {
 804c87e:	df f1                	fcomip %st(1),%st
 804c880:	dd d8                	fstp   %st(0)
 804c882:	76 10                	jbe    804c894 <cmd_stop_at_found+0x2e>
		posix_print_error_and_exit("Error: stop-at must be positive "
 804c884:	52                   	push   %edx
 804c885:	52                   	push   %edx
 804c886:	50                   	push   %eax
 804c887:	68 3c 23 05 08       	push   $0x805233c
 804c88c:	e8 ad 0a 00 00       	call   804d33e <posix_print_error_and_exit>
 804c891:	83 c4 10             	add    $0x10,%esp
	hwm_set_end_of_time(args.stop_at*1e6);
 804c894:	d9 05 c4 12 05 08    	flds   0x80512c4
 804c89a:	dc 0d a0 65 05 08    	fmull  0x80565a0
 804c8a0:	d9 05 c8 12 05 08    	flds   0x80512c8
 804c8a6:	d9 c9                	fxch   %st(1)
 804c8a8:	db f1                	fcomi  %st(1),%st
 804c8aa:	73 21                	jae    804c8cd <cmd_stop_at_found+0x67>
 804c8ac:	dd d9                	fstp   %st(1)
 804c8ae:	d9 7d f6             	fnstcw -0xa(%ebp)
 804c8b1:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
 804c8b5:	80 cc 0c             	or     $0xc,%ah
 804c8b8:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
 804c8bc:	d9 6d f4             	fldcw  -0xc(%ebp)
 804c8bf:	df 7d e8             	fistpll -0x18(%ebp)
 804c8c2:	d9 6d f6             	fldcw  -0xa(%ebp)
 804c8c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c8c8:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804c8cb:	eb 27                	jmp    804c8f4 <cmd_stop_at_found+0x8e>
 804c8cd:	d9 7d f6             	fnstcw -0xa(%ebp)
 804c8d0:	de e1                	fsubp  %st,%st(1)
 804c8d2:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
 804c8d6:	80 cc 0c             	or     $0xc,%ah
 804c8d9:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
 804c8dd:	d9 6d f4             	fldcw  -0xc(%ebp)
 804c8e0:	df 7d e8             	fistpll -0x18(%ebp)
 804c8e3:	d9 6d f6             	fldcw  -0xa(%ebp)
 804c8e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804c8e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c8ec:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804c8f2:	89 ca                	mov    %ecx,%edx
 804c8f4:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804c8f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	hwm_set_end_of_time(args.stop_at*1e6);
 804c8fa:	89 55 0c             	mov    %edx,0xc(%ebp)
}
 804c8fd:	c9                   	leave  
	hwm_set_end_of_time(args.stop_at*1e6);
 804c8fe:	e9 d4 fd ff ff       	jmp    804c6d7 <hwm_set_end_of_time>

0804c903 <get_host_us_time>:
{
 804c903:	f3 0f 1e fb          	endbr32 
 804c907:	55                   	push   %ebp
 804c908:	89 e5                	mov    %esp,%ebp
 804c90a:	53                   	push   %ebx
 804c90b:	83 ec 2c             	sub    $0x2c,%esp
 804c90e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804c914:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c917:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
 804c919:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804c91c:	50                   	push   %eax
 804c91d:	6a 04                	push   $0x4
 804c91f:	e8 5c ca ff ff       	call   8049380 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804c924:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c927:	db 45 ec             	fildl  -0x14(%ebp)
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
 804c92a:	83 c4 10             	add    $0x10,%esp
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804c92d:	99                   	cltd   
 804c92e:	85 d2                	test   %edx,%edx
 804c930:	79 06                	jns    804c938 <get_host_us_time+0x35>
 804c932:	d8 05 c0 12 05 08    	fadds  0x80512c0
 804c938:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c93b:	d8 0d c4 12 05 08    	fmuls  0x80512c4
 804c941:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804c946:	99                   	cltd   
 804c947:	f7 f9                	idiv   %ecx
 804c949:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804c94c:	da 45 d8             	fiaddl -0x28(%ebp)
 804c94f:	d9 05 c8 12 05 08    	flds   0x80512c8
 804c955:	d9 c9                	fxch   %st(1)
 804c957:	db f1                	fcomi  %st(1),%st
 804c959:	73 21                	jae    804c97c <get_host_us_time+0x79>
 804c95b:	dd d9                	fstp   %st(1)
 804c95d:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804c960:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804c964:	80 cc 0c             	or     $0xc,%ah
 804c967:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804c96b:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804c96e:	df 7d d8             	fistpll -0x28(%ebp)
 804c971:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804c974:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c977:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804c97a:	eb 27                	jmp    804c9a3 <get_host_us_time+0xa0>
 804c97c:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804c97f:	de e1                	fsubp  %st,%st(1)
 804c981:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804c985:	80 cc 0c             	or     $0xc,%ah
 804c988:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804c98c:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804c98f:	df 7d d8             	fistpll -0x28(%ebp)
 804c992:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804c995:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804c998:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c99b:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804c9a1:	89 ca                	mov    %ecx,%edx
}
 804c9a3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
 804c9a6:	65 33 1d 14 00 00 00 	xor    %gs:0x14,%ebx
 804c9ad:	74 05                	je     804c9b4 <get_host_us_time+0xb1>
 804c9af:	e8 0c ca ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804c9b4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804c9b7:	c9                   	leave  
 804c9b8:	c3                   	ret    

0804c9b9 <hwtimer_init>:
{
 804c9b9:	f3 0f 1e fb          	endbr32 
 804c9bd:	55                   	push   %ebp
 804c9be:	89 e5                	mov    %esp,%ebp
 804c9c0:	53                   	push   %ebx
 804c9c1:	83 ec 24             	sub    $0x24,%esp
 804c9c4:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804c9ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c9cd:	31 c0                	xor    %eax,%eax
	silent_ticks = 0;
 804c9cf:	c7 05 b0 69 05 08 00 	movl   $0x0,0x80569b0
 804c9d6:	00 00 00 
 804c9d9:	c7 05 b4 69 05 08 00 	movl   $0x0,0x80569b4
 804c9e0:	00 00 00 
	hw_timer_tick_timer = NEVER;
 804c9e3:	c7 05 c8 69 05 08 ff 	movl   $0xffffffff,0x80569c8
 804c9ea:	ff ff ff 
 804c9ed:	c7 05 cc 69 05 08 ff 	movl   $0xffffffff,0x80569cc
 804c9f4:	ff ff ff 
	hw_timer_awake_timer = NEVER;
 804c9f7:	c7 05 c0 69 05 08 ff 	movl   $0xffffffff,0x80569c0
 804c9fe:	ff ff ff 
 804ca01:	c7 05 c4 69 05 08 ff 	movl   $0xffffffff,0x80569c4
 804ca08:	ff ff ff 
	hwtimer_update_timer();
 804ca0b:	e8 2a fd ff ff       	call   804c73a <hwtimer_update_timer>
	if (real_time_mode) {
 804ca10:	80 3d ee 6a 05 08 00 	cmpb   $0x0,0x8056aee
 804ca17:	74 24                	je     804ca3d <hwtimer_init+0x84>
		boot_time = get_host_us_time();
 804ca19:	e8 e5 fe ff ff       	call   804c903 <get_host_us_time>
		last_radj_stime = 0U;
 804ca1e:	c7 05 98 69 05 08 00 	movl   $0x0,0x8056998
 804ca25:	00 00 00 
		last_radj_rtime = boot_time;
 804ca28:	a3 a0 69 05 08       	mov    %eax,0x80569a0
 804ca2d:	89 15 a4 69 05 08    	mov    %edx,0x80569a4
		last_radj_stime = 0U;
 804ca33:	c7 05 9c 69 05 08 00 	movl   $0x0,0x805699c
 804ca3a:	00 00 00 
	if (!reset_rtc) {
 804ca3d:	80 3d ed 6a 05 08 00 	cmpb   $0x0,0x8056aed
 804ca44:	0f 85 98 00 00 00    	jne    804cae2 <hwtimer_init+0x129>
		clock_gettime(CLOCK_REALTIME, &tv);
 804ca4a:	50                   	push   %eax
 804ca4b:	50                   	push   %eax
 804ca4c:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804ca4f:	50                   	push   %eax
 804ca50:	6a 00                	push   $0x0
 804ca52:	e8 29 c9 ff ff       	call   8049380 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804ca57:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ca5a:	db 45 ec             	fildl  -0x14(%ebp)
		clock_gettime(CLOCK_REALTIME, &tv);
 804ca5d:	83 c4 10             	add    $0x10,%esp
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804ca60:	99                   	cltd   
 804ca61:	85 d2                	test   %edx,%edx
 804ca63:	79 06                	jns    804ca6b <hwtimer_init+0xb2>
 804ca65:	d8 05 c0 12 05 08    	fadds  0x80512c0
 804ca6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ca6e:	d8 0d c4 12 05 08    	fmuls  0x80512c4
 804ca74:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804ca79:	99                   	cltd   
 804ca7a:	f7 f9                	idiv   %ecx
 804ca7c:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804ca7f:	da 45 d8             	fiaddl -0x28(%ebp)
 804ca82:	d9 05 c8 12 05 08    	flds   0x80512c8
 804ca88:	d9 c9                	fxch   %st(1)
 804ca8a:	db f1                	fcomi  %st(1),%st
 804ca8c:	73 21                	jae    804caaf <hwtimer_init+0xf6>
 804ca8e:	dd d9                	fstp   %st(1)
 804ca90:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804ca93:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804ca97:	80 cc 0c             	or     $0xc,%ah
 804ca9a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804ca9e:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804caa1:	df 7d d8             	fistpll -0x28(%ebp)
 804caa4:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804caa7:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804caaa:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804caad:	eb 27                	jmp    804cad6 <hwtimer_init+0x11d>
 804caaf:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804cab2:	de e1                	fsubp  %st,%st(1)
 804cab4:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804cab8:	80 cc 0c             	or     $0xc,%ah
 804cabb:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804cabf:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804cac2:	df 7d d8             	fistpll -0x28(%ebp)
 804cac5:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804cac8:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804cacb:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804cace:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804cad4:	89 ca                	mov    %ecx,%edx
		rtc_offset += realhosttime;
 804cad6:	01 05 a8 69 05 08    	add    %eax,0x80569a8
 804cadc:	11 15 ac 69 05 08    	adc    %edx,0x80569ac
}
 804cae2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cae5:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804caec:	74 05                	je     804caf3 <hwtimer_init+0x13a>
 804caee:	e8 cd c8 ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804caf3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804caf6:	c9                   	leave  
 804caf7:	c3                   	ret    

0804caf8 <hwtimer_cleanup>:
{
 804caf8:	f3 0f 1e fb          	endbr32 
}
 804cafc:	c3                   	ret    

0804cafd <hwtimer_enable>:
{
 804cafd:	f3 0f 1e fb          	endbr32 
 804cb01:	55                   	push   %ebp
 804cb02:	89 e5                	mov    %esp,%ebp
 804cb04:	83 ec 08             	sub    $0x8,%esp
	tick_p = period;
 804cb07:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb0a:	8b 55 0c             	mov    0xc(%ebp),%edx
 804cb0d:	a3 b8 69 05 08       	mov    %eax,0x80569b8
 804cb12:	89 15 bc 69 05 08    	mov    %edx,0x80569bc
	hw_timer_tick_timer = hwm_get_time() + tick_p;
 804cb18:	e8 d4 fb ff ff       	call   804c6f1 <hwm_get_time>
 804cb1d:	03 05 b8 69 05 08    	add    0x80569b8,%eax
 804cb23:	13 15 bc 69 05 08    	adc    0x80569bc,%edx
 804cb29:	a3 c8 69 05 08       	mov    %eax,0x80569c8
 804cb2e:	89 15 cc 69 05 08    	mov    %edx,0x80569cc
	hwtimer_update_timer();
 804cb34:	e8 01 fc ff ff       	call   804c73a <hwtimer_update_timer>
}
 804cb39:	c9                   	leave  
	hwm_find_next_timer();
 804cb3a:	e9 23 fa ff ff       	jmp    804c562 <hwm_find_next_timer>

0804cb3f <hwtimer_timer_reached>:
{
 804cb3f:	f3 0f 1e fb          	endbr32 
 804cb43:	55                   	push   %ebp
 804cb44:	89 e5                	mov    %esp,%ebp
 804cb46:	56                   	push   %esi
 804cb47:	53                   	push   %ebx
 804cb48:	83 ec 30             	sub    $0x30,%esp
	uint64_t Now = hw_timer_timer;
 804cb4b:	8b 1d d0 69 05 08    	mov    0x80569d0,%ebx
 804cb51:	8b 35 d4 69 05 08    	mov    0x80569d4,%esi
{
 804cb57:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804cb5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804cb60:	31 c0                	xor    %eax,%eax
	if (hw_timer_awake_timer == Now) {
 804cb62:	39 35 c4 69 05 08    	cmp    %esi,0x80569c4
 804cb68:	75 31                	jne    804cb9b <hwtimer_timer_reached+0x5c>
 804cb6a:	39 1d c0 69 05 08    	cmp    %ebx,0x80569c0
 804cb70:	75 29                	jne    804cb9b <hwtimer_timer_reached+0x5c>
	hw_timer_awake_timer = NEVER;
 804cb72:	c7 05 c0 69 05 08 ff 	movl   $0xffffffff,0x80569c0
 804cb79:	ff ff ff 
 804cb7c:	c7 05 c4 69 05 08 ff 	movl   $0xffffffff,0x80569c4
 804cb83:	ff ff ff 
	hwtimer_update_timer();
 804cb86:	e8 af fb ff ff       	call   804c73a <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
 804cb8b:	83 ec 0c             	sub    $0xc,%esp
 804cb8e:	68 ff ff 00 00       	push   $0xffff
 804cb93:	e8 a2 05 00 00       	call   804d13a <hw_irq_ctrl_set_irq>
 804cb98:	83 c4 10             	add    $0x10,%esp
	if (hw_timer_tick_timer == Now) {
 804cb9b:	8b 15 cc 69 05 08    	mov    0x80569cc,%edx
 804cba1:	a1 c8 69 05 08       	mov    0x80569c8,%eax
 804cba6:	39 f2                	cmp    %esi,%edx
 804cba8:	0f 85 5a 01 00 00    	jne    804cd08 <hwtimer_timer_reached+0x1c9>
 804cbae:	39 d8                	cmp    %ebx,%eax
 804cbb0:	0f 85 52 01 00 00    	jne    804cd08 <hwtimer_timer_reached+0x1c9>
	if (real_time_mode) {
 804cbb6:	80 3d ee 6a 05 08 00 	cmpb   $0x0,0x8056aee
 804cbbd:	0f 84 f6 00 00 00    	je     804ccb9 <hwtimer_timer_reached+0x17a>
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
 804cbc3:	2b 05 98 69 05 08    	sub    0x8056998,%eax
 804cbc9:	1b 15 9c 69 05 08    	sbb    0x805699c,%edx
				    / clock_ratio
 804cbcf:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804cbd2:	89 55 cc             	mov    %edx,-0x34(%ebp)
 804cbd5:	df 6d c8             	fildll -0x38(%ebp)
 804cbd8:	85 d2                	test   %edx,%edx
 804cbda:	79 06                	jns    804cbe2 <hwtimer_timer_reached+0xa3>
 804cbdc:	d8 05 c0 12 05 08    	fadds  0x80512c0
 804cbe2:	dc 35 60 52 05 08    	fdivl  0x8055260
				    + last_radj_rtime;
 804cbe8:	83 3d a4 69 05 08 00 	cmpl   $0x0,0x80569a4
 804cbef:	df 2d a0 69 05 08    	fildll 0x80569a0
 804cbf5:	79 06                	jns    804cbfd <hwtimer_timer_reached+0xbe>
 804cbf7:	d8 05 c0 12 05 08    	fadds  0x80512c0
 804cbfd:	de c1                	faddp  %st,%st(1)
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
 804cbff:	d9 05 c8 12 05 08    	flds   0x80512c8
 804cc05:	d9 c9                	fxch   %st(1)
 804cc07:	db f1                	fcomi  %st(1),%st
 804cc09:	73 1b                	jae    804cc26 <hwtimer_timer_reached+0xe7>
 804cc0b:	dd d9                	fstp   %st(1)
 804cc0d:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804cc10:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804cc14:	80 cc 0c             	or     $0xc,%ah
 804cc17:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804cc1b:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804cc1e:	df 7d c8             	fistpll -0x38(%ebp)
 804cc21:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804cc24:	eb 24                	jmp    804cc4a <hwtimer_timer_reached+0x10b>
 804cc26:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804cc29:	de e1                	fsubp  %st,%st(1)
 804cc2b:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804cc2f:	80 cc 0c             	or     $0xc,%ah
 804cc32:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804cc36:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804cc39:	df 7d c8             	fistpll -0x38(%ebp)
 804cc3c:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804cc3f:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cc42:	05 00 00 00 80       	add    $0x80000000,%eax
 804cc47:	89 45 cc             	mov    %eax,-0x34(%ebp)
		uint64_t real_time = get_host_us_time();
 804cc4a:	e8 b4 fc ff ff       	call   804c903 <get_host_us_time>
		int64_t diff = expected_rt - real_time;
 804cc4f:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 804cc52:	8b 5d cc             	mov    -0x34(%ebp),%ebx
 804cc55:	29 c1                	sub    %eax,%ecx
 804cc57:	19 d3                	sbb    %edx,%ebx
 804cc59:	89 4d c8             	mov    %ecx,-0x38(%ebp)
		if (diff > 0) { /* we need to slow down */
 804cc5c:	31 c0                	xor    %eax,%eax
 804cc5e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
		int64_t diff = expected_rt - real_time;
 804cc61:	89 5d cc             	mov    %ebx,-0x34(%ebp)
		if (diff > 0) { /* we need to slow down */
 804cc64:	1b 45 cc             	sbb    -0x34(%ebp),%eax
 804cc67:	7d 50                	jge    804ccb9 <hwtimer_timer_reached+0x17a>
			requested_time.tv_sec  = diff / 1e6;
 804cc69:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804cc6c:	df 6d c8             	fildll -0x38(%ebp)
 804cc6f:	d9 05 c4 12 05 08    	flds   0x80512c4
 804cc75:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804cc79:	d9 c1                	fld    %st(1)
 804cc7b:	d8 f1                	fdiv   %st(1),%st
 804cc7d:	80 cc 0c             	or     $0xc,%ah
 804cc80:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804cc84:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804cc87:	db 5d c8             	fistpl -0x38(%ebp)
 804cc8a:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804cc8d:	8b 45 c8             	mov    -0x38(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
 804cc90:	da 4d c8             	fimull -0x38(%ebp)
			requested_time.tv_sec  = diff / 1e6;
 804cc93:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			(void) nanosleep(&requested_time, &remaining);
 804cc96:	50                   	push   %eax
 804cc97:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
 804cc98:	de e9                	fsubrp %st,%st(1)
			(void) nanosleep(&requested_time, &remaining);
 804cc9a:	8d 45 ec             	lea    -0x14(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
 804cc9d:	d8 0d cc 12 05 08    	fmuls  0x80512cc
			(void) nanosleep(&requested_time, &remaining);
 804cca3:	50                   	push   %eax
 804cca4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804cca7:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
 804cca8:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804ccab:	db 5d e8             	fistpl -0x18(%ebp)
 804ccae:	d9 6d d6             	fldcw  -0x2a(%ebp)
			(void) nanosleep(&requested_time, &remaining);
 804ccb1:	e8 6a c8 ff ff       	call   8049520 <nanosleep@plt>
 804ccb6:	83 c4 10             	add    $0x10,%esp
	hw_timer_tick_timer += tick_p;
 804ccb9:	a1 b8 69 05 08       	mov    0x80569b8,%eax
 804ccbe:	8b 15 bc 69 05 08    	mov    0x80569bc,%edx
 804ccc4:	01 05 c8 69 05 08    	add    %eax,0x80569c8
 804ccca:	11 15 cc 69 05 08    	adc    %edx,0x80569cc
	hwtimer_update_timer();
 804ccd0:	e8 65 fa ff ff       	call   804c73a <hwtimer_update_timer>
	if (silent_ticks > 0) {
 804ccd5:	a1 b0 69 05 08       	mov    0x80569b0,%eax
 804ccda:	31 c9                	xor    %ecx,%ecx
 804ccdc:	8b 15 b4 69 05 08    	mov    0x80569b4,%edx
 804cce2:	39 c1                	cmp    %eax,%ecx
 804cce4:	19 d1                	sbb    %edx,%ecx
 804cce6:	7d 13                	jge    804ccfb <hwtimer_timer_reached+0x1bc>
		silent_ticks -= 1;
 804cce8:	83 c0 ff             	add    $0xffffffff,%eax
 804cceb:	83 d2 ff             	adc    $0xffffffff,%edx
 804ccee:	a3 b0 69 05 08       	mov    %eax,0x80569b0
 804ccf3:	89 15 b4 69 05 08    	mov    %edx,0x80569b4
 804ccf9:	eb 0d                	jmp    804cd08 <hwtimer_timer_reached+0x1c9>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
 804ccfb:	83 ec 0c             	sub    $0xc,%esp
 804ccfe:	6a 00                	push   $0x0
 804cd00:	e8 35 04 00 00       	call   804d13a <hw_irq_ctrl_set_irq>
 804cd05:	83 c4 10             	add    $0x10,%esp
}
 804cd08:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cd0b:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804cd12:	74 05                	je     804cd19 <hwtimer_timer_reached+0x1da>
 804cd14:	e8 a7 c6 ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804cd19:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804cd1c:	5b                   	pop    %ebx
 804cd1d:	5e                   	pop    %esi
 804cd1e:	5d                   	pop    %ebp
 804cd1f:	c3                   	ret    

0804cd20 <hwtimer_set_silent_ticks>:
{
 804cd20:	f3 0f 1e fb          	endbr32 
 804cd24:	55                   	push   %ebp
 804cd25:	89 e5                	mov    %esp,%ebp
	silent_ticks = sys_ticks;
 804cd27:	8b 45 08             	mov    0x8(%ebp),%eax
 804cd2a:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804cd2d:	5d                   	pop    %ebp
	silent_ticks = sys_ticks;
 804cd2e:	a3 b0 69 05 08       	mov    %eax,0x80569b0
 804cd33:	89 15 b4 69 05 08    	mov    %edx,0x80569b4
}
 804cd39:	c3                   	ret    

0804cd3a <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
 804cd3a:	f3 0f 1e fb          	endbr32 
 804cd3e:	55                   	push   %ebp
 804cd3f:	89 e5                	mov    %esp,%ebp
 804cd41:	57                   	push   %edi
 804cd42:	56                   	push   %esi
 804cd43:	53                   	push   %ebx
 804cd44:	83 ec 0c             	sub    $0xc,%esp
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
 804cd47:	e8 67 03 00 00       	call   804d0b3 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
 804cd4c:	85 c0                	test   %eax,%eax
 804cd4e:	0f 85 f9 00 00 00    	jne    804ce4d <posix_irq_handler+0x113>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
 804cd54:	a1 60 69 05 08       	mov    0x8056960,%eax
 804cd59:	85 c0                	test   %eax,%eax
 804cd5b:	75 0a                	jne    804cd67 <posix_irq_handler+0x2d>
		may_swap = 0;
 804cd5d:	c7 05 a0 6a 05 08 00 	movl   $0x0,0x8056aa0
 804cd64:	00 00 00 
	}

	_kernel.cpus[0].nested++;
 804cd67:	40                   	inc    %eax
 804cd68:	a3 60 69 05 08       	mov    %eax,0x8056960

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
 804cd6d:	e8 a9 02 00 00       	call   804d01b <hw_irq_ctrl_get_highest_prio_irq>
 804cd72:	89 c3                	mov    %eax,%ebx
 804cd74:	83 f8 ff             	cmp    $0xffffffff,%eax
 804cd77:	0f 84 9b 00 00 00    	je     804ce18 <posix_irq_handler+0xde>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
 804cd7d:	e8 68 02 00 00       	call   804cfea <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804cd82:	83 ec 0c             	sub    $0xc,%esp
		int last_running_irq = currently_running_irq;
 804cd85:	8b 3d 7c 52 05 08    	mov    0x805527c,%edi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804cd8b:	53                   	push   %ebx
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
 804cd8c:	89 c6                	mov    %eax,%esi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804cd8e:	e8 76 02 00 00       	call   804d009 <hw_irq_ctrl_get_prio>
 804cd93:	0f b6 c0             	movzbl %al,%eax
 804cd96:	89 04 24             	mov    %eax,(%esp)
 804cd99:	e8 3b 02 00 00       	call   804cfd9 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
 804cd9e:	89 1c 24             	mov    %ebx,(%esp)
 804cda1:	e8 53 03 00 00       	call   804d0f9 <hw_irq_ctrl_clear_irq>
 804cda6:	83 c4 10             	add    $0x10,%esp

		currently_running_irq = irq_nbr;
 804cda9:	89 1d 7c 52 05 08    	mov    %ebx,0x805527c
	sys_trace_isr_enter();
 804cdaf:	e8 90 ee ff ff       	call   804bc44 <sys_trace_isr_enter>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
 804cdb4:	89 d8                	mov    %ebx,%eax
 804cdb6:	c1 e0 04             	shl    $0x4,%eax
 804cdb9:	05 c0 65 05 08       	add    $0x80565c0,%eax
 804cdbe:	8b 50 08             	mov    0x8(%eax),%edx
 804cdc1:	85 d2                	test   %edx,%edx
 804cdc3:	75 12                	jne    804cdd7 <posix_irq_handler+0x9d>
		posix_print_error_and_exit("Received irq %i without a "
 804cdc5:	50                   	push   %eax
 804cdc6:	50                   	push   %eax
 804cdc7:	53                   	push   %ebx
 804cdc8:	68 3b 27 05 08       	push   $0x805273b
 804cdcd:	e8 6c 05 00 00       	call   804d33e <posix_print_error_and_exit>
 804cdd2:	83 c4 10             	add    $0x10,%esp
 804cdd5:	eb 25                	jmp    804cdfc <posix_irq_handler+0xc2>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
 804cdd7:	f6 40 04 01          	testb  $0x1,0x4(%eax)
 804cddb:	74 0a                	je     804cde7 <posix_irq_handler+0xad>
			*may_swap |= ((direct_irq_f_ptr)
 804cddd:	ff d2                	call   *%edx
 804cddf:	09 05 a0 6a 05 08    	or     %eax,0x8056aa0
 804cde5:	eb 15                	jmp    804cdfc <posix_irq_handler+0xc2>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
 804cde7:	83 ec 0c             	sub    $0xc,%esp
 804cdea:	ff 70 0c             	pushl  0xc(%eax)
 804cded:	ff d2                	call   *%edx
			*may_swap = 1;
 804cdef:	c7 05 a0 6a 05 08 01 	movl   $0x1,0x8056aa0
 804cdf6:	00 00 00 
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
 804cdf9:	83 c4 10             	add    $0x10,%esp
	sys_trace_isr_exit();
 804cdfc:	e8 48 ee ff ff       	call   804bc49 <sys_trace_isr_exit>
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
 804ce01:	83 ec 0c             	sub    $0xc,%esp
		currently_running_irq = last_running_irq;
 804ce04:	89 3d 7c 52 05 08    	mov    %edi,0x805527c
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
 804ce0a:	56                   	push   %esi
 804ce0b:	e8 c9 01 00 00       	call   804cfd9 <hw_irq_ctrl_set_cur_prio>
 804ce10:	83 c4 10             	add    $0x10,%esp
 804ce13:	e9 55 ff ff ff       	jmp    804cd6d <posix_irq_handler+0x33>
	}

	_kernel.cpus[0].nested--;
 804ce18:	ff 0d 60 69 05 08    	decl   0x8056960
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
 804ce1e:	83 3d a0 6a 05 08 00 	cmpl   $0x0,0x8056aa0
 804ce25:	74 26                	je     804ce4d <posix_irq_handler+0x113>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
 804ce27:	e8 be 01 00 00       	call   804cfea <hw_irq_ctrl_get_cur_prio>
 804ce2c:	3d 00 01 00 00       	cmp    $0x100,%eax
 804ce31:	75 1a                	jne    804ce4d <posix_irq_handler+0x113>
		&& (_kernel.ready_q.cache != _current)) {
 804ce33:	a1 68 69 05 08       	mov    0x8056968,%eax
 804ce38:	39 05 78 69 05 08    	cmp    %eax,0x8056978
 804ce3e:	74 0d                	je     804ce4d <posix_irq_handler+0x113>

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
 804ce40:	83 ec 0c             	sub    $0xc,%esp
 804ce43:	6a 00                	push   $0x0
 804ce45:	e8 de f2 ff ff       	call   804c128 <arch_swap>
 804ce4a:	83 c4 10             	add    $0x10,%esp

		(void)z_swap_irqlock(irq_lock);
	}
}
 804ce4d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ce50:	5b                   	pop    %ebx
 804ce51:	5e                   	pop    %esi
 804ce52:	5f                   	pop    %edi
 804ce53:	5d                   	pop    %ebp
 804ce54:	c3                   	ret    

0804ce55 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
 804ce55:	f3 0f 1e fb          	endbr32 
 804ce59:	55                   	push   %ebp
 804ce5a:	89 e5                	mov    %esp,%ebp
 804ce5c:	83 ec 08             	sub    $0x8,%esp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
 804ce5f:	e8 b7 01 00 00       	call   804d01b <hw_irq_ctrl_get_highest_prio_irq>
 804ce64:	40                   	inc    %eax
 804ce65:	74 23                	je     804ce8a <posix_irq_handler_im_from_sw+0x35>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
 804ce67:	e8 d4 f3 ff ff       	call   804c240 <posix_is_cpu_running>
 804ce6c:	85 c0                	test   %eax,%eax
 804ce6e:	75 14                	jne    804ce84 <posix_irq_handler_im_from_sw+0x2f>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
 804ce70:	50                   	push   %eax
 804ce71:	50                   	push   %eax
 804ce72:	68 d4 12 05 08       	push   $0x80512d4
 804ce77:	68 69 27 05 08       	push   $0x8052769
 804ce7c:	e8 bd 04 00 00       	call   804d33e <posix_print_error_and_exit>
 804ce81:	83 c4 10             	add    $0x10,%esp
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
 804ce84:	c9                   	leave  
		posix_irq_handler();
 804ce85:	e9 b0 fe ff ff       	jmp    804cd3a <posix_irq_handler>
}
 804ce8a:	c9                   	leave  
 804ce8b:	c3                   	ret    

0804ce8c <posix_irq_lock>:
 * @return An architecture-dependent lock-out key representing the
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
 804ce8c:	f3 0f 1e fb          	endbr32 
 804ce90:	55                   	push   %ebp
 804ce91:	89 e5                	mov    %esp,%ebp
 804ce93:	83 ec 14             	sub    $0x14,%esp
	return hw_irq_ctrl_change_lock(true);
 804ce96:	6a 01                	push   $0x1
 804ce98:	e8 22 02 00 00       	call   804d0bf <hw_irq_ctrl_change_lock>
 804ce9d:	83 c4 10             	add    $0x10,%esp
}
 804cea0:	c9                   	leave  
 804cea1:	c3                   	ret    

0804cea2 <posix_irq_unlock>:
 * board_irq_lock().
 *
 * This routine can be called from either interrupt, task or fiber level.
 */
void posix_irq_unlock(unsigned int key)
{
 804cea2:	f3 0f 1e fb          	endbr32 
	hw_irq_ctrl_change_lock(key);
 804cea6:	e9 14 02 00 00       	jmp    804d0bf <hw_irq_ctrl_change_lock>

0804ceab <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
 804ceab:	f3 0f 1e fb          	endbr32 
 804ceaf:	55                   	push   %ebp
 804ceb0:	89 e5                	mov    %esp,%ebp
 804ceb2:	83 ec 14             	sub    $0x14,%esp
	hw_irq_ctrl_change_lock(false);
 804ceb5:	6a 00                	push   $0x0
 804ceb7:	e8 03 02 00 00       	call   804d0bf <hw_irq_ctrl_change_lock>
 804cebc:	83 c4 10             	add    $0x10,%esp
}
 804cebf:	c9                   	leave  
 804cec0:	c3                   	ret    

0804cec1 <posix_irq_enable>:

void posix_irq_enable(unsigned int irq)
{
 804cec1:	f3 0f 1e fb          	endbr32 
	hw_irq_ctrl_enable_irq(irq);
 804cec5:	e9 cf 02 00 00       	jmp    804d199 <hw_irq_ctrl_enable_irq>

0804ceca <posix_isr_declare>:
 * @param isr_param_p ISR parameter
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
 804ceca:	f3 0f 1e fb          	endbr32 
 804cece:	55                   	push   %ebp
 804cecf:	89 e5                	mov    %esp,%ebp
 804ced1:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_vector_table[irq_p].irq   = irq_p;
 804ced4:	89 ca                	mov    %ecx,%edx
 804ced6:	c1 e2 04             	shl    $0x4,%edx
 804ced9:	8d 82 c0 65 05 08    	lea    0x80565c0(%edx),%eax
 804cedf:	89 8a c0 65 05 08    	mov    %ecx,0x80565c0(%edx)
	irq_vector_table[irq_p].func  = isr_p;
 804cee5:	8b 55 10             	mov    0x10(%ebp),%edx
 804cee8:	89 50 08             	mov    %edx,0x8(%eax)
	irq_vector_table[irq_p].param = isr_param_p;
 804ceeb:	8b 55 14             	mov    0x14(%ebp),%edx
 804ceee:	89 50 0c             	mov    %edx,0xc(%eax)
	irq_vector_table[irq_p].flags = flags;
 804cef1:	8b 55 0c             	mov    0xc(%ebp),%edx
 804cef4:	89 50 04             	mov    %edx,0x4(%eax)
}
 804cef7:	5d                   	pop    %ebp
 804cef8:	c3                   	ret    

0804cef9 <posix_irq_priority_set>:
 * @brief Set an interrupt's priority
 *
 * Lower values take priority over higher values.
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
 804cef9:	f3 0f 1e fb          	endbr32 
	hw_irq_ctrl_prio_set(irq, prio);
 804cefd:	e9 f2 00 00 00       	jmp    804cff4 <hw_irq_ctrl_prio_set>

0804cf02 <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
 804cf02:	80 3d f0 6a 05 08 00 	cmpb   $0x0,0x8056af0
 804cf09:	74 09                	je     804cf14 <irq_raising_from_hw_now+0x12>
 804cf0b:	80 3d ef 6a 05 08 00 	cmpb   $0x0,0x8056aef
 804cf12:	74 0c                	je     804cf20 <irq_raising_from_hw_now+0x1e>
		lock_ignore = false;
 804cf14:	c6 05 ef 6a 05 08 00 	movb   $0x0,0x8056aef
		posix_interrupt_raised();
 804cf1b:	e9 b6 f3 ff ff       	jmp    804c2d6 <posix_interrupt_raised>
	}
}
 804cf20:	c3                   	ret    

0804cf21 <hw_irq_ctrl_irq_raise_prefix>:
{
 804cf21:	89 c1                	mov    %eax,%ecx
	if (irq < N_IRQS) {
 804cf23:	83 f8 1f             	cmp    $0x1f,%eax
 804cf26:	77 4e                	ja     804cf76 <hw_irq_ctrl_irq_raise_prefix+0x55>
{
 804cf28:	55                   	push   %ebp
		irq_premask |= ((uint64_t)1<<irq);
 804cf29:	31 c0                	xor    %eax,%eax
 804cf2b:	31 d2                	xor    %edx,%edx
 804cf2d:	f6 c1 20             	test   $0x20,%cl
 804cf30:	0f 94 c0             	sete   %al
 804cf33:	0f 95 c2             	setne  %dl
 804cf36:	d3 e2                	shl    %cl,%edx
 804cf38:	d3 e0                	shl    %cl,%eax
 804cf3a:	09 15 e4 69 05 08    	or     %edx,0x80569e4
{
 804cf40:	89 e5                	mov    %esp,%ebp
 804cf42:	56                   	push   %esi
		if (irq_mask & (1 << irq)) {
 804cf43:	be 01 00 00 00       	mov    $0x1,%esi
 804cf48:	d3 e6                	shl    %cl,%esi
{
 804cf4a:	53                   	push   %ebx
		if (irq_mask & (1 << irq)) {
 804cf4b:	8b 0d dc 69 05 08    	mov    0x80569dc,%ecx
 804cf51:	89 f3                	mov    %esi,%ebx
 804cf53:	23 35 d8 69 05 08    	and    0x80569d8,%esi
		irq_premask |= ((uint64_t)1<<irq);
 804cf59:	09 05 e0 69 05 08    	or     %eax,0x80569e0
		if (irq_mask & (1 << irq)) {
 804cf5f:	c1 fb 1f             	sar    $0x1f,%ebx
 804cf62:	21 d9                	and    %ebx,%ecx
 804cf64:	09 f1                	or     %esi,%ecx
 804cf66:	74 1d                	je     804cf85 <hw_irq_ctrl_irq_raise_prefix+0x64>
			irq_status |= ((uint64_t)1<<irq);
 804cf68:	09 05 e8 69 05 08    	or     %eax,0x80569e8
 804cf6e:	09 15 ec 69 05 08    	or     %edx,0x80569ec
 804cf74:	eb 0f                	jmp    804cf85 <hw_irq_ctrl_irq_raise_prefix+0x64>
	} else if (irq == PHONY_HARD_IRQ) {
 804cf76:	3d ff ff 00 00       	cmp    $0xffff,%eax
 804cf7b:	75 0c                	jne    804cf89 <hw_irq_ctrl_irq_raise_prefix+0x68>
		lock_ignore = true;
 804cf7d:	c6 05 ef 6a 05 08 01 	movb   $0x1,0x8056aef
}
 804cf84:	c3                   	ret    
 804cf85:	5b                   	pop    %ebx
 804cf86:	5e                   	pop    %esi
 804cf87:	5d                   	pop    %ebp
 804cf88:	c3                   	ret    
 804cf89:	c3                   	ret    

0804cf8a <hw_irq_ctrl_init>:
{
 804cf8a:	f3 0f 1e fb          	endbr32 
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
 804cf8e:	c7 05 d8 69 05 08 00 	movl   $0x0,0x80569d8
 804cf95:	00 00 00 
	for (int i = 0 ; i < N_IRQS; i++) {
 804cf98:	31 c0                	xor    %eax,%eax
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
 804cf9a:	c7 05 dc 69 05 08 00 	movl   $0x0,0x80569dc
 804cfa1:	00 00 00 
	irq_premask = 0U;
 804cfa4:	c7 05 e0 69 05 08 00 	movl   $0x0,0x80569e0
 804cfab:	00 00 00 
 804cfae:	c7 05 e4 69 05 08 00 	movl   $0x0,0x80569e4
 804cfb5:	00 00 00 
	irqs_locked = false;
 804cfb8:	c6 05 f0 6a 05 08 00 	movb   $0x0,0x8056af0
	lock_ignore = false;
 804cfbf:	c6 05 ef 6a 05 08 00 	movb   $0x0,0x8056aef
		irq_prio[i] = 255U;
 804cfc6:	c6 80 c0 67 05 08 ff 	movb   $0xff,0x80567c0(%eax)
	for (int i = 0 ; i < N_IRQS; i++) {
 804cfcd:	40                   	inc    %eax
 804cfce:	83 f8 20             	cmp    $0x20,%eax
 804cfd1:	75 f3                	jne    804cfc6 <hw_irq_ctrl_init+0x3c>
}
 804cfd3:	c3                   	ret    

0804cfd4 <hw_irq_ctrl_cleanup>:
{
 804cfd4:	f3 0f 1e fb          	endbr32 
}
 804cfd8:	c3                   	ret    

0804cfd9 <hw_irq_ctrl_set_cur_prio>:
{
 804cfd9:	f3 0f 1e fb          	endbr32 
 804cfdd:	55                   	push   %ebp
 804cfde:	89 e5                	mov    %esp,%ebp
	currently_running_prio = new;
 804cfe0:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804cfe3:	5d                   	pop    %ebp
	currently_running_prio = new;
 804cfe4:	a3 80 52 05 08       	mov    %eax,0x8055280
}
 804cfe9:	c3                   	ret    

0804cfea <hw_irq_ctrl_get_cur_prio>:
{
 804cfea:	f3 0f 1e fb          	endbr32 
}
 804cfee:	a1 80 52 05 08       	mov    0x8055280,%eax
 804cff3:	c3                   	ret    

0804cff4 <hw_irq_ctrl_prio_set>:
{
 804cff4:	f3 0f 1e fb          	endbr32 
 804cff8:	55                   	push   %ebp
 804cff9:	89 e5                	mov    %esp,%ebp
	irq_prio[irq] = prio;
 804cffb:	8b 45 08             	mov    0x8(%ebp),%eax
 804cffe:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804d001:	5d                   	pop    %ebp
	irq_prio[irq] = prio;
 804d002:	88 90 c0 67 05 08    	mov    %dl,0x80567c0(%eax)
}
 804d008:	c3                   	ret    

0804d009 <hw_irq_ctrl_get_prio>:
{
 804d009:	f3 0f 1e fb          	endbr32 
 804d00d:	55                   	push   %ebp
 804d00e:	89 e5                	mov    %esp,%ebp
	return irq_prio[irq];
 804d010:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804d013:	5d                   	pop    %ebp
	return irq_prio[irq];
 804d014:	8a 80 c0 67 05 08    	mov    0x80567c0(%eax),%al
}
 804d01a:	c3                   	ret    

0804d01b <hw_irq_ctrl_get_highest_prio_irq>:
{
 804d01b:	f3 0f 1e fb          	endbr32 
		return -1;
 804d01f:	83 ca ff             	or     $0xffffffff,%edx
	if (irqs_locked) {
 804d022:	80 3d f0 6a 05 08 00 	cmpb   $0x0,0x8056af0
 804d029:	0f 85 81 00 00 00    	jne    804d0b0 <hw_irq_ctrl_get_highest_prio_irq+0x95>
{
 804d02f:	55                   	push   %ebp
 804d030:	89 e5                	mov    %esp,%ebp
 804d032:	57                   	push   %edi
 804d033:	56                   	push   %esi
 804d034:	53                   	push   %ebx
	int winner_prio = 256;
 804d035:	bb 00 01 00 00       	mov    $0x100,%ebx
{
 804d03a:	83 ec 14             	sub    $0x14,%esp
	return irq_status;
 804d03d:	8b 3d ec 69 05 08    	mov    0x80569ec,%edi
 804d043:	a1 e8 69 05 08       	mov    0x80569e8,%eax
 804d048:	89 7d e8             	mov    %edi,-0x18(%ebp)
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
 804d04b:	8b 3d 80 52 05 08    	mov    0x8055280,%edi
 804d051:	89 7d ec             	mov    %edi,-0x14(%ebp)
	while (irq_status != 0U) {
 804d054:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 804d057:	09 c1                	or     %eax,%ecx
 804d059:	74 4b                	je     804d0a6 <hw_irq_ctrl_get_highest_prio_irq+0x8b>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
 804d05b:	0f bc c8             	bsf    %eax,%ecx
		int irq_nbr = find_lsb_set(irq_status) - 1;
 804d05e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804d063:	be 01 00 00 00       	mov    $0x1,%esi
		int irq_nbr = find_lsb_set(irq_status) - 1;
 804d068:	0f 44 cf             	cmove  %edi,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804d06b:	31 ff                	xor    %edi,%edi
 804d06d:	0f a5 f7             	shld   %cl,%esi,%edi
 804d070:	d3 e6                	shl    %cl,%esi
 804d072:	f6 c1 20             	test   $0x20,%cl
 804d075:	74 04                	je     804d07b <hw_irq_ctrl_get_highest_prio_irq+0x60>
 804d077:	89 f7                	mov    %esi,%edi
 804d079:	31 f6                	xor    %esi,%esi
 804d07b:	89 75 e0             	mov    %esi,-0x20(%ebp)
 804d07e:	8b 75 e0             	mov    -0x20(%ebp),%esi
 804d081:	89 7d e4             	mov    %edi,-0x1c(%ebp)
 804d084:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 804d087:	f7 d6                	not    %esi
 804d089:	21 f0                	and    %esi,%eax
		if ((winner_prio > (int)irq_prio[irq_nbr])
 804d08b:	0f b6 b1 c0 67 05 08 	movzbl 0x80567c0(%ecx),%esi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804d092:	f7 d7                	not    %edi
 804d094:	21 7d e8             	and    %edi,-0x18(%ebp)
		if ((winner_prio > (int)irq_prio[irq_nbr])
 804d097:	39 de                	cmp    %ebx,%esi
 804d099:	7d b9                	jge    804d054 <hw_irq_ctrl_get_highest_prio_irq+0x39>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
 804d09b:	3b 75 ec             	cmp    -0x14(%ebp),%esi
 804d09e:	0f 4c de             	cmovl  %esi,%ebx
 804d0a1:	0f 4c d1             	cmovl  %ecx,%edx
 804d0a4:	eb ae                	jmp    804d054 <hw_irq_ctrl_get_highest_prio_irq+0x39>
}
 804d0a6:	83 c4 14             	add    $0x14,%esp
 804d0a9:	89 d0                	mov    %edx,%eax
 804d0ab:	5b                   	pop    %ebx
 804d0ac:	5e                   	pop    %esi
 804d0ad:	5f                   	pop    %edi
 804d0ae:	5d                   	pop    %ebp
 804d0af:	c3                   	ret    
 804d0b0:	89 d0                	mov    %edx,%eax
 804d0b2:	c3                   	ret    

0804d0b3 <hw_irq_ctrl_get_current_lock>:
{
 804d0b3:	f3 0f 1e fb          	endbr32 
	return irqs_locked;
 804d0b7:	0f b6 05 f0 6a 05 08 	movzbl 0x8056af0,%eax
}
 804d0be:	c3                   	ret    

0804d0bf <hw_irq_ctrl_change_lock>:
{
 804d0bf:	f3 0f 1e fb          	endbr32 
 804d0c3:	55                   	push   %ebp
 804d0c4:	89 e5                	mov    %esp,%ebp
 804d0c6:	53                   	push   %ebx
 804d0c7:	51                   	push   %ecx
 804d0c8:	8b 55 08             	mov    0x8(%ebp),%edx
	uint32_t previous_lock = irqs_locked;
 804d0cb:	0f b6 1d f0 6a 05 08 	movzbl 0x8056af0,%ebx
	irqs_locked = new_lock;
 804d0d2:	85 d2                	test   %edx,%edx
 804d0d4:	0f 95 05 f0 6a 05 08 	setne  0x8056af0
	if ((previous_lock == true) && (new_lock == false)) {
 804d0db:	75 16                	jne    804d0f3 <hw_irq_ctrl_change_lock+0x34>
 804d0dd:	84 db                	test   %bl,%bl
 804d0df:	74 12                	je     804d0f3 <hw_irq_ctrl_change_lock+0x34>
		if (irq_status != 0U) {
 804d0e1:	a1 ec 69 05 08       	mov    0x80569ec,%eax
 804d0e6:	0b 05 e8 69 05 08    	or     0x80569e8,%eax
 804d0ec:	74 05                	je     804d0f3 <hw_irq_ctrl_change_lock+0x34>
			posix_irq_handler_im_from_sw();
 804d0ee:	e8 62 fd ff ff       	call   804ce55 <posix_irq_handler_im_from_sw>
}
 804d0f3:	89 d8                	mov    %ebx,%eax
 804d0f5:	5a                   	pop    %edx
 804d0f6:	5b                   	pop    %ebx
 804d0f7:	5d                   	pop    %ebp
 804d0f8:	c3                   	ret    

0804d0f9 <hw_irq_ctrl_clear_irq>:
{
 804d0f9:	f3 0f 1e fb          	endbr32 
 804d0fd:	55                   	push   %ebp
 804d0fe:	89 e5                	mov    %esp,%ebp
 804d100:	57                   	push   %edi
	irq_status  &= ~((uint64_t)1<<irq);
 804d101:	8b 4d 08             	mov    0x8(%ebp),%ecx
{
 804d104:	56                   	push   %esi
	irq_status  &= ~((uint64_t)1<<irq);
 804d105:	89 cf                	mov    %ecx,%edi
 804d107:	c1 ef 05             	shr    $0x5,%edi
 804d10a:	83 e7 01             	and    $0x1,%edi
 804d10d:	89 fe                	mov    %edi,%esi
 804d10f:	d3 e7                	shl    %cl,%edi
 804d111:	83 f6 01             	xor    $0x1,%esi
 804d114:	89 f8                	mov    %edi,%eax
 804d116:	d3 e6                	shl    %cl,%esi
 804d118:	f7 d0                	not    %eax
 804d11a:	21 05 ec 69 05 08    	and    %eax,0x80569ec
 804d120:	89 f2                	mov    %esi,%edx
	irq_premask &= ~((uint64_t)1<<irq);
 804d122:	21 05 e4 69 05 08    	and    %eax,0x80569e4
}
 804d128:	5e                   	pop    %esi
	irq_status  &= ~((uint64_t)1<<irq);
 804d129:	f7 d2                	not    %edx
}
 804d12b:	5f                   	pop    %edi
	irq_status  &= ~((uint64_t)1<<irq);
 804d12c:	21 15 e8 69 05 08    	and    %edx,0x80569e8
	irq_premask &= ~((uint64_t)1<<irq);
 804d132:	21 15 e0 69 05 08    	and    %edx,0x80569e0
}
 804d138:	5d                   	pop    %ebp
 804d139:	c3                   	ret    

0804d13a <hw_irq_ctrl_set_irq>:
{
 804d13a:	f3 0f 1e fb          	endbr32 
 804d13e:	55                   	push   %ebp
 804d13f:	89 e5                	mov    %esp,%ebp
 804d141:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
 804d144:	8b 45 08             	mov    0x8(%ebp),%eax
 804d147:	e8 d5 fd ff ff       	call   804cf21 <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
 804d14c:	80 3d f0 6a 05 08 00 	cmpb   $0x0,0x8056af0
 804d153:	74 09                	je     804d15e <hw_irq_ctrl_set_irq+0x24>
 804d155:	80 3d ef 6a 05 08 00 	cmpb   $0x0,0x8056aef
 804d15c:	74 16                	je     804d174 <hw_irq_ctrl_set_irq+0x3a>
		irq_ctrl_timer = hwm_get_time();
 804d15e:	e8 8e f5 ff ff       	call   804c6f1 <hwm_get_time>
 804d163:	a3 68 52 05 08       	mov    %eax,0x8055268
 804d168:	89 15 6c 52 05 08    	mov    %edx,0x805526c
}
 804d16e:	c9                   	leave  
		hwm_find_next_timer();
 804d16f:	e9 ee f3 ff ff       	jmp    804c562 <hwm_find_next_timer>
}
 804d174:	c9                   	leave  
 804d175:	c3                   	ret    

0804d176 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
 804d176:	f3 0f 1e fb          	endbr32 
 804d17a:	55                   	push   %ebp
 804d17b:	89 e5                	mov    %esp,%ebp
 804d17d:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
 804d180:	8b 45 08             	mov    0x8(%ebp),%eax
 804d183:	e8 99 fd ff ff       	call   804cf21 <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
 804d188:	80 3d f0 6a 05 08 00 	cmpb   $0x0,0x8056af0
 804d18f:	75 06                	jne    804d197 <hw_irq_ctrl_raise_im_from_sw+0x21>
		posix_irq_handler_im_from_sw();
	}
}
 804d191:	c9                   	leave  
		posix_irq_handler_im_from_sw();
 804d192:	e9 be fc ff ff       	jmp    804ce55 <posix_irq_handler_im_from_sw>
}
 804d197:	c9                   	leave  
 804d198:	c3                   	ret    

0804d199 <hw_irq_ctrl_enable_irq>:
{
 804d199:	f3 0f 1e fb          	endbr32 
 804d19d:	55                   	push   %ebp
	irq_mask |= ((uint64_t)1<<irq);
 804d19e:	31 c0                	xor    %eax,%eax
 804d1a0:	31 d2                	xor    %edx,%edx
{
 804d1a2:	89 e5                	mov    %esp,%ebp
 804d1a4:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_mask |= ((uint64_t)1<<irq);
 804d1a7:	f6 c1 20             	test   $0x20,%cl
 804d1aa:	0f 94 c0             	sete   %al
 804d1ad:	0f 95 c2             	setne  %dl
 804d1b0:	d3 e2                	shl    %cl,%edx
 804d1b2:	d3 e0                	shl    %cl,%eax
 804d1b4:	09 15 dc 69 05 08    	or     %edx,0x80569dc
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
 804d1ba:	8b 15 e4 69 05 08    	mov    0x80569e4,%edx
	irq_mask |= ((uint64_t)1<<irq);
 804d1c0:	09 05 d8 69 05 08    	or     %eax,0x80569d8
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
 804d1c6:	a1 e0 69 05 08       	mov    0x80569e0,%eax
 804d1cb:	0f ad d0             	shrd   %cl,%edx,%eax
 804d1ce:	d3 ea                	shr    %cl,%edx
 804d1d0:	f6 c1 20             	test   $0x20,%cl
 804d1d3:	74 02                	je     804d1d7 <hw_irq_ctrl_enable_irq+0x3e>
 804d1d5:	89 d0                	mov    %edx,%eax
 804d1d7:	83 e0 01             	and    $0x1,%eax
 804d1da:	74 06                	je     804d1e2 <hw_irq_ctrl_enable_irq+0x49>
}
 804d1dc:	5d                   	pop    %ebp
		hw_irq_ctrl_raise_im_from_sw(irq);
 804d1dd:	e9 94 ff ff ff       	jmp    804d176 <hw_irq_ctrl_raise_im_from_sw>
}
 804d1e2:	5d                   	pop    %ebp
 804d1e3:	c3                   	ret    

0804d1e4 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
 804d1e4:	f3 0f 1e fb          	endbr32 
	irq_ctrl_timer = NEVER;
 804d1e8:	c7 05 68 52 05 08 ff 	movl   $0xffffffff,0x8055268
 804d1ef:	ff ff ff 
 804d1f2:	c7 05 6c 52 05 08 ff 	movl   $0xffffffff,0x805526c
 804d1f9:	ff ff ff 
	irq_raising_from_hw_now();
 804d1fc:	e9 01 fd ff ff       	jmp    804cf02 <irq_raising_from_hw_now>

0804d201 <posix_exit>:
#include <stdlib.h>
#include <zephyr/sys/util.h>
#include "cmdline.h"

void posix_exit(int exit_code)
{
 804d201:	f3 0f 1e fb          	endbr32 
 804d205:	55                   	push   %ebp
 804d206:	89 e5                	mov    %esp,%ebp
 804d208:	83 ec 08             	sub    $0x8,%esp
 804d20b:	8b 45 08             	mov    0x8(%ebp),%eax
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
 804d20e:	39 05 a4 6a 05 08    	cmp    %eax,0x8056aa4
 804d214:	0f 4d 05 a4 6a 05 08 	cmovge 0x8056aa4,%eax
 804d21b:	a3 a4 6a 05 08       	mov    %eax,0x8056aa4
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
 804d220:	e8 d8 f1 ff ff       	call   804c3fd <posix_soc_clean_up>
	hwm_cleanup();
 804d225:	e8 fb f4 ff ff       	call   804c725 <hwm_cleanup>
	native_cleanup_cmd_line();
 804d22a:	e8 75 08 00 00       	call   804daa4 <native_cleanup_cmd_line>
	exit(max_exit_code);
 804d22f:	83 ec 0c             	sub    $0xc,%esp
 804d232:	ff 35 a4 6a 05 08    	pushl  0x8056aa4
 804d238:	e8 c3 c1 ff ff       	call   8049400 <exit@plt>

0804d23d <main>:
/**
 * This is the actual main for the Linux process,
 * the Zephyr application main is renamed something else thru a define.
 */
int main(int argc, char *argv[])
{
 804d23d:	f3 0f 1e fb          	endbr32 
 804d241:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 804d245:	83 e4 f0             	and    $0xfffffff0,%esp
 804d248:	ff 71 fc             	pushl  -0x4(%ecx)
 804d24b:	55                   	push   %ebp
 804d24c:	89 e5                	mov    %esp,%ebp
 804d24e:	56                   	push   %esi
 804d24f:	53                   	push   %ebx
 804d250:	51                   	push   %ecx
 804d251:	83 ec 18             	sub    $0x18,%esp
 804d254:	8b 71 04             	mov    0x4(%ecx),%esi
 804d257:	8b 19                	mov    (%ecx),%ebx
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
 804d259:	6a 00                	push   $0x0
 804d25b:	e8 70 f1 ff ff       	call   804c3d0 <run_native_tasks>
 804d260:	58                   	pop    %eax
 804d261:	5a                   	pop    %edx

	native_handle_cmd_line(argc, argv);
 804d262:	56                   	push   %esi
 804d263:	53                   	push   %ebx
 804d264:	e8 1a 09 00 00       	call   804db83 <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
 804d269:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804d270:	e8 5b f1 ff ff       	call   804c3d0 <run_native_tasks>
 804d275:	83 c4 10             	add    $0x10,%esp

	hwm_init();
 804d278:	e8 84 f4 ff ff       	call   804c701 <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
 804d27d:	83 ec 0c             	sub    $0xc,%esp
 804d280:	6a 02                	push   $0x2
 804d282:	e8 49 f1 ff ff       	call   804c3d0 <run_native_tasks>
 804d287:	83 c4 10             	add    $0x10,%esp

	posix_boot_cpu();
 804d28a:	e8 8d f0 ff ff       	call   804c31c <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
 804d28f:	83 ec 0c             	sub    $0xc,%esp
 804d292:	6a 03                	push   $0x3
 804d294:	e8 37 f1 ff ff       	call   804c3d0 <run_native_tasks>
 804d299:	83 c4 10             	add    $0x10,%esp

	hwm_main_loop();
 804d29c:	e8 46 f3 ff ff       	call   804c5e7 <hwm_main_loop>

	/* This line should be unreachable */
	return 1; /* LCOV_EXCL_LINE */
}
 804d2a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d2a4:	b8 01 00 00 00       	mov    $0x1,%eax
 804d2a9:	59                   	pop    %ecx
 804d2aa:	5b                   	pop    %ebx
 804d2ab:	5e                   	pop    %esi
 804d2ac:	5d                   	pop    %ebp
 804d2ad:	8d 61 fc             	lea    -0x4(%ecx),%esp
 804d2b0:	c3                   	ret    

0804d2b1 <trace_disable_color>:
 * Indexed 0:stdout, 1:stderr
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
 804d2b1:	f3 0f 1e fb          	endbr32 
	is_a_tty[0] = 0;
 804d2b5:	c7 05 84 52 05 08 00 	movl   $0x0,0x8055284
 804d2bc:	00 00 00 
	is_a_tty[1] = 0;
 804d2bf:	c7 05 88 52 05 08 00 	movl   $0x0,0x8055288
 804d2c6:	00 00 00 
}
 804d2c9:	c3                   	ret    

0804d2ca <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
 804d2ca:	f3 0f 1e fb          	endbr32 
	is_a_tty[0] = -1;
 804d2ce:	c7 05 84 52 05 08 ff 	movl   $0xffffffff,0x8055284
 804d2d5:	ff ff ff 
	is_a_tty[1] = -1;
 804d2d8:	c7 05 88 52 05 08 ff 	movl   $0xffffffff,0x8055288
 804d2df:	ff ff ff 

}
 804d2e2:	c3                   	ret    

0804d2e3 <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
 804d2e3:	f3 0f 1e fb          	endbr32 
	is_a_tty[0] = 1;
 804d2e7:	c7 05 84 52 05 08 01 	movl   $0x1,0x8055284
 804d2ee:	00 00 00 
	is_a_tty[1] = 1;
 804d2f1:	c7 05 88 52 05 08 01 	movl   $0x1,0x8055288
 804d2f8:	00 00 00 
}
 804d2fb:	c3                   	ret    

0804d2fc <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
 804d2fc:	f3 0f 1e fb          	endbr32 
 804d300:	55                   	push   %ebp
 804d301:	89 e5                	mov    %esp,%ebp
 804d303:	83 ec 08             	sub    $0x8,%esp
	if (is_a_tty[0] == -1) {
 804d306:	83 3d 84 52 05 08 ff 	cmpl   $0xffffffff,0x8055284
 804d30d:	75 12                	jne    804d321 <decide_about_color+0x25>
		is_a_tty[0] = isatty(STDOUT_FILENO);
 804d30f:	83 ec 0c             	sub    $0xc,%esp
 804d312:	6a 01                	push   $0x1
 804d314:	e8 67 c2 ff ff       	call   8049580 <isatty@plt>
 804d319:	83 c4 10             	add    $0x10,%esp
 804d31c:	a3 84 52 05 08       	mov    %eax,0x8055284
	}
	if (is_a_tty[1] == -1) {
 804d321:	83 3d 88 52 05 08 ff 	cmpl   $0xffffffff,0x8055288
 804d328:	75 12                	jne    804d33c <decide_about_color+0x40>
		is_a_tty[1] = isatty(STDERR_FILENO);
 804d32a:	83 ec 0c             	sub    $0xc,%esp
 804d32d:	6a 02                	push   $0x2
 804d32f:	e8 4c c2 ff ff       	call   8049580 <isatty@plt>
 804d334:	83 c4 10             	add    $0x10,%esp
 804d337:	a3 88 52 05 08       	mov    %eax,0x8055288
	}
}
 804d33c:	c9                   	leave  
 804d33d:	c3                   	ret    

0804d33e <posix_print_error_and_exit>:
{
 804d33e:	f3 0f 1e fb          	endbr32 
 804d342:	55                   	push   %ebp
 804d343:	89 e5                	mov    %esp,%ebp
 804d345:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804d348:	8d 45 0c             	lea    0xc(%ebp),%eax

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
 804d34b:	50                   	push   %eax
 804d34c:	ff 75 08             	pushl  0x8(%ebp)
 804d34f:	6a 01                	push   $0x1
 804d351:	ff 35 00 63 05 08    	pushl  0x8056300
 804d357:	e8 e4 bf ff ff       	call   8049340 <__vfprintf_chk@plt>
	posix_exit(1);
 804d35c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804d363:	e8 99 fe ff ff       	call   804d201 <posix_exit>
 804d368:	83 c4 10             	add    $0x10,%esp
}
 804d36b:	c9                   	leave  
 804d36c:	c3                   	ret    

0804d36d <posix_print_warning>:
{
 804d36d:	f3 0f 1e fb          	endbr32 
 804d371:	55                   	push   %ebp
 804d372:	89 e5                	mov    %esp,%ebp
 804d374:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804d377:	8d 45 0c             	lea    0xc(%ebp),%eax
 804d37a:	50                   	push   %eax
 804d37b:	ff 75 08             	pushl  0x8(%ebp)
 804d37e:	6a 01                	push   $0x1
 804d380:	ff 35 00 63 05 08    	pushl  0x8056300
 804d386:	e8 b5 bf ff ff       	call   8049340 <__vfprintf_chk@plt>
 804d38b:	83 c4 10             	add    $0x10,%esp
}
 804d38e:	c9                   	leave  
 804d38f:	c3                   	ret    

0804d390 <posix_print_trace>:
{
 804d390:	f3 0f 1e fb          	endbr32 
 804d394:	55                   	push   %ebp
 804d395:	89 e5                	mov    %esp,%ebp
 804d397:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804d39a:	8d 45 0c             	lea    0xc(%ebp),%eax
 804d39d:	50                   	push   %eax
 804d39e:	ff 75 08             	pushl  0x8(%ebp)
 804d3a1:	6a 01                	push   $0x1
 804d3a3:	ff 35 04 63 05 08    	pushl  0x8056304
 804d3a9:	e8 92 bf ff ff       	call   8049340 <__vfprintf_chk@plt>
 804d3ae:	83 c4 10             	add    $0x10,%esp
}
 804d3b1:	c9                   	leave  
 804d3b2:	c3                   	ret    

0804d3b3 <native_add_tracing_options>:

NATIVE_TASK(decide_about_color, PRE_BOOT_2, 0);

void native_add_tracing_options(void)
{
 804d3b3:	f3 0f 1e fb          	endbr32 
 804d3b7:	55                   	push   %ebp
 804d3b8:	89 e5                	mov    %esp,%ebp
 804d3ba:	83 ec 14             	sub    $0x14,%esp
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
 804d3bd:	68 a0 51 05 08       	push   $0x80551a0
 804d3c2:	e8 06 07 00 00       	call   804dacd <native_add_command_line_opts>
 804d3c7:	83 c4 10             	add    $0x10,%esp
}
 804d3ca:	c9                   	leave  
 804d3cb:	c3                   	ret    

0804d3cc <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
 804d3cc:	55                   	push   %ebp
 804d3cd:	89 e5                	mov    %esp,%ebp
 804d3cf:	57                   	push   %edi
 804d3d0:	89 d7                	mov    %edx,%edi
 804d3d2:	56                   	push   %esi
 804d3d3:	be 46 00 00 00       	mov    $0x46,%esi
 804d3d8:	53                   	push   %ebx
 804d3d9:	89 c3                	mov    %eax,%ebx
 804d3db:	83 ec 1c             	sub    $0x1c,%esp

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
 804d3de:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
 804d3e2:	75 09                	jne    804d3ed <cmd_gen_switch_syntax.constprop.0+0x21>
		*buf++ = '[';
 804d3e4:	c6 00 5b             	movb   $0x5b,(%eax)
 804d3e7:	43                   	inc    %ebx
		size--;
 804d3e8:	be 45 00 00 00       	mov    $0x45,%esi
	}

	if (args_s_el->is_switch == true) {
 804d3ed:	80 7f 02 00          	cmpb   $0x0,0x2(%edi)
 804d3f1:	8b 47 04             	mov    0x4(%edi),%eax
 804d3f4:	74 0a                	je     804d400 <cmd_gen_switch_syntax.constprop.0+0x34>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
 804d3f6:	52                   	push   %edx
 804d3f7:	52                   	push   %edx
 804d3f8:	50                   	push   %eax
 804d3f9:	68 56 28 05 08       	push   $0x8052856
 804d3fe:	eb 1b                	jmp    804d41b <cmd_gen_switch_syntax.constprop.0+0x4f>
		ret = snprintf(buf, size, "-%s", args_s_el->option);
	} else {
		if (args_s_el->type != 'l') {
 804d400:	80 7f 0c 6c          	cmpb   $0x6c,0xc(%edi)
 804d404:	8b 57 08             	mov    0x8(%edi),%edx
 804d407:	74 0a                	je     804d413 <cmd_gen_switch_syntax.constprop.0+0x47>
 804d409:	51                   	push   %ecx
 804d40a:	52                   	push   %edx
 804d40b:	50                   	push   %eax
 804d40c:	68 5a 28 05 08       	push   $0x805285a
 804d411:	eb 08                	jmp    804d41b <cmd_gen_switch_syntax.constprop.0+0x4f>
 804d413:	51                   	push   %ecx
 804d414:	52                   	push   %edx
 804d415:	50                   	push   %eax
 804d416:	68 63 28 05 08       	push   $0x8052863
 804d41b:	6a ff                	push   $0xffffffff
 804d41d:	6a 01                	push   $0x1
 804d41f:	56                   	push   %esi
 804d420:	53                   	push   %ebx
 804d421:	e8 ea be ff ff       	call   8049310 <__snprintf_chk@plt>
 804d426:	83 c4 20             	add    $0x20,%esp
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
 804d429:	85 c0                	test   %eax,%eax
 804d42b:	79 1e                	jns    804d44b <cmd_gen_switch_syntax.constprop.0+0x7f>
 804d42d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		posix_print_error_and_exit("Unexpected error in %s %i\n",
 804d430:	50                   	push   %eax
 804d431:	68 07 01 00 00       	push   $0x107
 804d436:	68 6f 28 05 08       	push   $0x805286f
 804d43b:	68 ad 28 05 08       	push   $0x80528ad
 804d440:	e8 f9 fe ff ff       	call   804d33e <posix_print_error_and_exit>
 804d445:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804d448:	83 c4 10             	add    $0x10,%esp
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
 804d44b:	29 c6                	sub    %eax,%esi
 804d44d:	78 20                	js     804d46f <cmd_gen_switch_syntax.constprop.0+0xa3>
		 * If we run out of space we can just stop,
		 * this is not critical
		 */
		return;
	}
	buf += ret;
 804d44f:	01 d8                	add    %ebx,%eax
	size -= ret;

	if (args_s_el->is_mandatory == false) {
 804d451:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
 804d455:	75 08                	jne    804d45f <cmd_gen_switch_syntax.constprop.0+0x93>
 804d457:	51                   	push   %ecx
 804d458:	68 93 1e 05 08       	push   $0x8051e93
 804d45d:	eb 06                	jmp    804d465 <cmd_gen_switch_syntax.constprop.0+0x99>
 804d45f:	52                   	push   %edx
 804d460:	68 a7 1e 05 08       	push   $0x8051ea7
 804d465:	56                   	push   %esi
 804d466:	50                   	push   %eax
 804d467:	e8 04 c0 ff ff       	call   8049470 <snprintf@plt>
 804d46c:	83 c4 10             	add    $0x10,%esp
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
 804d46f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d472:	5b                   	pop    %ebx
 804d473:	5e                   	pop    %esi
 804d474:	5f                   	pop    %edi
 804d475:	5d                   	pop    %ebp
 804d476:	c3                   	ret    

0804d477 <cmd_is_option>:
{
 804d477:	f3 0f 1e fb          	endbr32 
 804d47b:	55                   	push   %ebp
 804d47c:	89 e5                	mov    %esp,%ebp
 804d47e:	57                   	push   %edi
 804d47f:	56                   	push   %esi
 804d480:	53                   	push   %ebx
 804d481:	83 ec 0c             	sub    $0xc,%esp
	if (arg[of] == '-') {
 804d484:	8b 45 08             	mov    0x8(%ebp),%eax
{
 804d487:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804d48a:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if (arg[of] == '-') {
 804d48d:	80 38 2d             	cmpb   $0x2d,(%eax)
	int of = 0;
 804d490:	0f 94 c0             	sete   %al
 804d493:	0f b6 c0             	movzbl %al,%eax
 804d496:	89 c6                	mov    %eax,%esi
	if (arg[of] == '-') {
 804d498:	8b 45 08             	mov    0x8(%ebp),%eax
 804d49b:	80 3c 30 2d          	cmpb   $0x2d,(%eax,%esi,1)
 804d49f:	75 01                	jne    804d4a2 <cmd_is_option+0x2b>
		of++;
 804d4a1:	46                   	inc    %esi
	if (!with_value) {
 804d4a2:	85 db                	test   %ebx,%ebx
 804d4a4:	75 24                	jne    804d4ca <cmd_is_option+0x53>
		if (strcmp(&arg[of], option) != 0) {
 804d4a6:	52                   	push   %edx
 804d4a7:	52                   	push   %edx
 804d4a8:	8b 55 08             	mov    0x8(%ebp),%edx
 804d4ab:	57                   	push   %edi
 804d4ac:	01 f2                	add    %esi,%edx
 804d4ae:	52                   	push   %edx
 804d4af:	e8 7c be ff ff       	call   8049330 <strcmp@plt>
 804d4b4:	83 c4 10             	add    $0x10,%esp
 804d4b7:	85 c0                	test   %eax,%eax
 804d4b9:	75 57                	jne    804d512 <cmd_is_option+0x9b>
	size_t to_match_len = strlen(option);
 804d4bb:	83 c9 ff             	or     $0xffffffff,%ecx
 804d4be:	f2 ae                	repnz scas %es:(%edi),%al
 804d4c0:	89 cf                	mov    %ecx,%edi
 804d4c2:	f7 d7                	not    %edi
			return of + to_match_len;
 804d4c4:	8d 5c 3e ff          	lea    -0x1(%esi,%edi,1),%ebx
 804d4c8:	eb 48                	jmp    804d512 <cmd_is_option+0x9b>
 804d4ca:	89 f3                	mov    %esi,%ebx
 804d4cc:	29 f7                	sub    %esi,%edi
	while (!(arg[of] == 0 && *option == 0)) {
 804d4ce:	8b 45 08             	mov    0x8(%ebp),%eax
 804d4d1:	8a 0c 1f             	mov    (%edi,%ebx,1),%cl
 804d4d4:	8a 04 18             	mov    (%eax,%ebx,1),%al
 804d4d7:	89 c2                	mov    %eax,%edx
 804d4d9:	08 ca                	or     %cl,%dl
 804d4db:	74 1f                	je     804d4fc <cmd_is_option+0x85>
		if (*option == 0) {
 804d4dd:	84 c9                	test   %cl,%cl
 804d4df:	75 14                	jne    804d4f5 <cmd_is_option+0x7e>
			if ((arg[of] == ':') || (arg[of] == '=')) {
 804d4e1:	3c 3a                	cmp    $0x3a,%al
 804d4e3:	74 04                	je     804d4e9 <cmd_is_option+0x72>
 804d4e5:	3c 3d                	cmp    $0x3d,%al
 804d4e7:	75 27                	jne    804d510 <cmd_is_option+0x99>
	if (arg[of] == 0) { /* we need a value to follow */
 804d4e9:	8b 45 08             	mov    0x8(%ebp),%eax
				of++;
 804d4ec:	43                   	inc    %ebx
	if (arg[of] == 0) { /* we need a value to follow */
 804d4ed:	80 3c 18 00          	cmpb   $0x0,(%eax,%ebx,1)
 804d4f1:	75 1f                	jne    804d512 <cmd_is_option+0x9b>
 804d4f3:	eb 07                	jmp    804d4fc <cmd_is_option+0x85>
		if (arg[of] != *option) {
 804d4f5:	38 c8                	cmp    %cl,%al
 804d4f7:	75 17                	jne    804d510 <cmd_is_option+0x99>
		of++;
 804d4f9:	43                   	inc    %ebx
		option++;
 804d4fa:	eb d2                	jmp    804d4ce <cmd_is_option+0x57>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
 804d4fc:	50                   	push   %eax
 804d4fd:	50                   	push   %eax
 804d4fe:	ff 75 08             	pushl  0x8(%ebp)
 804d501:	68 c8 28 05 08       	push   $0x80528c8
 804d506:	e8 33 fe ff ff       	call   804d33e <posix_print_error_and_exit>
 804d50b:	83 c4 10             	add    $0x10,%esp
 804d50e:	eb 02                	jmp    804d512 <cmd_is_option+0x9b>
			return 0;
 804d510:	31 db                	xor    %ebx,%ebx
}
 804d512:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d515:	89 d8                	mov    %ebx,%eax
 804d517:	5b                   	pop    %ebx
 804d518:	5e                   	pop    %esi
 804d519:	5f                   	pop    %edi
 804d51a:	5d                   	pop    %ebp
 804d51b:	c3                   	ret    

0804d51c <cmd_is_help_option>:
{
 804d51c:	f3 0f 1e fb          	endbr32 
 804d520:	55                   	push   %ebp
 804d521:	89 e5                	mov    %esp,%ebp
 804d523:	53                   	push   %ebx
 804d524:	53                   	push   %ebx
 804d525:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (arg[0] == '-') {
 804d528:	80 3b 2d             	cmpb   $0x2d,(%ebx)
 804d52b:	75 0c                	jne    804d539 <cmd_is_help_option+0x1d>
	if (arg[0] == '-') {
 804d52d:	80 7b 01 2d          	cmpb   $0x2d,0x1(%ebx)
 804d531:	74 03                	je     804d536 <cmd_is_help_option+0x1a>
		arg++;
 804d533:	43                   	inc    %ebx
 804d534:	eb 03                	jmp    804d539 <cmd_is_help_option+0x1d>
		arg++;
 804d536:	83 c3 02             	add    $0x2,%ebx
	if ((strcasecmp(arg, "?") == 0) ||
 804d539:	51                   	push   %ecx
 804d53a:	51                   	push   %ecx
 804d53b:	68 22 29 05 08       	push   $0x8052922
 804d540:	53                   	push   %ebx
 804d541:	e8 0a bf ff ff       	call   8049450 <strcasecmp@plt>
 804d546:	83 c4 10             	add    $0x10,%esp
 804d549:	89 c2                	mov    %eax,%edx
		return 1;
 804d54b:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
 804d550:	85 d2                	test   %edx,%edx
 804d552:	74 33                	je     804d587 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "h") == 0) ||
 804d554:	52                   	push   %edx
 804d555:	52                   	push   %edx
 804d556:	68 34 30 05 08       	push   $0x8053034
 804d55b:	53                   	push   %ebx
 804d55c:	e8 ef be ff ff       	call   8049450 <strcasecmp@plt>
 804d561:	83 c4 10             	add    $0x10,%esp
 804d564:	89 c2                	mov    %eax,%edx
		return 1;
 804d566:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
 804d56b:	85 d2                	test   %edx,%edx
 804d56d:	74 18                	je     804d587 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "help") == 0)) {
 804d56f:	50                   	push   %eax
 804d570:	50                   	push   %eax
 804d571:	68 b1 29 05 08       	push   $0x80529b1
 804d576:	53                   	push   %ebx
 804d577:	e8 d4 be ff ff       	call   8049450 <strcasecmp@plt>
 804d57c:	83 c4 10             	add    $0x10,%esp
	    (strcasecmp(arg, "h") == 0) ||
 804d57f:	85 c0                	test   %eax,%eax
 804d581:	0f 94 c0             	sete   %al
 804d584:	0f b6 c0             	movzbl %al,%eax
}
 804d587:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804d58a:	c9                   	leave  
 804d58b:	c3                   	ret    

0804d58c <cmd_read_option_value>:
{
 804d58c:	f3 0f 1e fb          	endbr32 
 804d590:	55                   	push   %ebp
 804d591:	89 e5                	mov    %esp,%ebp
 804d593:	57                   	push   %edi
 804d594:	56                   	push   %esi
 804d595:	53                   	push   %ebx
 804d596:	83 ec 1c             	sub    $0x1c,%esp
 804d599:	8b 45 10             	mov    0x10(%ebp),%eax
 804d59c:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804d59f:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
 804d5a6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804d5a9:	31 d2                	xor    %edx,%edx
 804d5ab:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804d5ae:	8b 75 14             	mov    0x14(%ebp),%esi
	char *endptr = NULL;
 804d5b1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	switch (type) {
 804d5b8:	3c 64                	cmp    $0x64,%al
 804d5ba:	0f 84 19 01 00 00    	je     804d6d9 <cmd_read_option_value+0x14d>
 804d5c0:	7f 26                	jg     804d5e8 <cmd_read_option_value+0x5c>
 804d5c2:	3c 55                	cmp    $0x55,%al
 804d5c4:	0f 84 ef 00 00 00    	je     804d6b9 <cmd_read_option_value+0x12d>
 804d5ca:	3c 62                	cmp    $0x62,%al
 804d5cc:	74 44                	je     804d612 <cmd_read_option_value+0x86>
 804d5ce:	3c 49                	cmp    $0x49,%al
 804d5d0:	0f 85 16 01 00 00    	jne    804d6ec <cmd_read_option_value+0x160>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
 804d5d6:	50                   	push   %eax
 804d5d7:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804d5da:	6a 00                	push   $0x0
 804d5dc:	50                   	push   %eax
 804d5dd:	53                   	push   %ebx
 804d5de:	e8 fd bd ff ff       	call   80493e0 <strtoll@plt>
 804d5e3:	e9 e7 00 00 00       	jmp    804d6cf <cmd_read_option_value+0x143>
	switch (type) {
 804d5e8:	3c 73                	cmp    $0x73,%al
 804d5ea:	0f 84 a7 00 00 00    	je     804d697 <cmd_read_option_value+0x10b>
 804d5f0:	3c 75                	cmp    $0x75,%al
 804d5f2:	0f 84 b2 00 00 00    	je     804d6aa <cmd_read_option_value+0x11e>
 804d5f8:	3c 69                	cmp    $0x69,%al
 804d5fa:	0f 85 ec 00 00 00    	jne    804d6ec <cmd_read_option_value+0x160>
		*(int32_t *)dest = strtol(str, &endptr, 0);
 804d600:	50                   	push   %eax
 804d601:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804d604:	6a 00                	push   $0x0
 804d606:	50                   	push   %eax
 804d607:	53                   	push   %ebx
 804d608:	e8 83 bf ff ff       	call   8049590 <strtol@plt>
 804d60d:	e9 b6 00 00 00       	jmp    804d6c8 <cmd_read_option_value+0x13c>
		if (strcasecmp(str, "false") == 0) {
 804d612:	50                   	push   %eax
 804d613:	50                   	push   %eax
 804d614:	68 94 13 05 08       	push   $0x8051394
 804d619:	53                   	push   %ebx
 804d61a:	e8 31 be ff ff       	call   8049450 <strcasecmp@plt>
 804d61f:	83 c4 10             	add    $0x10,%esp
 804d622:	85 c0                	test   %eax,%eax
 804d624:	75 08                	jne    804d62e <cmd_read_option_value+0xa2>
			*(bool *)dest = false;
 804d626:	c6 07 00             	movb   $0x0,(%edi)
			endptr = (char *)str + 5;
 804d629:	8d 43 05             	lea    0x5(%ebx),%eax
 804d62c:	eb 1a                	jmp    804d648 <cmd_read_option_value+0xbc>
		} else if (strcmp(str, "0") == 0) {
 804d62e:	50                   	push   %eax
 804d62f:	50                   	push   %eax
 804d630:	68 2e 18 05 08       	push   $0x805182e
 804d635:	53                   	push   %ebx
 804d636:	e8 f5 bc ff ff       	call   8049330 <strcmp@plt>
 804d63b:	83 c4 10             	add    $0x10,%esp
 804d63e:	85 c0                	test   %eax,%eax
 804d640:	75 0e                	jne    804d650 <cmd_read_option_value+0xc4>
			*(bool *)dest = false;
 804d642:	c6 07 00             	movb   $0x0,(%edi)
			endptr = (char *)str + 1;
 804d645:	8d 43 01             	lea    0x1(%ebx),%eax
 804d648:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (!error && endptr && *endptr != 0) {
 804d64b:	e9 af 00 00 00       	jmp    804d6ff <cmd_read_option_value+0x173>
		} else if (strcasecmp(str, "true") == 0) {
 804d650:	51                   	push   %ecx
 804d651:	51                   	push   %ecx
 804d652:	68 b0 13 05 08       	push   $0x80513b0
 804d657:	53                   	push   %ebx
 804d658:	e8 f3 bd ff ff       	call   8049450 <strcasecmp@plt>
 804d65d:	83 c4 10             	add    $0x10,%esp
 804d660:	85 c0                	test   %eax,%eax
 804d662:	75 08                	jne    804d66c <cmd_read_option_value+0xe0>
			*(bool *)dest = true;
 804d664:	c6 07 01             	movb   $0x1,(%edi)
			endptr = (char *)str + 4;
 804d667:	8d 43 04             	lea    0x4(%ebx),%eax
 804d66a:	eb dc                	jmp    804d648 <cmd_read_option_value+0xbc>
		} else if (strcmp(str, "1") == 0) {
 804d66c:	52                   	push   %edx
 804d66d:	52                   	push   %edx
 804d66e:	68 c0 14 05 08       	push   $0x80514c0
 804d673:	53                   	push   %ebx
 804d674:	e8 b7 bc ff ff       	call   8049330 <strcmp@plt>
 804d679:	83 c4 10             	add    $0x10,%esp
 804d67c:	85 c0                	test   %eax,%eax
 804d67e:	74 12                	je     804d692 <cmd_read_option_value+0x106>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
 804d680:	50                   	push   %eax
 804d681:	53                   	push   %ebx
 804d682:	56                   	push   %esi
 804d683:	68 24 29 05 08       	push   $0x8052924
 804d688:	e8 b1 fc ff ff       	call   804d33e <posix_print_error_and_exit>
 804d68d:	83 c4 10             	add    $0x10,%esp
 804d690:	eb 7d                	jmp    804d70f <cmd_read_option_value+0x183>
			*(bool *)dest = true;
 804d692:	c6 07 01             	movb   $0x1,(%edi)
			endptr = (char *)str + 1;
 804d695:	eb ae                	jmp    804d645 <cmd_read_option_value+0xb9>
		*(char **)dest = (char *)str;
 804d697:	89 1f                	mov    %ebx,(%edi)
		endptr = (char *)str + strlen(str);
 804d699:	31 c0                	xor    %eax,%eax
 804d69b:	83 c9 ff             	or     $0xffffffff,%ecx
 804d69e:	89 df                	mov    %ebx,%edi
 804d6a0:	f2 ae                	repnz scas %es:(%edi),%al
 804d6a2:	f7 d1                	not    %ecx
 804d6a4:	8d 44 0b ff          	lea    -0x1(%ebx,%ecx,1),%eax
 804d6a8:	eb 9e                	jmp    804d648 <cmd_read_option_value+0xbc>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
 804d6aa:	50                   	push   %eax
 804d6ab:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804d6ae:	6a 00                	push   $0x0
 804d6b0:	50                   	push   %eax
 804d6b1:	53                   	push   %ebx
 804d6b2:	e8 69 bd ff ff       	call   8049420 <strtoul@plt>
 804d6b7:	eb 0f                	jmp    804d6c8 <cmd_read_option_value+0x13c>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
 804d6b9:	50                   	push   %eax
 804d6ba:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804d6bd:	6a 00                	push   $0x0
 804d6bf:	50                   	push   %eax
 804d6c0:	53                   	push   %ebx
 804d6c1:	e8 ea bd ff ff       	call   80494b0 <strtoull@plt>
 804d6c6:	eb 07                	jmp    804d6cf <cmd_read_option_value+0x143>
		*(int32_t *)dest = strtol(str, &endptr, 0);
 804d6c8:	89 07                	mov    %eax,(%edi)
 804d6ca:	83 c4 10             	add    $0x10,%esp
 804d6cd:	eb 30                	jmp    804d6ff <cmd_read_option_value+0x173>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
 804d6cf:	89 07                	mov    %eax,(%edi)
 804d6d1:	83 c4 10             	add    $0x10,%esp
 804d6d4:	89 57 04             	mov    %edx,0x4(%edi)
	if (!error && endptr && *endptr != 0) {
 804d6d7:	eb 26                	jmp    804d6ff <cmd_read_option_value+0x173>
		*(double *)dest = strtod(str, &endptr);
 804d6d9:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804d6dc:	51                   	push   %ecx
 804d6dd:	51                   	push   %ecx
 804d6de:	50                   	push   %eax
 804d6df:	53                   	push   %ebx
 804d6e0:	e8 db bd ff ff       	call   80494c0 <strtod@plt>
 804d6e5:	83 c4 10             	add    $0x10,%esp
 804d6e8:	dd 1f                	fstpl  (%edi)
	if (!error && endptr && *endptr != 0) {
 804d6ea:	eb 13                	jmp    804d6ff <cmd_read_option_value+0x173>
	switch (type) {
 804d6ec:	0f be c0             	movsbl %al,%eax
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
 804d6ef:	52                   	push   %edx
 804d6f0:	52                   	push   %edx
 804d6f1:	50                   	push   %eax
 804d6f2:	68 66 29 05 08       	push   $0x8052966
 804d6f7:	e8 42 fc ff ff       	call   804d33e <posix_print_error_and_exit>
 804d6fc:	83 c4 10             	add    $0x10,%esp
	if (!error && endptr && *endptr != 0) {
 804d6ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804d702:	85 c0                	test   %eax,%eax
 804d704:	74 09                	je     804d70f <cmd_read_option_value+0x183>
 804d706:	80 38 00             	cmpb   $0x0,(%eax)
 804d709:	0f 85 71 ff ff ff    	jne    804d680 <cmd_read_option_value+0xf4>
}
 804d70f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804d712:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804d719:	74 05                	je     804d720 <cmd_read_option_value+0x194>
 804d71b:	e8 a0 bc ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804d720:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d723:	5b                   	pop    %ebx
 804d724:	5e                   	pop    %esi
 804d725:	5f                   	pop    %edi
 804d726:	5d                   	pop    %ebp
 804d727:	c3                   	ret    

0804d728 <cmd_args_set_defaults>:
{
 804d728:	f3 0f 1e fb          	endbr32 
 804d72c:	55                   	push   %ebp
 804d72d:	89 e5                	mov    %esp,%ebp
 804d72f:	53                   	push   %ebx
 804d730:	51                   	push   %ecx
 804d731:	8b 45 08             	mov    0x8(%ebp),%eax
 804d734:	8d 58 04             	lea    0x4(%eax),%ebx
	while (args_struct[count].option != NULL) {
 804d737:	83 3b 00             	cmpl   $0x0,(%ebx)
 804d73a:	0f 84 8c 00 00 00    	je     804d7cc <cmd_args_set_defaults+0xa4>
		if (args_struct[count].dest == NULL) {
 804d740:	8b 53 0c             	mov    0xc(%ebx),%edx
 804d743:	85 d2                	test   %edx,%edx
 804d745:	74 7d                	je     804d7c4 <cmd_args_set_defaults+0x9c>
		switch (args_struct[count].type) {
 804d747:	0f be 43 08          	movsbl 0x8(%ebx),%eax
 804d74b:	3c 64                	cmp    $0x64,%al
 804d74d:	74 5b                	je     804d7aa <cmd_args_set_defaults+0x82>
 804d74f:	7f 26                	jg     804d777 <cmd_args_set_defaults+0x4f>
 804d751:	3c 55                	cmp    $0x55,%al
 804d753:	74 46                	je     804d79b <cmd_args_set_defaults+0x73>
 804d755:	7f 17                	jg     804d76e <cmd_args_set_defaults+0x46>
 804d757:	84 c0                	test   %al,%al
 804d759:	74 69                	je     804d7c4 <cmd_args_set_defaults+0x9c>
 804d75b:	3c 49                	cmp    $0x49,%al
 804d75d:	75 55                	jne    804d7b4 <cmd_args_set_defaults+0x8c>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
 804d75f:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
 804d765:	c7 42 04 ff ff ff 7f 	movl   $0x7fffffff,0x4(%edx)
			break;
 804d76c:	eb 56                	jmp    804d7c4 <cmd_args_set_defaults+0x9c>
		switch (args_struct[count].type) {
 804d76e:	3c 62                	cmp    $0x62,%al
 804d770:	75 42                	jne    804d7b4 <cmd_args_set_defaults+0x8c>
			*(bool *)args_struct[count].dest = false;
 804d772:	c6 02 00             	movb   $0x0,(%edx)
			break;
 804d775:	eb 4d                	jmp    804d7c4 <cmd_args_set_defaults+0x9c>
		switch (args_struct[count].type) {
 804d777:	3c 73                	cmp    $0x73,%al
 804d779:	74 10                	je     804d78b <cmd_args_set_defaults+0x63>
 804d77b:	3c 75                	cmp    $0x75,%al
 804d77d:	74 14                	je     804d793 <cmd_args_set_defaults+0x6b>
 804d77f:	3c 69                	cmp    $0x69,%al
 804d781:	75 31                	jne    804d7b4 <cmd_args_set_defaults+0x8c>
			*(int32_t *)args_struct[count].dest = INT32_MAX;
 804d783:	c7 02 ff ff ff 7f    	movl   $0x7fffffff,(%edx)
			break;
 804d789:	eb 39                	jmp    804d7c4 <cmd_args_set_defaults+0x9c>
			*(char **)args_struct[count].dest = NULL;
 804d78b:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			break;
 804d791:	eb 31                	jmp    804d7c4 <cmd_args_set_defaults+0x9c>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
 804d793:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
			break;
 804d799:	eb 29                	jmp    804d7c4 <cmd_args_set_defaults+0x9c>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
 804d79b:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
 804d7a1:	c7 42 04 ff ff ff ff 	movl   $0xffffffff,0x4(%edx)
			break;
 804d7a8:	eb 1a                	jmp    804d7c4 <cmd_args_set_defaults+0x9c>
			*(double *)args_struct[count].dest = (double)NAN;
 804d7aa:	d9 05 f4 12 05 08    	flds   0x80512f4
 804d7b0:	dd 1a                	fstpl  (%edx)
			break;
 804d7b2:	eb 10                	jmp    804d7c4 <cmd_args_set_defaults+0x9c>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
 804d7b4:	52                   	push   %edx
 804d7b5:	52                   	push   %edx
 804d7b6:	50                   	push   %eax
 804d7b7:	68 66 29 05 08       	push   $0x8052966
 804d7bc:	e8 7d fb ff ff       	call   804d33e <posix_print_error_and_exit>
 804d7c1:	83 c4 10             	add    $0x10,%esp
		count++;
 804d7c4:	83 c3 1c             	add    $0x1c,%ebx
 804d7c7:	e9 6b ff ff ff       	jmp    804d737 <cmd_args_set_defaults+0xf>
}
 804d7cc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804d7cf:	c9                   	leave  
 804d7d0:	c3                   	ret    

0804d7d1 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
 804d7d1:	f3 0f 1e fb          	endbr32 
 804d7d5:	55                   	push   %ebp
 804d7d6:	89 e5                	mov    %esp,%ebp
 804d7d8:	57                   	push   %edi
 804d7d9:	56                   	push   %esi
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
 804d7da:	be 19 00 00 00       	mov    $0x19,%esi
{
 804d7df:	53                   	push   %ebx
 804d7e0:	83 ec 5c             	sub    $0x5c,%esp
 804d7e3:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804d7e6:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804d7ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804d7ef:	31 c0                	xor    %eax,%eax
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
 804d7f1:	68 8b 29 05 08       	push   $0x805298b
 804d7f6:	68 6d 1e 05 08       	push   $0x8051e6d
 804d7fb:	6a 01                	push   $0x1
 804d7fd:	ff 35 04 63 05 08    	pushl  0x8056304
 804d803:	e8 28 bd ff ff       	call   8049530 <__fprintf_chk@plt>
 804d808:	83 c4 10             	add    $0x10,%esp

	fprintf(stdout, "%s ", _HELP_SWITCH);

	while (args_struct[count].option != NULL) {
 804d80b:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
 804d80f:	74 67                	je     804d878 <cmd_print_switches_help+0xa7>
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804d811:	8d 45 9e             	lea    -0x62(%ebp),%eax
 804d814:	89 da                	mov    %ebx,%edx
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
 804d816:	8d 7d 9e             	lea    -0x62(%ebp),%edi
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804d819:	e8 ae fb ff ff       	call   804d3cc <cmd_gen_switch_syntax.constprop.0>
		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
 804d81e:	31 c0                	xor    %eax,%eax
 804d820:	83 c9 ff             	or     $0xffffffff,%ecx
 804d823:	f2 ae                	repnz scas %es:(%edi),%al
 804d825:	f7 d1                	not    %ecx
 804d827:	8d 44 0e ff          	lea    -0x1(%esi,%ecx,1),%eax
 804d82b:	83 f8 64             	cmp    $0x64,%eax
 804d82e:	76 18                	jbe    804d848 <cmd_print_switches_help+0x77>
 804d830:	52                   	push   %edx
			fprintf(stdout, "\n");
			printed_in_line = 0;
 804d831:	31 f6                	xor    %esi,%esi
 804d833:	68 37 30 05 08       	push   $0x8053037
 804d838:	6a 01                	push   $0x1
 804d83a:	ff 35 04 63 05 08    	pushl  0x8056304
 804d840:	e8 eb bc ff ff       	call   8049530 <__fprintf_chk@plt>
 804d845:	83 c4 10             	add    $0x10,%esp
 804d848:	8d 45 9e             	lea    -0x62(%ebp),%eax
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
 804d84b:	8d 7d 9e             	lea    -0x62(%ebp),%edi
 804d84e:	83 c3 1c             	add    $0x1c,%ebx
 804d851:	50                   	push   %eax
 804d852:	68 57 28 05 08       	push   $0x8052857
 804d857:	6a 01                	push   $0x1
 804d859:	ff 35 04 63 05 08    	pushl  0x8056304
 804d85f:	e8 cc bc ff ff       	call   8049530 <__fprintf_chk@plt>
 804d864:	31 c0                	xor    %eax,%eax
 804d866:	83 c9 ff             	or     $0xffffffff,%ecx
 804d869:	83 c4 10             	add    $0x10,%esp
 804d86c:	f2 ae                	repnz scas %es:(%edi),%al
 804d86e:	89 c8                	mov    %ecx,%eax
 804d870:	f7 d0                	not    %eax
 804d872:	8d 74 06 ff          	lea    -0x1(%esi,%eax,1),%esi
		count++;
 804d876:	eb 93                	jmp    804d80b <cmd_print_switches_help+0x3a>
 804d878:	50                   	push   %eax
 804d879:	68 37 30 05 08       	push   $0x8053037
 804d87e:	6a 01                	push   $0x1
 804d880:	ff 35 04 63 05 08    	pushl  0x8056304
 804d886:	e8 a5 bc ff ff       	call   8049530 <__fprintf_chk@plt>
 804d88b:	83 c4 10             	add    $0x10,%esp
	}

	fprintf(stdout, "\n");
}
 804d88e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804d891:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804d898:	74 05                	je     804d89f <cmd_print_switches_help+0xce>
 804d89a:	e8 21 bb ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804d89f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d8a2:	5b                   	pop    %ebx
 804d8a3:	5e                   	pop    %esi
 804d8a4:	5f                   	pop    %edi
 804d8a5:	5d                   	pop    %ebp
 804d8a6:	c3                   	ret    

0804d8a7 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
 804d8a7:	f3 0f 1e fb          	endbr32 
 804d8ab:	55                   	push   %ebp
 804d8ac:	89 e5                	mov    %esp,%ebp
 804d8ae:	57                   	push   %edi
 804d8af:	56                   	push   %esi
 804d8b0:	53                   	push   %ebx
 804d8b1:	83 ec 78             	sub    $0x78,%esp
 804d8b4:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804d8b7:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804d8bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804d8c0:	31 c0                	xor    %eax,%eax
	int ret;
	int count = 0;
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
 804d8c2:	53                   	push   %ebx
 804d8c3:	e8 09 ff ff ff       	call   804d7d1 <cmd_print_switches_help>
 804d8c8:	5a                   	pop    %edx
 804d8c9:	59                   	pop    %ecx
 804d8ca:	68 a4 29 05 08       	push   $0x80529a4
 804d8cf:	68 8b 29 05 08       	push   $0x805298b
 804d8d4:	6a 1d                	push   $0x1d
 804d8d6:	68 b6 29 05 08       	push   $0x80529b6
 804d8db:	6a 01                	push   $0x1
 804d8dd:	ff 35 04 63 05 08    	pushl  0x8056304
 804d8e3:	e8 48 bc ff ff       	call   8049530 <__fprintf_chk@plt>
 804d8e8:	83 c4 20             	add    $0x20,%esp

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
 804d8eb:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
 804d8ef:	0f 84 ab 00 00 00    	je     804d9a0 <cmd_print_long_help+0xf9>
		int printed_right;
		char *toprint;
		int total_to_print;

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804d8f5:	8d 75 9e             	lea    -0x62(%ebp),%esi
 804d8f8:	89 da                	mov    %ebx,%edx
 804d8fa:	89 f0                	mov    %esi,%eax
 804d8fc:	e8 cb fa ff ff       	call   804d3cc <cmd_gen_switch_syntax.constprop.0>
 804d901:	83 ec 0c             	sub    $0xc,%esp
 804d904:	56                   	push   %esi
 804d905:	6a 1d                	push   $0x1d
 804d907:	68 c1 29 05 08       	push   $0x80529c1
 804d90c:	6a 01                	push   $0x1
 804d90e:	ff 35 04 63 05 08    	pushl  0x8056304
 804d914:	e8 17 bc ff ff       	call   8049530 <__fprintf_chk@plt>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
 804d919:	8b 73 18             	mov    0x18(%ebx),%esi
		total_to_print = strlen(toprint);
 804d91c:	83 c9 ff             	or     $0xffffffff,%ecx
 804d91f:	83 c4 14             	add    $0x14,%esp
 804d922:	89 c2                	mov    %eax,%edx
 804d924:	31 c0                	xor    %eax,%eax
 804d926:	89 f7                	mov    %esi,%edi
 804d928:	f2 ae                	repnz scas %es:(%edi),%al
 804d92a:	56                   	push   %esi
 804d92b:	f7 d1                	not    %ecx
 804d92d:	8d 41 ff             	lea    -0x1(%ecx),%eax
 804d930:	89 45 94             	mov    %eax,-0x6c(%ebp)
		ret = fprintf(stdout, "%.*s\n",
 804d933:	b8 64 00 00 00       	mov    $0x64,%eax
 804d938:	29 d0                	sub    %edx,%eax
 804d93a:	50                   	push   %eax
 804d93b:	68 c8 29 05 08       	push   $0x80529c8
 804d940:	6a 01                	push   $0x1
 804d942:	ff 35 04 63 05 08    	pushl  0x8056304
 804d948:	e8 e3 bb ff ff       	call   8049530 <__fprintf_chk@plt>
 804d94d:	83 c4 20             	add    $0x20,%esp
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
 804d950:	8d 78 ff             	lea    -0x1(%eax),%edi

		while (printed_right < total_to_print) {
 804d953:	3b 7d 94             	cmp    -0x6c(%ebp),%edi
 804d956:	7d 40                	jge    804d998 <cmd_print_long_help+0xf1>
 804d958:	83 ec 0c             	sub    $0xc,%esp
 804d95b:	68 38 30 05 08       	push   $0x8053038
 804d960:	6a 1e                	push   $0x1e
 804d962:	68 ce 29 05 08       	push   $0x80529ce
 804d967:	6a 01                	push   $0x1
 804d969:	ff 35 04 63 05 08    	pushl  0x8056304
 804d96f:	e8 bc bb ff ff       	call   8049530 <__fprintf_chk@plt>
 804d974:	83 c4 14             	add    $0x14,%esp
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
 804d977:	8d 04 3e             	lea    (%esi,%edi,1),%eax
 804d97a:	50                   	push   %eax
 804d97b:	6a 46                	push   $0x46
 804d97d:	68 c8 29 05 08       	push   $0x80529c8
 804d982:	6a 01                	push   $0x1
 804d984:	ff 35 04 63 05 08    	pushl  0x8056304
 804d98a:	e8 a1 bb ff ff       	call   8049530 <__fprintf_chk@plt>
 804d98f:	83 c4 20             	add    $0x20,%esp
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
 804d992:	8d 7c 07 ff          	lea    -0x1(%edi,%eax,1),%edi
 804d996:	eb bb                	jmp    804d953 <cmd_print_long_help+0xac>
		}
		count++;
 804d998:	83 c3 1c             	add    $0x1c,%ebx
 804d99b:	e9 4b ff ff ff       	jmp    804d8eb <cmd_print_long_help+0x44>
 804d9a0:	50                   	push   %eax
 804d9a1:	68 37 30 05 08       	push   $0x8053037
 804d9a6:	6a 01                	push   $0x1
 804d9a8:	ff 35 04 63 05 08    	pushl  0x8056304
 804d9ae:	e8 7d bb ff ff       	call   8049530 <__fprintf_chk@plt>
 804d9b3:	83 c4 0c             	add    $0xc,%esp
 804d9b6:	68 d2 29 05 08       	push   $0x80529d2
 804d9bb:	6a 01                	push   $0x1
 804d9bd:	ff 35 04 63 05 08    	pushl  0x8056304
 804d9c3:	e8 68 bb ff ff       	call   8049530 <__fprintf_chk@plt>
 804d9c8:	83 c4 10             	add    $0x10,%esp
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
 804d9cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804d9ce:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804d9d5:	74 05                	je     804d9dc <cmd_print_long_help+0x135>
 804d9d7:	e8 e4 b9 ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804d9dc:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d9df:	5b                   	pop    %ebx
 804d9e0:	5e                   	pop    %esi
 804d9e1:	5f                   	pop    %edi
 804d9e2:	5d                   	pop    %ebp
 804d9e3:	c3                   	ret    

0804d9e4 <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
 804d9e4:	f3 0f 1e fb          	endbr32 
 804d9e8:	55                   	push   %ebp
 804d9e9:	89 e5                	mov    %esp,%ebp
 804d9eb:	57                   	push   %edi
 804d9ec:	56                   	push   %esi
 804d9ed:	53                   	push   %ebx
 804d9ee:	83 ec 18             	sub    $0x18,%esp
 804d9f1:	8b 7d 08             	mov    0x8(%ebp),%edi
 804d9f4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
 804d9f7:	57                   	push   %edi
 804d9f8:	e8 1f fb ff ff       	call   804d51c <cmd_is_help_option>
 804d9fd:	83 c4 10             	add    $0x10,%esp
 804da00:	85 c0                	test   %eax,%eax
 804da02:	74 22                	je     804da26 <cmd_parse_one_arg+0x42>
		cmd_print_long_help(args_struct);
 804da04:	83 ec 0c             	sub    $0xc,%esp
 804da07:	53                   	push   %ebx
 804da08:	e8 9a fe ff ff       	call   804d8a7 <cmd_print_long_help>
		posix_exit(0);
 804da0d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804da14:	e8 e8 f7 ff ff       	call   804d201 <posix_exit>
 804da19:	83 c4 10             	add    $0x10,%esp
 804da1c:	eb 08                	jmp    804da26 <cmd_parse_one_arg+0x42>
	}

	while (args_struct[count].option != NULL) {
		if (args_struct[count].manual) {
 804da1e:	80 3b 00             	cmpb   $0x0,(%ebx)
 804da21:	74 0c                	je     804da2f <cmd_parse_one_arg+0x4b>
 804da23:	83 c3 1c             	add    $0x1c,%ebx
	while (args_struct[count].option != NULL) {
 804da26:	8b 53 04             	mov    0x4(%ebx),%edx
 804da29:	85 d2                	test   %edx,%edx
 804da2b:	75 f1                	jne    804da1e <cmd_parse_one_arg+0x3a>
 804da2d:	eb 6b                	jmp    804da9a <cmd_parse_one_arg+0xb6>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
 804da2f:	51                   	push   %ecx
				    !args_struct[count].is_switch);
 804da30:	8a 43 02             	mov    0x2(%ebx),%al
 804da33:	83 f0 01             	xor    $0x1,%eax
		ret = cmd_is_option(argv, args_struct[count].option,
 804da36:	0f b6 c0             	movzbl %al,%eax
 804da39:	50                   	push   %eax
 804da3a:	52                   	push   %edx
 804da3b:	57                   	push   %edi
 804da3c:	e8 36 fa ff ff       	call   804d477 <cmd_is_option>
 804da41:	83 c4 10             	add    $0x10,%esp
 804da44:	89 c6                	mov    %eax,%esi
		if (ret) {
 804da46:	85 c0                	test   %eax,%eax
 804da48:	74 d9                	je     804da23 <cmd_parse_one_arg+0x3f>
	if (arg_element->dest != NULL) {
 804da4a:	8b 53 10             	mov    0x10(%ebx),%edx
 804da4d:	85 d2                	test   %edx,%edx
 804da4f:	74 33                	je     804da84 <cmd_parse_one_arg+0xa0>
		if (arg_element->is_switch) {
 804da51:	80 7b 02 00          	cmpb   $0x0,0x2(%ebx)
 804da55:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
 804da59:	74 18                	je     804da73 <cmd_parse_one_arg+0x8f>
			if (arg_element->type == 'b') {
 804da5b:	3c 62                	cmp    $0x62,%al
 804da5d:	75 05                	jne    804da64 <cmd_parse_one_arg+0x80>
				*(bool *)arg_element->dest = true;
 804da5f:	c6 02 01             	movb   $0x1,(%edx)
 804da62:	eb 20                	jmp    804da84 <cmd_parse_one_arg+0xa0>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
 804da64:	83 ec 0c             	sub    $0xc,%esp
 804da67:	68 22 2a 05 08       	push   $0x8052a22
 804da6c:	e8 cd f8 ff ff       	call   804d33e <posix_print_error_and_exit>
 804da71:	eb 0e                	jmp    804da81 <cmd_parse_one_arg+0x9d>
			cmd_read_option_value(&argv[offset],
 804da73:	ff 73 04             	pushl  0x4(%ebx)
 804da76:	50                   	push   %eax
 804da77:	8d 04 37             	lea    (%edi,%esi,1),%eax
 804da7a:	52                   	push   %edx
 804da7b:	50                   	push   %eax
 804da7c:	e8 0b fb ff ff       	call   804d58c <cmd_read_option_value>
 804da81:	83 c4 10             	add    $0x10,%esp
	if (arg_element->call_when_found) {
 804da84:	8b 53 14             	mov    0x14(%ebx),%edx
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
 804da87:	b0 01                	mov    $0x1,%al
	if (arg_element->call_when_found) {
 804da89:	85 d2                	test   %edx,%edx
 804da8b:	74 0f                	je     804da9c <cmd_parse_one_arg+0xb8>
		arg_element->call_when_found(argv, offset);
 804da8d:	50                   	push   %eax
 804da8e:	50                   	push   %eax
 804da8f:	56                   	push   %esi
 804da90:	57                   	push   %edi
 804da91:	ff d2                	call   *%edx
			return true;
 804da93:	b0 01                	mov    $0x1,%al
		arg_element->call_when_found(argv, offset);
 804da95:	83 c4 10             	add    $0x10,%esp
 804da98:	eb 02                	jmp    804da9c <cmd_parse_one_arg+0xb8>
		}
		count++;
	}
	return false;
 804da9a:	31 c0                	xor    %eax,%eax
}
 804da9c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804da9f:	5b                   	pop    %ebx
 804daa0:	5e                   	pop    %esi
 804daa1:	5f                   	pop    %edi
 804daa2:	5d                   	pop    %ebp
 804daa3:	c3                   	ret    

0804daa4 <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
 804daa4:	f3 0f 1e fb          	endbr32 
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
 804daa8:	a1 b0 6a 05 08       	mov    0x8056ab0,%eax
 804daad:	85 c0                	test   %eax,%eax
 804daaf:	74 1b                	je     804dacc <native_cleanup_cmd_line+0x28>
{
 804dab1:	55                   	push   %ebp
 804dab2:	89 e5                	mov    %esp,%ebp
 804dab4:	83 ec 14             	sub    $0x14,%esp
		free(args_struct);
 804dab7:	50                   	push   %eax
 804dab8:	e8 a3 b8 ff ff       	call   8049360 <free@plt>
 804dabd:	83 c4 10             	add    $0x10,%esp
		args_struct = NULL;
 804dac0:	c7 05 b0 6a 05 08 00 	movl   $0x0,0x8056ab0
 804dac7:	00 00 00 
	}
}
 804daca:	c9                   	leave  
 804dacb:	c3                   	ret    
 804dacc:	c3                   	ret    

0804dacd <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
 804dacd:	f3 0f 1e fb          	endbr32 
 804dad1:	55                   	push   %ebp
 804dad2:	89 e5                	mov    %esp,%ebp
 804dad4:	57                   	push   %edi
	int count = 0;
 804dad5:	31 ff                	xor    %edi,%edi
{
 804dad7:	56                   	push   %esi
 804dad8:	53                   	push   %ebx
 804dad9:	83 ec 1c             	sub    $0x1c,%esp
 804dadc:	8b 75 08             	mov    0x8(%ebp),%esi

	while (args[count].option != NULL) {
 804dadf:	6b c7 1c             	imul   $0x1c,%edi,%eax
 804dae2:	89 7d e4             	mov    %edi,-0x1c(%ebp)
 804dae5:	47                   	inc    %edi
 804dae6:	83 7c 06 04 00       	cmpl   $0x0,0x4(%esi,%eax,1)
 804daeb:	75 f2                	jne    804dadf <native_add_command_line_opts+0x12>
		count++;
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
 804daed:	8b 15 ac 6a 05 08    	mov    0x8056aac,%edx
 804daf3:	a1 a8 6a 05 08       	mov    0x8056aa8,%eax
 804daf8:	01 fa                	add    %edi,%edx
 804dafa:	39 c2                	cmp    %eax,%edx
 804dafc:	7c 43                	jl     804db41 <native_add_command_line_opts+0x74>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
 804dafe:	83 ff 14             	cmp    $0x14,%edi
 804db01:	ba 14 00 00 00       	mov    $0x14,%edx
 804db06:	0f 4d d7             	cmovge %edi,%edx
 804db09:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
		struct args_struct_t *new_args_struct = realloc(args_struct,
 804db0c:	50                   	push   %eax
 804db0d:	50                   	push   %eax
 804db0e:	6b c3 1c             	imul   $0x1c,%ebx,%eax
 804db11:	50                   	push   %eax
 804db12:	ff 35 b0 6a 05 08    	pushl  0x8056ab0
 804db18:	e8 d3 b8 ff ff       	call   80493f0 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
 804db1d:	89 1d a8 6a 05 08    	mov    %ebx,0x8056aa8
		struct args_struct_t *new_args_struct = realloc(args_struct,
 804db23:	83 c4 10             	add    $0x10,%esp
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
 804db26:	85 c0                	test   %eax,%eax
 804db28:	75 12                	jne    804db3c <native_add_command_line_opts+0x6f>
			posix_print_error_and_exit("Could not allocate memory");
 804db2a:	83 ec 0c             	sub    $0xc,%esp
 804db2d:	68 6d 2a 05 08       	push   $0x8052a6d
 804db32:	e8 07 f8 ff ff       	call   804d33e <posix_print_error_and_exit>
 804db37:	83 c4 10             	add    $0x10,%esp
 804db3a:	eb 05                	jmp    804db41 <native_add_command_line_opts+0x74>
		} else {
			args_struct = new_args_struct;
 804db3c:	a3 b0 6a 05 08       	mov    %eax,0x8056ab0
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
 804db41:	8b 15 ac 6a 05 08    	mov    0x8056aac,%edx
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
 804db47:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	memcpy(&args_struct[used_args], args,
 804db4a:	6b cf 1c             	imul   $0x1c,%edi,%ecx
 804db4d:	6b c2 1c             	imul   $0x1c,%edx,%eax
 804db50:	03 05 b0 6a 05 08    	add    0x8056ab0,%eax
	used_args += count - 1;
 804db56:	01 d3                	add    %edx,%ebx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
 804db58:	89 c7                	mov    %eax,%edi
 804db5a:	89 1d ac 6a 05 08    	mov    %ebx,0x8056aac
 804db60:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
 804db62:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804db65:	5b                   	pop    %ebx
 804db66:	5e                   	pop    %esi
 804db67:	5f                   	pop    %edi
 804db68:	5d                   	pop    %ebp
 804db69:	c3                   	ret    

0804db6a <native_add_testargs_option>:

void native_add_testargs_option(void)
{
 804db6a:	f3 0f 1e fb          	endbr32 
 804db6e:	55                   	push   %ebp
 804db6f:	89 e5                	mov    %esp,%ebp
 804db71:	83 ec 14             	sub    $0x14,%esp
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
 804db74:	68 20 52 05 08       	push   $0x8055220
 804db79:	e8 4f ff ff ff       	call   804dacd <native_add_command_line_opts>
 804db7e:	83 c4 10             	add    $0x10,%esp
}
 804db81:	c9                   	leave  
 804db82:	c3                   	ret    

0804db83 <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
 804db83:	f3 0f 1e fb          	endbr32 
 804db87:	55                   	push   %ebp
 804db88:	89 e5                	mov    %esp,%ebp
 804db8a:	57                   	push   %edi
 804db8b:	56                   	push   %esi
 804db8c:	53                   	push   %ebx
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
 804db8d:	bb 01 00 00 00       	mov    $0x1,%ebx
{
 804db92:	83 ec 0c             	sub    $0xc,%esp
 804db95:	8b 75 0c             	mov    0xc(%ebp),%esi
	native_add_tracing_options();
 804db98:	e8 16 f8 ff ff       	call   804d3b3 <native_add_tracing_options>
	native_add_testargs_option();
 804db9d:	e8 c8 ff ff ff       	call   804db6a <native_add_testargs_option>
	cmd_args_set_defaults(args_struct);
 804dba2:	83 ec 0c             	sub    $0xc,%esp
	s_argc = argc;
 804dba5:	8b 45 08             	mov    0x8(%ebp),%eax
	cmd_args_set_defaults(args_struct);
 804dba8:	ff 35 b0 6a 05 08    	pushl  0x8056ab0
	s_argv = argv;
 804dbae:	89 35 b8 6a 05 08    	mov    %esi,0x8056ab8
	s_argc = argc;
 804dbb4:	a3 c0 6a 05 08       	mov    %eax,0x8056ac0
	cmd_args_set_defaults(args_struct);
 804dbb9:	e8 6a fb ff ff       	call   804d728 <cmd_args_set_defaults>
 804dbbe:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
 804dbc1:	3b 5d 08             	cmp    0x8(%ebp),%ebx
 804dbc4:	7d 6d                	jge    804dc33 <native_handle_cmd_line+0xb0>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
 804dbc6:	57                   	push   %edi
 804dbc7:	8d 7b 01             	lea    0x1(%ebx),%edi
 804dbca:	6a 00                	push   $0x0
 804dbcc:	68 87 2a 05 08       	push   $0x8052a87
 804dbd1:	ff 34 9e             	pushl  (%esi,%ebx,4)
 804dbd4:	e8 9e f8 ff ff       	call   804d477 <cmd_is_option>
 804dbd9:	83 c4 10             	add    $0x10,%esp
 804dbdc:	85 c0                	test   %eax,%eax
 804dbde:	74 18                	je     804dbf8 <native_handle_cmd_line+0x75>
			test_argc = argc - i - 1;
 804dbe0:	8b 45 08             	mov    0x8(%ebp),%eax
 804dbe3:	29 d8                	sub    %ebx,%eax
 804dbe5:	89 c3                	mov    %eax,%ebx
			test_argv = &argv[i+1];
 804dbe7:	8d 04 be             	lea    (%esi,%edi,4),%eax
			test_argc = argc - i - 1;
 804dbea:	4b                   	dec    %ebx
			test_argv = &argv[i+1];
 804dbeb:	a3 b4 6a 05 08       	mov    %eax,0x8056ab4
			test_argc = argc - i - 1;
 804dbf0:	89 1d bc 6a 05 08    	mov    %ebx,0x8056abc
			break;
 804dbf6:	eb 3b                	jmp    804dc33 <native_handle_cmd_line+0xb0>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
 804dbf8:	51                   	push   %ecx
 804dbf9:	51                   	push   %ecx
 804dbfa:	ff 35 b0 6a 05 08    	pushl  0x8056ab0
 804dc00:	ff 34 9e             	pushl  (%esi,%ebx,4)
 804dc03:	e8 dc fd ff ff       	call   804d9e4 <cmd_parse_one_arg>
 804dc08:	83 c4 10             	add    $0x10,%esp
 804dc0b:	84 c0                	test   %al,%al
 804dc0d:	75 20                	jne    804dc2f <native_handle_cmd_line+0xac>
			cmd_print_switches_help(args_struct);
 804dc0f:	83 ec 0c             	sub    $0xc,%esp
 804dc12:	ff 35 b0 6a 05 08    	pushl  0x8056ab0
 804dc18:	e8 b4 fb ff ff       	call   804d7d1 <cmd_print_switches_help>
 804dc1d:	58                   	pop    %eax
 804dc1e:	5a                   	pop    %edx
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
 804dc1f:	ff 34 9e             	pushl  (%esi,%ebx,4)
 804dc22:	68 90 2a 05 08       	push   $0x8052a90
 804dc27:	e8 12 f7 ff ff       	call   804d33e <posix_print_error_and_exit>
 804dc2c:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
 804dc2f:	89 fb                	mov    %edi,%ebx
 804dc31:	eb 8e                	jmp    804dbc1 <native_handle_cmd_line+0x3e>
			print_invalid_opt_error(argv[i]);
		}
	}
}
 804dc33:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804dc36:	5b                   	pop    %ebx
 804dc37:	5e                   	pop    %esi
 804dc38:	5f                   	pop    %edi
 804dc39:	5d                   	pop    %ebp
 804dc3a:	c3                   	ret    

0804dc3b <hw_counter_init>:

/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
 804dc3b:	f3 0f 1e fb          	endbr32 
	hw_counter_timer = NEVER;
 804dc3f:	c7 05 08 6a 05 08 ff 	movl   $0xffffffff,0x8056a08
 804dc46:	ff ff ff 
 804dc49:	c7 05 0c 6a 05 08 ff 	movl   $0xffffffff,0x8056a0c
 804dc50:	ff ff ff 
	counter_target = NEVER;
 804dc53:	c7 05 f8 69 05 08 ff 	movl   $0xffffffff,0x80569f8
 804dc5a:	ff ff ff 
 804dc5d:	c7 05 fc 69 05 08 ff 	movl   $0xffffffff,0x80569fc
 804dc64:	ff ff ff 
	counter_value = 0;
 804dc67:	c7 05 00 6a 05 08 00 	movl   $0x0,0x8056a00
 804dc6e:	00 00 00 
 804dc71:	c7 05 04 6a 05 08 00 	movl   $0x0,0x8056a04
 804dc78:	00 00 00 
	counter_running = false;
 804dc7b:	c6 05 f1 6a 05 08 00 	movb   $0x0,0x8056af1
	counter_period = NEVER;
 804dc82:	c7 05 f0 69 05 08 ff 	movl   $0xffffffff,0x80569f0
 804dc89:	ff ff ff 
 804dc8c:	c7 05 f4 69 05 08 ff 	movl   $0xffffffff,0x80569f4
 804dc93:	ff ff ff 
}
 804dc96:	c3                   	ret    

0804dc97 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
 804dc97:	f3 0f 1e fb          	endbr32 
	if (!counter_running) {
 804dc9b:	80 3d f1 6a 05 08 00 	cmpb   $0x0,0x8056af1
 804dca2:	75 15                	jne    804dcb9 <hw_counter_triggered+0x22>
		hw_counter_timer = NEVER;
 804dca4:	c7 05 08 6a 05 08 ff 	movl   $0xffffffff,0x8056a08
 804dcab:	ff ff ff 
 804dcae:	c7 05 0c 6a 05 08 ff 	movl   $0xffffffff,0x8056a0c
 804dcb5:	ff ff ff 
		return;
 804dcb8:	c3                   	ret    
{
 804dcb9:	55                   	push   %ebp
 804dcba:	89 e5                	mov    %esp,%ebp
 804dcbc:	83 ec 08             	sub    $0x8,%esp
	}

	hw_counter_timer = hwm_get_time() + counter_period;
 804dcbf:	e8 2d ea ff ff       	call   804c6f1 <hwm_get_time>
 804dcc4:	03 05 f0 69 05 08    	add    0x80569f0,%eax
 804dcca:	13 15 f4 69 05 08    	adc    0x80569f4,%edx
 804dcd0:	a3 08 6a 05 08       	mov    %eax,0x8056a08
	counter_value = counter_value + 1;
 804dcd5:	a1 00 6a 05 08       	mov    0x8056a00,%eax
	hw_counter_timer = hwm_get_time() + counter_period;
 804dcda:	89 15 0c 6a 05 08    	mov    %edx,0x8056a0c
	counter_value = counter_value + 1;
 804dce0:	8b 15 04 6a 05 08    	mov    0x8056a04,%edx
 804dce6:	83 c0 01             	add    $0x1,%eax
 804dce9:	83 d2 00             	adc    $0x0,%edx
 804dcec:	a3 00 6a 05 08       	mov    %eax,0x8056a00
 804dcf1:	89 15 04 6a 05 08    	mov    %edx,0x8056a04

	if (counter_value == counter_target) {
 804dcf7:	3b 15 fc 69 05 08    	cmp    0x80569fc,%edx
 804dcfd:	75 15                	jne    804dd14 <hw_counter_triggered+0x7d>
 804dcff:	3b 05 f8 69 05 08    	cmp    0x80569f8,%eax
 804dd05:	75 0d                	jne    804dd14 <hw_counter_triggered+0x7d>
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
 804dd07:	83 ec 0c             	sub    $0xc,%esp
 804dd0a:	6a 02                	push   $0x2
 804dd0c:	e8 29 f4 ff ff       	call   804d13a <hw_irq_ctrl_set_irq>
 804dd11:	83 c4 10             	add    $0x10,%esp
	}
}
 804dd14:	c9                   	leave  
 804dd15:	c3                   	ret    

0804dd16 <run_test_rules>:
#include <syscalls/z_test_1cpu_stop_mrsh.c>
#endif /* CONFIG_USERSPACE */
#endif

static void run_test_rules(bool is_before, struct ztest_unit_test *test, void *data)
{
 804dd16:	55                   	push   %ebp
 804dd17:	89 e5                	mov    %esp,%ebp
 804dd19:	57                   	push   %edi
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
 804dd1a:	bf e4 62 05 08       	mov    $0x80562e4,%edi
{
 804dd1f:	56                   	push   %esi
 804dd20:	89 ce                	mov    %ecx,%esi
 804dd22:	53                   	push   %ebx
 804dd23:	89 d3                	mov    %edx,%ebx
 804dd25:	83 ec 1c             	sub    $0x1c,%esp
 804dd28:	88 45 e7             	mov    %al,-0x19(%ebp)
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
 804dd2b:	81 ff e4 62 05 08    	cmp    $0x80562e4,%edi
 804dd31:	73 1f                	jae    804dd52 <run_test_rules+0x3c>
	     rule < _ztest_test_rule_list_end; ++rule) {
		if (is_before && rule->before_each) {
 804dd33:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
 804dd37:	74 04                	je     804dd3d <run_test_rules+0x27>
 804dd39:	8b 17                	mov    (%edi),%edx
 804dd3b:	eb 03                	jmp    804dd40 <run_test_rules+0x2a>
			rule->before_each(test, data);
		} else if (!is_before && rule->after_each) {
 804dd3d:	8b 57 04             	mov    0x4(%edi),%edx
 804dd40:	85 d2                	test   %edx,%edx
 804dd42:	74 09                	je     804dd4d <run_test_rules+0x37>
			rule->after_each(test, data);
 804dd44:	50                   	push   %eax
 804dd45:	50                   	push   %eax
 804dd46:	56                   	push   %esi
 804dd47:	53                   	push   %ebx
 804dd48:	ff d2                	call   *%edx
 804dd4a:	83 c4 10             	add    $0x10,%esp
	     rule < _ztest_test_rule_list_end; ++rule) {
 804dd4d:	83 c7 08             	add    $0x8,%edi
 804dd50:	eb d9                	jmp    804dd2b <run_test_rules+0x15>
		}
	}
}
 804dd52:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804dd55:	5b                   	pop    %ebx
 804dd56:	5e                   	pop    %esi
 804dd57:	5f                   	pop    %edi
 804dd58:	5d                   	pop    %ebp
 804dd59:	c3                   	ret    

0804dd5a <ztest_find_test_suite>:
}

#endif /* !KERNEL */

static struct ztest_suite_node *ztest_find_test_suite(const char *name)
{
 804dd5a:	55                   	push   %ebp
 804dd5b:	89 e5                	mov    %esp,%ebp
 804dd5d:	56                   	push   %esi
 804dd5e:	89 c6                	mov    %eax,%esi
 804dd60:	53                   	push   %ebx
	struct ztest_suite_node *node;

	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
 804dd61:	bb e8 61 05 08       	mov    $0x80561e8,%ebx
 804dd66:	81 fb 54 62 05 08    	cmp    $0x8056254,%ebx
 804dd6c:	73 16                	jae    804dd84 <ztest_find_test_suite+0x2a>
		if (strcmp(name, node->name) == 0) {
 804dd6e:	50                   	push   %eax
 804dd6f:	50                   	push   %eax
 804dd70:	ff 33                	pushl  (%ebx)
 804dd72:	56                   	push   %esi
 804dd73:	e8 b8 b5 ff ff       	call   8049330 <strcmp@plt>
 804dd78:	83 c4 10             	add    $0x10,%esp
 804dd7b:	85 c0                	test   %eax,%eax
 804dd7d:	74 07                	je     804dd86 <ztest_find_test_suite+0x2c>
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
 804dd7f:	83 c3 24             	add    $0x24,%ebx
 804dd82:	eb e2                	jmp    804dd66 <ztest_find_test_suite+0xc>
			return node;
		}
	}

	return NULL;
 804dd84:	31 db                	xor    %ebx,%ebx
}
 804dd86:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804dd89:	89 d8                	mov    %ebx,%eax
 804dd8b:	5b                   	pop    %ebx
 804dd8c:	5e                   	pop    %esi
 804dd8d:	5d                   	pop    %ebp
 804dd8e:	c3                   	ret    

0804dd8f <test_time_ms>:
		tc_start_time = k_cycle_get_32();
	}
}

static inline void test_time_ms(void)
{
 804dd8f:	55                   	push   %ebp
 804dd90:	89 e5                	mov    %esp,%ebp
 804dd92:	53                   	push   %ebx
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_cyc_to_ms_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_cyc, Z_HZ_ms, Z_CCYC, true, true, false);
 804dd93:	31 db                	xor    %ebx,%ebx
 804dd95:	50                   	push   %eax
	return sys_clock_cycle_get_32();
 804dd96:	e8 c0 06 00 00       	call   804e45b <sys_clock_cycle_get_32>
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
 804dd9b:	2b 05 d0 6a 05 08    	sub    0x8056ad0,%eax
 804dda1:	89 c1                	mov    %eax,%ecx
		t += off;
 804dda3:	81 c1 e7 03 00 00    	add    $0x3e7,%ecx
 804dda9:	83 d3 00             	adc    $0x0,%ebx
		if (result32 && (t < BIT64(32))) {
 804ddac:	83 fb 00             	cmp    $0x0,%ebx
 804ddaf:	77 10                	ja     804ddc1 <test_time_ms+0x32>
			return ((uint32_t)t) / (from_hz / to_hz);
 804ddb1:	05 e7 03 00 00       	add    $0x3e7,%eax
 804ddb6:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804ddbb:	31 d2                	xor    %edx,%edx
 804ddbd:	f7 f1                	div    %ecx
 804ddbf:	eb 11                	jmp    804ddd2 <test_time_ms+0x43>
			return t / ((uint64_t)from_hz / to_hz);
 804ddc1:	6a 00                	push   $0x0
 804ddc3:	68 e8 03 00 00       	push   $0x3e8
 804ddc8:	53                   	push   %ebx
 804ddc9:	51                   	push   %ecx
 804ddca:	e8 51 b5 ff ff       	call   8049320 <__udivdi3@plt>
 804ddcf:	83 c4 10             	add    $0x10,%esp
	return z_tmcvt(t, Z_HZ_cyc, Z_HZ_ms, Z_CCYC, true, true, false);
 804ddd2:	a3 cc 6a 05 08       	mov    %eax,0x8056acc

	tc_spend_time = k_cyc_to_ms_ceil32(spend_cycle);
}
 804ddd7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804ddda:	c9                   	leave  
 804dddb:	c3                   	ret    

0804dddc <test_cb>:
{
 804dddc:	f3 0f 1e fb          	endbr32 
 804dde0:	55                   	push   %ebp
	run_test_rules(/*is_before=*/true, test, /*data=*/c);
 804dde1:	b8 01 00 00 00       	mov    $0x1,%eax
	test_result = 1;
 804dde6:	c7 05 c4 6a 05 08 01 	movl   $0x1,0x8056ac4
 804dded:	00 00 00 
{
 804ddf0:	89 e5                	mov    %esp,%ebp
 804ddf2:	56                   	push   %esi
 804ddf3:	8b 75 0c             	mov    0xc(%ebp),%esi
 804ddf6:	53                   	push   %ebx
 804ddf7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	run_test_rules(/*is_before=*/true, test, /*data=*/c);
 804ddfa:	89 f2                	mov    %esi,%edx
 804ddfc:	89 d9                	mov    %ebx,%ecx
 804ddfe:	e8 13 ff ff ff       	call   804dd16 <run_test_rules>
	if (suite->before) {
 804de03:	8b 45 08             	mov    0x8(%ebp),%eax
 804de06:	8b 40 08             	mov    0x8(%eax),%eax
 804de09:	85 c0                	test   %eax,%eax
 804de0b:	74 09                	je     804de16 <test_cb+0x3a>
		suite->before(/*data=*/c);
 804de0d:	83 ec 0c             	sub    $0xc,%esp
 804de10:	53                   	push   %ebx
 804de11:	ff d0                	call   *%eax
 804de13:	83 c4 10             	add    $0x10,%esp
	phase = TEST_PHASE_TEST;
 804de16:	c7 05 8c 52 05 08 02 	movl   $0x2,0x805528c
 804de1d:	00 00 00 
	test->test(data);
 804de20:	83 ec 0c             	sub    $0xc,%esp
 804de23:	53                   	push   %ebx
 804de24:	ff 56 08             	call   *0x8(%esi)
	test_result = 0;
 804de27:	c7 05 c4 6a 05 08 00 	movl   $0x0,0x8056ac4
 804de2e:	00 00 00 
	test->test(data);
 804de31:	83 c4 10             	add    $0x10,%esp
}
 804de34:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804de37:	5b                   	pop    %ebx
 804de38:	5e                   	pop    %esi
 804de39:	5d                   	pop    %ebp
 804de3a:	c3                   	ret    

0804de3b <test_finalize>:
{
 804de3b:	55                   	push   %ebp
 804de3c:	89 e5                	mov    %esp,%ebp
 804de3e:	83 ec 14             	sub    $0x14,%esp
 804de41:	68 e0 67 05 08       	push   $0x80567e0
 804de46:	e8 52 e2 ff ff       	call   804c09d <z_impl_k_thread_abort>
 804de4b:	83 c4 10             	add    $0x10,%esp
	return z_impl_z_current_get();
 804de4e:	e8 06 1b 00 00       	call   804f959 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
 804de53:	83 ec 0c             	sub    $0xc,%esp
 804de56:	50                   	push   %eax
 804de57:	e8 41 e2 ff ff       	call   804c09d <z_impl_k_thread_abort>
 804de5c:	83 c4 10             	add    $0x10,%esp
}
 804de5f:	c9                   	leave  
 804de60:	c3                   	ret    

0804de61 <ztest_relative_filename>:
{
 804de61:	f3 0f 1e fb          	endbr32 
 804de65:	55                   	push   %ebp
 804de66:	89 e5                	mov    %esp,%ebp
 804de68:	57                   	push   %edi
 804de69:	56                   	push   %esi
 804de6a:	53                   	push   %ebx
 804de6b:	81 ec f4 00 00 00    	sub    $0xf4,%esp
 804de71:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804de74:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804de7a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804de7d:	31 c0                	xor    %eax,%eax
	return __getcwd_chk (__buf, __size, __bos (__buf));

      if (__size > __bos (__buf))
	return __getcwd_chk_warn (__buf, __size, __bos (__buf));
    }
  return __getcwd_alias (__buf, __size);
 804de7f:	8d 85 1c ff ff ff    	lea    -0xe4(%ebp),%eax
 804de85:	68 c8 00 00 00       	push   $0xc8
 804de8a:	50                   	push   %eax
 804de8b:	e8 a0 b5 ff ff       	call   8049430 <getcwd@plt>
 804de90:	83 c4 10             	add    $0x10,%esp
	if (cwd && strlen(file) > strlen(cwd) &&
 804de93:	85 c0                	test   %eax,%eax
 804de95:	74 3f                	je     804ded6 <ztest_relative_filename+0x75>
 804de97:	83 ce ff             	or     $0xffffffff,%esi
 804de9a:	89 c2                	mov    %eax,%edx
 804de9c:	89 df                	mov    %ebx,%edi
 804de9e:	31 c0                	xor    %eax,%eax
 804dea0:	89 f1                	mov    %esi,%ecx
 804dea2:	f2 ae                	repnz scas %es:(%edi),%al
 804dea4:	f7 d1                	not    %ecx
 804dea6:	8d 79 ff             	lea    -0x1(%ecx),%edi
 804dea9:	89 f1                	mov    %esi,%ecx
 804deab:	89 bd 14 ff ff ff    	mov    %edi,-0xec(%ebp)
 804deb1:	89 d7                	mov    %edx,%edi
 804deb3:	f2 ae                	repnz scas %es:(%edi),%al
 804deb5:	89 ce                	mov    %ecx,%esi
 804deb7:	f7 d6                	not    %esi
 804deb9:	8d 46 ff             	lea    -0x1(%esi),%eax
 804debc:	39 85 14 ff ff ff    	cmp    %eax,-0xec(%ebp)
 804dec2:	76 12                	jbe    804ded6 <ztest_relative_filename+0x75>
	    !strncmp(file, cwd, strlen(cwd)))
 804dec4:	51                   	push   %ecx
 804dec5:	50                   	push   %eax
 804dec6:	52                   	push   %edx
 804dec7:	53                   	push   %ebx
 804dec8:	e8 a3 b6 ff ff       	call   8049570 <strncmp@plt>
 804decd:	83 c4 10             	add    $0x10,%esp
	if (cwd && strlen(file) > strlen(cwd) &&
 804ded0:	85 c0                	test   %eax,%eax
 804ded2:	75 02                	jne    804ded6 <ztest_relative_filename+0x75>
		return file + strlen(cwd) + 1; /* move past the trailing '/' */
 804ded4:	01 f3                	add    %esi,%ebx
}
 804ded6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ded9:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804dee0:	74 05                	je     804dee7 <ztest_relative_filename+0x86>
 804dee2:	e8 d9 b4 ff ff       	call   80493c0 <__stack_chk_fail@plt>
 804dee7:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804deea:	89 d8                	mov    %ebx,%eax
 804deec:	5b                   	pop    %ebx
 804deed:	5e                   	pop    %esi
 804deee:	5f                   	pop    %edi
 804deef:	5d                   	pop    %ebp
 804def0:	c3                   	ret    

0804def1 <ztest_test_fail>:
{
 804def1:	f3 0f 1e fb          	endbr32 
	test_result = -1;
 804def5:	c7 05 c4 6a 05 08 ff 	movl   $0xffffffff,0x8056ac4
 804defc:	ff ff ff 
	test_finalize();
 804deff:	e9 37 ff ff ff       	jmp    804de3b <test_finalize>

0804df04 <ztest_get_next_test>:

struct ztest_unit_test *ztest_get_next_test(const char *suite, struct ztest_unit_test *prev)
{
 804df04:	f3 0f 1e fb          	endbr32 
 804df08:	55                   	push   %ebp
 804df09:	89 e5                	mov    %esp,%ebp
 804df0b:	53                   	push   %ebx
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
 804df0c:	bb 54 62 05 08       	mov    $0x8056254,%ebx
{
 804df11:	52                   	push   %edx
 804df12:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
 804df15:	85 c0                	test   %eax,%eax
 804df17:	74 1b                	je     804df34 <ztest_get_next_test+0x30>
 804df19:	8d 58 10             	lea    0x10(%eax),%ebx
 804df1c:	eb 16                	jmp    804df34 <ztest_get_next_test+0x30>

	for (; test < _ztest_unit_test_list_end; ++test) {
		if (strcmp(suite, test->test_suite_name) == 0) {
 804df1e:	50                   	push   %eax
 804df1f:	50                   	push   %eax
 804df20:	ff 33                	pushl  (%ebx)
 804df22:	ff 75 08             	pushl  0x8(%ebp)
 804df25:	e8 06 b4 ff ff       	call   8049330 <strcmp@plt>
 804df2a:	83 c4 10             	add    $0x10,%esp
 804df2d:	85 c0                	test   %eax,%eax
 804df2f:	74 0d                	je     804df3e <ztest_get_next_test+0x3a>
	for (; test < _ztest_unit_test_list_end; ++test) {
 804df31:	83 c3 10             	add    $0x10,%ebx
 804df34:	81 fb e4 62 05 08    	cmp    $0x80562e4,%ebx
 804df3a:	72 e2                	jb     804df1e <ztest_get_next_test+0x1a>
			return test;
		}
	}
	return NULL;
 804df3c:	31 db                	xor    %ebx,%ebx
}
 804df3e:	89 d8                	mov    %ebx,%eax
 804df40:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804df43:	c9                   	leave  
 804df44:	c3                   	ret    

0804df45 <z_ztest_run_test_suite_ptr>:

static int z_ztest_run_test_suite_ptr(struct ztest_suite_node *suite)
{
 804df45:	55                   	push   %ebp
 804df46:	89 e5                	mov    %esp,%ebp
 804df48:	57                   	push   %edi
 804df49:	56                   	push   %esi
 804df4a:	53                   	push   %ebx
 804df4b:	83 ec 1c             	sub    $0x1c,%esp
	struct ztest_unit_test *test = NULL;
	void *data = NULL;
	int fail = 0;

	if (test_status < 0) {
 804df4e:	8b 3d c8 6a 05 08    	mov    0x8056ac8,%edi
 804df54:	85 ff                	test   %edi,%edi
 804df56:	0f 88 11 02 00 00    	js     804e16d <z_ztest_run_test_suite_ptr+0x228>
 804df5c:	89 c6                	mov    %eax,%esi
		return test_status;
	}

	if (suite == NULL) {
 804df5e:	85 c0                	test   %eax,%eax
 804df60:	75 12                	jne    804df74 <z_ztest_run_test_suite_ptr+0x2f>
		test_status = 1;
 804df62:	c7 05 c8 6a 05 08 01 	movl   $0x1,0x8056ac8
 804df69:	00 00 00 
		return -1;
 804df6c:	83 cf ff             	or     $0xffffffff,%edi
 804df6f:	e9 f9 01 00 00       	jmp    804e16d <z_ztest_run_test_suite_ptr+0x228>
	}

	init_testing();

	TC_SUITE_START(suite->name);
 804df74:	51                   	push   %ecx
 804df75:	51                   	push   %ecx
 804df76:	ff 30                	pushl  (%eax)
 804df78:	68 4c 2b 05 08       	push   $0x8052b4c
 804df7d:	e8 19 c8 ff ff       	call   804a79b <printk>
 804df82:	c7 04 24 63 2b 05 08 	movl   $0x8052b63,(%esp)
 804df89:	e8 0d c8 ff ff       	call   804a79b <printk>
	phase = TEST_PHASE_SETUP;
	if (suite->setup != NULL) {
 804df8e:	8b 46 04             	mov    0x4(%esi),%eax
	void *data = NULL;
 804df91:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	TC_SUITE_START(suite->name);
 804df98:	83 c4 10             	add    $0x10,%esp
	phase = TEST_PHASE_SETUP;
 804df9b:	c7 05 8c 52 05 08 00 	movl   $0x0,0x805528c
 804dfa2:	00 00 00 
	if (suite->setup != NULL) {
 804dfa5:	85 c0                	test   %eax,%eax
 804dfa7:	74 05                	je     804dfae <z_ztest_run_test_suite_ptr+0x69>
		data = suite->setup();
 804dfa9:	ff d0                	call   *%eax
 804dfab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	void *data = NULL;
 804dfae:	31 ff                	xor    %edi,%edi
 804dfb0:	31 db                	xor    %ebx,%ebx
	}
	while ((test = ztest_get_next_test(suite->name, test)) != NULL) {
 804dfb2:	8b 16                	mov    (%esi),%edx
 804dfb4:	50                   	push   %eax
 804dfb5:	50                   	push   %eax
 804dfb6:	53                   	push   %ebx
 804dfb7:	52                   	push   %edx
 804dfb8:	89 55 e0             	mov    %edx,-0x20(%ebp)
 804dfbb:	e8 44 ff ff ff       	call   804df04 <ztest_get_next_test>
 804dfc0:	83 c4 10             	add    $0x10,%esp
 804dfc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804dfc6:	85 c0                	test   %eax,%eax
 804dfc8:	89 c3                	mov    %eax,%ebx
 804dfca:	0f 84 50 01 00 00    	je     804e120 <z_ztest_run_test_suite_ptr+0x1db>
	TC_START(test->name);
 804dfd0:	51                   	push   %ecx
 804dfd1:	51                   	push   %ecx
 804dfd2:	ff 73 04             	pushl  0x4(%ebx)
 804dfd5:	68 a8 2b 05 08       	push   $0x8052ba8
 804dfda:	e8 bc c7 ff ff       	call   804a79b <printk>
 804dfdf:	83 c4 10             	add    $0x10,%esp
 804dfe2:	e8 74 04 00 00       	call   804e45b <sys_clock_cycle_get_32>
	phase = TEST_PHASE_BEFORE;
 804dfe7:	c7 05 8c 52 05 08 01 	movl   $0x1,0x805528c
 804dfee:	00 00 00 
		tc_start_time = k_cycle_get_32();
 804dff1:	a3 d0 6a 05 08       	mov    %eax,0x8056ad0
				test->thread_options | K_INHERIT_PERMS, K_FOREVER);
 804dff6:	8b 43 0c             	mov    0xc(%ebx),%eax
 804dff9:	83 c8 08             	or     $0x8,%eax
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 804dffc:	52                   	push   %edx
 804dffd:	6a ff                	push   $0xffffffff
 804dfff:	6a ff                	push   $0xffffffff
 804e001:	50                   	push   %eax
 804e002:	6a ff                	push   $0xffffffff
 804e004:	ff 75 e4             	pushl  -0x1c(%ebp)
 804e007:	53                   	push   %ebx
 804e008:	56                   	push   %esi
 804e009:	68 dc dd 04 08       	push   $0x804dddc
 804e00e:	68 00 04 00 00       	push   $0x400
 804e013:	68 9c 52 05 08       	push   $0x805529c
 804e018:	68 e0 67 05 08       	push   $0x80567e0
 804e01d:	e8 27 09 00 00       	call   804e949 <z_impl_k_thread_create>
		if (test->name != NULL) {
 804e022:	8b 43 04             	mov    0x4(%ebx),%eax
 804e025:	83 c4 30             	add    $0x30,%esp
 804e028:	85 c0                	test   %eax,%eax
 804e02a:	74 10                	je     804e03c <z_ztest_run_test_suite_ptr+0xf7>
		union { uintptr_t x; const char * val; } parm1 = { .val = str };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread, str);
 804e02c:	52                   	push   %edx
 804e02d:	52                   	push   %edx
 804e02e:	50                   	push   %eax
 804e02f:	68 e0 67 05 08       	push   $0x80567e0
 804e034:	e8 c7 07 00 00       	call   804e800 <z_impl_k_thread_name_set>
 804e039:	83 c4 10             	add    $0x10,%esp
	z_impl_k_thread_start(thread);
 804e03c:	83 ec 0c             	sub    $0xc,%esp
 804e03f:	68 e0 67 05 08       	push   $0x80567e0
 804e044:	e8 f9 07 00 00       	call   804e842 <z_impl_k_thread_start>
 804e049:	83 c4 0c             	add    $0xc,%esp
	return z_impl_k_thread_join(thread, timeout);
 804e04c:	6a ff                	push   $0xffffffff
 804e04e:	6a ff                	push   $0xffffffff
 804e050:	68 e0 67 05 08       	push   $0x80567e0
 804e055:	e8 20 1b 00 00       	call   804fb7a <z_impl_k_thread_join>
	if (suite->after != NULL) {
 804e05a:	8b 46 0c             	mov    0xc(%esi),%eax
 804e05d:	83 c4 10             	add    $0x10,%esp
	phase = TEST_PHASE_AFTER;
 804e060:	c7 05 8c 52 05 08 03 	movl   $0x3,0x805528c
 804e067:	00 00 00 
	if (suite->after != NULL) {
 804e06a:	85 c0                	test   %eax,%eax
 804e06c:	74 0b                	je     804e079 <z_ztest_run_test_suite_ptr+0x134>
		suite->after(data);
 804e06e:	83 ec 0c             	sub    $0xc,%esp
 804e071:	ff 75 e4             	pushl  -0x1c(%ebp)
 804e074:	ff d0                	call   *%eax
 804e076:	83 c4 10             	add    $0x10,%esp
	run_test_rules(/*is_before=*/false, test, data);
 804e079:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804e07c:	31 c0                	xor    %eax,%eax
 804e07e:	89 da                	mov    %ebx,%edx
 804e080:	e8 91 fc ff ff       	call   804dd16 <run_test_rules>
	int ret = TC_PASS;
 804e085:	31 c0                	xor    %eax,%eax
 804e087:	83 3d c4 6a 05 08 ff 	cmpl   $0xffffffff,0x8056ac4
	phase = TEST_PHASE_FRAMEWORK;
 804e08e:	c7 05 8c 52 05 08 05 	movl   $0x5,0x805528c
 804e095:	00 00 00 
	int ret = TC_PASS;
 804e098:	0f 94 c0             	sete   %al
 804e09b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	z_impl_k_thread_abort(thread);
 804e09e:	83 ec 0c             	sub    $0xc,%esp
 804e0a1:	68 e0 67 05 08       	push   $0x80567e0
 804e0a6:	e8 f2 df ff ff       	call   804c09d <z_impl_k_thread_abort>
 804e0ab:	83 c4 10             	add    $0x10,%esp
	if (test_result == -2) {
 804e0ae:	83 3d c4 6a 05 08 fe 	cmpl   $0xfffffffe,0x8056ac4
 804e0b5:	75 22                	jne    804e0d9 <z_ztest_run_test_suite_ptr+0x194>
		Z_TC_END_RESULT(TC_SKIP, test->name);
 804e0b7:	e8 d3 fc ff ff       	call   804dd8f <test_time_ms>
 804e0bc:	a1 cc 6a 05 08       	mov    0x8056acc,%eax
 804e0c1:	31 d2                	xor    %edx,%edx
 804e0c3:	83 ec 0c             	sub    $0xc,%esp
 804e0c6:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804e0cb:	f7 f1                	div    %ecx
 804e0cd:	52                   	push   %edx
 804e0ce:	50                   	push   %eax
 804e0cf:	ff 73 04             	pushl  0x4(%ebx)
 804e0d2:	68 b4 2b 05 08       	push   $0x8052bb4
 804e0d7:	eb 25                	jmp    804e0fe <z_ztest_run_test_suite_ptr+0x1b9>
		Z_TC_END_RESULT(ret, test->name);
 804e0d9:	e8 b1 fc ff ff       	call   804dd8f <test_time_ms>
 804e0de:	a1 cc 6a 05 08       	mov    0x8056acc,%eax
 804e0e3:	31 d2                	xor    %edx,%edx
 804e0e5:	83 ec 0c             	sub    $0xc,%esp
 804e0e8:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804e0ed:	f7 f1                	div    %ecx
 804e0ef:	52                   	push   %edx
 804e0f0:	50                   	push   %eax
 804e0f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804e0f4:	ff 73 04             	pushl  0x4(%ebx)
 804e0f7:	ff 34 85 f8 12 05 08 	pushl  0x80512f8(,%eax,4)
 804e0fe:	68 b9 2b 05 08       	push   $0x8052bb9
 804e103:	e8 93 c6 ff ff       	call   804a79b <printk>
 804e108:	83 c4 14             	add    $0x14,%esp
 804e10b:	68 63 2b 05 08       	push   $0x8052b63
 804e110:	e8 86 c6 ff ff       	call   804a79b <printk>
 804e115:	83 c4 10             	add    $0x10,%esp
		fail += run_test(suite, test, data);
 804e118:	03 7d e0             	add    -0x20(%ebp),%edi

		if (fail && FAIL_FAST) {
 804e11b:	e9 92 fe ff ff       	jmp    804dfb2 <z_ztest_run_test_suite_ptr+0x6d>
			break;
		}
	}
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
 804e120:	85 ff                	test   %edi,%edi
 804e122:	75 0a                	jne    804e12e <z_ztest_run_test_suite_ptr+0x1e9>
 804e124:	51                   	push   %ecx
 804e125:	51                   	push   %ecx
 804e126:	52                   	push   %edx
 804e127:	68 d4 2b 05 08       	push   $0x8052bd4
 804e12c:	eb 08                	jmp    804e136 <z_ztest_run_test_suite_ptr+0x1f1>
 804e12e:	50                   	push   %eax
 804e12f:	50                   	push   %eax
 804e130:	52                   	push   %edx
 804e131:	68 ed 2b 05 08       	push   $0x8052bed
 804e136:	e8 60 c6 ff ff       	call   804a79b <printk>
	phase = TEST_PHASE_TEARDOWN;
	if (suite->teardown != NULL) {
 804e13b:	8b 46 10             	mov    0x10(%esi),%eax
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
 804e13e:	83 c4 10             	add    $0x10,%esp
	phase = TEST_PHASE_TEARDOWN;
 804e141:	c7 05 8c 52 05 08 04 	movl   $0x4,0x805528c
 804e148:	00 00 00 
	if (suite->teardown != NULL) {
 804e14b:	85 c0                	test   %eax,%eax
 804e14d:	74 0b                	je     804e15a <z_ztest_run_test_suite_ptr+0x215>
		suite->teardown(data);
 804e14f:	83 ec 0c             	sub    $0xc,%esp
 804e152:	ff 75 e4             	pushl  -0x1c(%ebp)
 804e155:	ff d0                	call   *%eax
 804e157:	83 c4 10             	add    $0x10,%esp
	}

	test_status = (test_status || fail) ? 1 : 0;
 804e15a:	89 f8                	mov    %edi,%eax
 804e15c:	0b 05 c8 6a 05 08    	or     0x8056ac8,%eax
 804e162:	0f 95 c0             	setne  %al
 804e165:	0f b6 c0             	movzbl %al,%eax
 804e168:	a3 c8 6a 05 08       	mov    %eax,0x8056ac8

	return fail;
}
 804e16d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804e170:	89 f8                	mov    %edi,%eax
 804e172:	5b                   	pop    %ebx
 804e173:	5e                   	pop    %esi
 804e174:	5f                   	pop    %edi
 804e175:	5d                   	pop    %ebp
 804e176:	c3                   	ret    

0804e177 <end_report>:
{
	return z_ztest_run_test_suite_ptr(ztest_find_test_suite(name));
}

void end_report(void)
{
 804e177:	f3 0f 1e fb          	endbr32 
 804e17b:	55                   	push   %ebp
 804e17c:	89 e5                	mov    %esp,%ebp
 804e17e:	83 ec 08             	sub    $0x8,%esp
	if (test_status) {
 804e181:	83 3d c8 6a 05 08 00 	cmpl   $0x0,0x8056ac8
 804e188:	74 39                	je     804e1c3 <end_report+0x4c>
		TC_END_REPORT(TC_FAIL);
 804e18a:	83 ec 0c             	sub    $0xc,%esp
 804e18d:	68 63 2b 05 08       	push   $0x8052b63
 804e192:	e8 04 c6 ff ff       	call   804a79b <printk>
 804e197:	c7 04 24 04 2c 05 08 	movl   $0x8052c04,(%esp)
 804e19e:	e8 f8 c5 ff ff       	call   804a79b <printk>
 804e1a3:	59                   	pop    %ecx
 804e1a4:	58                   	pop    %eax
 804e1a5:	68 2d 2c 05 08       	push   $0x8052c2d
 804e1aa:	68 34 2c 05 08       	push   $0x8052c34
 804e1af:	e8 e7 c5 ff ff       	call   804a79b <printk>
 804e1b4:	83 c4 10             	add    $0x10,%esp
		(void) arch_syscall_invoke0(K_SYSCALL_LOG_PANIC);
		return;
	}
#endif
	compiler_barrier();
	z_impl_log_panic();
 804e1b7:	e8 65 d1 ff ff       	call   804b321 <z_impl_log_panic>
 804e1bc:	83 ec 0c             	sub    $0xc,%esp
 804e1bf:	6a 01                	push   $0x1
 804e1c1:	eb 37                	jmp    804e1fa <end_report+0x83>
	} else {
		TC_END_REPORT(TC_PASS);
 804e1c3:	83 ec 0c             	sub    $0xc,%esp
 804e1c6:	68 63 2b 05 08       	push   $0x8052b63
 804e1cb:	e8 cb c5 ff ff       	call   804a79b <printk>
 804e1d0:	c7 04 24 04 2c 05 08 	movl   $0x8052c04,(%esp)
 804e1d7:	e8 bf c5 ff ff       	call   804a79b <printk>
 804e1dc:	58                   	pop    %eax
 804e1dd:	5a                   	pop    %edx
 804e1de:	68 4a 2c 05 08       	push   $0x8052c4a
 804e1e3:	68 34 2c 05 08       	push   $0x8052c34
 804e1e8:	e8 ae c5 ff ff       	call   804a79b <printk>
 804e1ed:	83 c4 10             	add    $0x10,%esp
 804e1f0:	e8 2c d1 ff ff       	call   804b321 <z_impl_log_panic>
 804e1f5:	83 ec 0c             	sub    $0xc,%esp
 804e1f8:	6a 00                	push   $0x0
 804e1fa:	e8 02 f0 ff ff       	call   804d201 <posix_exit>
 804e1ff:	83 c4 10             	add    $0x10,%esp
	}
}
 804e202:	c9                   	leave  
 804e203:	c3                   	ret    

0804e204 <ztest_run_test_suites>:
#ifdef CONFIG_USERSPACE
K_APPMEM_PARTITION_DEFINE(ztest_mem_partition);
#endif

int ztest_run_test_suites(const void *state)
{
 804e204:	f3 0f 1e fb          	endbr32 
 804e208:	55                   	push   %ebp
 804e209:	89 e5                	mov    %esp,%ebp
 804e20b:	56                   	push   %esi
	struct ztest_suite_node *ptr;
	int count = 0;
 804e20c:	31 f6                	xor    %esi,%esi
{
 804e20e:	53                   	push   %ebx

	for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
 804e20f:	bb e8 61 05 08       	mov    $0x80561e8,%ebx
 804e214:	81 fb 54 62 05 08    	cmp    $0x8056254,%ebx
 804e21a:	73 3f                	jae    804e25b <ztest_run_test_suites+0x57>
		struct ztest_suite_stats *stats = &ptr->stats;
		bool should_run = true;

		if (ptr->predicate != NULL) {
 804e21c:	8b 43 14             	mov    0x14(%ebx),%eax
 804e21f:	85 c0                	test   %eax,%eax
 804e221:	74 0d                	je     804e230 <ztest_run_test_suites+0x2c>
			should_run = ptr->predicate(state);
 804e223:	83 ec 0c             	sub    $0xc,%esp
 804e226:	ff 75 08             	pushl  0x8(%ebp)
 804e229:	ff d0                	call   *%eax
 804e22b:	83 c4 10             	add    $0x10,%esp
 804e22e:	eb 07                	jmp    804e237 <ztest_run_test_suites+0x33>
		} else  {
			/* If predicate is NULL, only run this test once. */
			should_run = stats->run_count == 0;
 804e230:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
 804e234:	0f 94 c0             	sete   %al
		}

		if (should_run) {
 804e237:	84 c0                	test   %al,%al
 804e239:	74 18                	je     804e253 <ztest_run_test_suites+0x4f>
			int fail = z_ztest_run_test_suite_ptr(ptr);
 804e23b:	89 d8                	mov    %ebx,%eax

			count++;
 804e23d:	46                   	inc    %esi
			int fail = z_ztest_run_test_suite_ptr(ptr);
 804e23e:	e8 02 fd ff ff       	call   804df45 <z_ztest_run_test_suite_ptr>
			stats->run_count++;
 804e243:	ff 43 18             	incl   0x18(%ebx)
			stats->fail_count += (fail != 0) ? 1 : 0;
 804e246:	85 c0                	test   %eax,%eax
 804e248:	0f 95 c0             	setne  %al
 804e24b:	0f b6 c0             	movzbl %al,%eax
 804e24e:	01 43 20             	add    %eax,0x20(%ebx)
 804e251:	eb 03                	jmp    804e256 <ztest_run_test_suites+0x52>
		} else {
			stats->skip_count++;
 804e253:	ff 43 1c             	incl   0x1c(%ebx)
	for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
 804e256:	83 c3 24             	add    $0x24,%ebx
 804e259:	eb b9                	jmp    804e214 <ztest_run_test_suites+0x10>
		}
	}

	return count;
}
 804e25b:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804e25e:	89 f0                	mov    %esi,%eax
 804e260:	5b                   	pop    %ebx
 804e261:	5e                   	pop    %esi
 804e262:	5d                   	pop    %ebp
 804e263:	c3                   	ret    

0804e264 <ztest_verify_all_test_suites_ran>:

void ztest_verify_all_test_suites_ran(void)
{
 804e264:	f3 0f 1e fb          	endbr32 
 804e268:	55                   	push   %ebp
 804e269:	89 e5                	mov    %esp,%ebp
 804e26b:	57                   	push   %edi
 804e26c:	56                   	push   %esi
	bool all_tests_run = true;
 804e26d:	be 01 00 00 00       	mov    $0x1,%esi
{
 804e272:	53                   	push   %ebx
	struct ztest_suite_node *suite;
	struct ztest_unit_test *test;

	for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end; ++suite) {
 804e273:	bb e8 61 05 08       	mov    $0x80561e8,%ebx
{
 804e278:	83 ec 0c             	sub    $0xc,%esp
	for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end; ++suite) {
 804e27b:	81 fb 54 62 05 08    	cmp    $0x8056254,%ebx
 804e281:	73 1e                	jae    804e2a1 <ztest_verify_all_test_suites_ran+0x3d>
		if (suite->stats.run_count < 1) {
 804e283:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
 804e287:	75 13                	jne    804e29c <ztest_verify_all_test_suites_ran+0x38>
			PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
 804e289:	52                   	push   %edx
			all_tests_run = false;
 804e28a:	31 f6                	xor    %esi,%esi
			PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
 804e28c:	52                   	push   %edx
 804e28d:	ff 33                	pushl  (%ebx)
 804e28f:	68 55 2c 05 08       	push   $0x8052c55
 804e294:	e8 02 c5 ff ff       	call   804a79b <printk>
 804e299:	83 c4 10             	add    $0x10,%esp
	for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end; ++suite) {
 804e29c:	83 c3 24             	add    $0x24,%ebx
 804e29f:	eb da                	jmp    804e27b <ztest_verify_all_test_suites_ran+0x17>
		}
	}

	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
 804e2a1:	bb 54 62 05 08       	mov    $0x8056254,%ebx
 804e2a6:	81 fb e4 62 05 08    	cmp    $0x80562e4,%ebx
 804e2ac:	73 26                	jae    804e2d4 <ztest_verify_all_test_suites_ran+0x70>
		suite = ztest_find_test_suite(test->test_suite_name);
 804e2ae:	8b 3b                	mov    (%ebx),%edi
 804e2b0:	89 f8                	mov    %edi,%eax
 804e2b2:	e8 a3 fa ff ff       	call   804dd5a <ztest_find_test_suite>
		if (suite == NULL) {
 804e2b7:	85 c0                	test   %eax,%eax
 804e2b9:	75 14                	jne    804e2cf <ztest_verify_all_test_suites_ran+0x6b>
			PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't exist\n",
 804e2bb:	50                   	push   %eax
			      test->name, test->test_suite_name);
			all_tests_run = false;
 804e2bc:	31 f6                	xor    %esi,%esi
			PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't exist\n",
 804e2be:	57                   	push   %edi
 804e2bf:	ff 73 04             	pushl  0x4(%ebx)
 804e2c2:	68 7a 2c 05 08       	push   $0x8052c7a
 804e2c7:	e8 cf c4 ff ff       	call   804a79b <printk>
 804e2cc:	83 c4 10             	add    $0x10,%esp
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
 804e2cf:	83 c3 10             	add    $0x10,%ebx
 804e2d2:	eb d2                	jmp    804e2a6 <ztest_verify_all_test_suites_ran+0x42>
		}
	}

	if (!all_tests_run) {
 804e2d4:	89 f0                	mov    %esi,%eax
 804e2d6:	84 c0                	test   %al,%al
 804e2d8:	75 0a                	jne    804e2e4 <ztest_verify_all_test_suites_ran+0x80>
		test_status = 1;
 804e2da:	c7 05 c8 6a 05 08 01 	movl   $0x1,0x8056ac8
 804e2e1:	00 00 00 
	}
}
 804e2e4:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804e2e7:	5b                   	pop    %ebx
 804e2e8:	5e                   	pop    %esi
 804e2e9:	5f                   	pop    %edi
 804e2ea:	5d                   	pop    %ebp
 804e2eb:	c3                   	ret    

0804e2ec <test_main>:

void __weak test_main(void)
{
 804e2ec:	f3 0f 1e fb          	endbr32 
 804e2f0:	55                   	push   %ebp
 804e2f1:	89 e5                	mov    %esp,%ebp
 804e2f3:	83 ec 14             	sub    $0x14,%esp
	ztest_run_test_suites(NULL);
 804e2f6:	6a 00                	push   $0x0
 804e2f8:	e8 07 ff ff ff       	call   804e204 <ztest_run_test_suites>
 804e2fd:	83 c4 10             	add    $0x10,%esp
	ztest_verify_all_test_suites_ran();
}
 804e300:	c9                   	leave  
	ztest_verify_all_test_suites_ran();
 804e301:	e9 5e ff ff ff       	jmp    804e264 <ztest_verify_all_test_suites_ran>

0804e306 <zephyr_app_main>:

	return test_status;
}
#else
void main(void)
{
 804e306:	f3 0f 1e fb          	endbr32 
 804e30a:	55                   	push   %ebp
 804e30b:	89 e5                	mov    %esp,%ebp
 804e30d:	83 ec 08             	sub    $0x8,%esp
				   &z_malloc_partition);
#endif
#endif /* CONFIG_USERSPACE */

	z_init_mock();
	test_main();
 804e310:	e8 d7 ff ff ff       	call   804e2ec <test_main>
	end_report();
 804e315:	e8 5d fe ff ff       	call   804e177 <end_report>
		} else {
			PRINT("Failed after %u attempts\n", state.boots);
			state.boots = 0;
		}
	}
}
 804e31a:	c9                   	leave  
 804e31b:	e9 01 d0 ff ff       	jmp    804b321 <z_impl_log_panic>

0804e320 <native_posix_console_init>:
	}
}
#endif /* CONFIG_NATIVE_POSIX_STDIN_CONSOLE */

static int native_posix_console_init(const struct device *arg)
{
 804e320:	f3 0f 1e fb          	endbr32 
 804e324:	55                   	push   %ebp
 804e325:	89 e5                	mov    %esp,%ebp
 804e327:	83 ec 08             	sub    $0x8,%esp
	setvbuf(stdout, NULL, _IOLBF, 512);
 804e32a:	68 00 02 00 00       	push   $0x200
 804e32f:	6a 01                	push   $0x1
 804e331:	6a 00                	push   $0x0
 804e333:	ff 35 04 63 05 08    	pushl  0x8056304
 804e339:	e8 22 b1 ff ff       	call   8049460 <setvbuf@plt>
 804e33e:	83 c4 10             	add    $0x10,%esp
	setvbuf(stderr, NULL, _IOLBF, 512);
 804e341:	68 00 02 00 00       	push   $0x200
 804e346:	6a 01                	push   $0x1
 804e348:	6a 00                	push   $0x0
 804e34a:	ff 35 00 63 05 08    	pushl  0x8056300
 804e350:	e8 0b b1 ff ff       	call   8049460 <setvbuf@plt>
	__printk_hook_install(putchar);
 804e355:	c7 04 24 80 94 04 08 	movl   $0x8049480,(%esp)
 804e35c:	e8 e3 c3 ff ff       	call   804a744 <__printk_hook_install>
 804e361:	83 c4 10             	add    $0x10,%esp
#if defined(CONFIG_NATIVE_POSIX_STDOUT_CONSOLE)
	native_posix_stdout_init();
#endif

	return 0;
}
 804e364:	31 c0                	xor    %eax,%eax
 804e366:	c9                   	leave  
 804e367:	c3                   	ret    

0804e368 <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
 804e368:	f3 0f 1e fb          	endbr32 
 804e36c:	55                   	push   %ebp
 804e36d:	89 e5                	mov    %esp,%ebp
 804e36f:	57                   	push   %edi
 804e370:	56                   	push   %esi
 804e371:	83 ec 10             	sub    $0x10,%esp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
 804e374:	e8 78 e3 ff ff       	call   804c6f1 <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
 804e379:	8b 35 10 6a 05 08    	mov    0x8056a10,%esi
 804e37f:	8b 3d 14 6a 05 08    	mov    0x8056a14,%edi
 804e385:	89 75 e8             	mov    %esi,-0x18(%ebp)
 804e388:	8b 35 18 6a 05 08    	mov    0x8056a18,%esi
 804e38e:	89 7d ec             	mov    %edi,-0x14(%ebp)
 804e391:	8b 3d 1c 6a 05 08    	mov    0x8056a1c,%edi
 804e397:	2b 45 e8             	sub    -0x18(%ebp),%eax
 804e39a:	1b 55 ec             	sbb    -0x14(%ebp),%edx
 804e39d:	89 75 f0             	mov    %esi,-0x10(%ebp)
 804e3a0:	57                   	push   %edi
 804e3a1:	56                   	push   %esi
 804e3a2:	52                   	push   %edx
 804e3a3:	50                   	push   %eax
 804e3a4:	89 7d f4             	mov    %edi,-0xc(%ebp)
 804e3a7:	e8 74 af ff ff       	call   8049320 <__udivdi3@plt>

	last_tick_time += elapsed_ticks*tick_period;
 804e3ac:	8b 7d f4             	mov    -0xc(%ebp),%edi
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
 804e3af:	83 c4 10             	add    $0x10,%esp
 804e3b2:	89 c1                	mov    %eax,%ecx
	last_tick_time += elapsed_ticks*tick_period;
 804e3b4:	99                   	cltd   
 804e3b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804e3b8:	0f af f9             	imul   %ecx,%edi
	sys_clock_announce(elapsed_ticks);
 804e3bb:	89 4d 08             	mov    %ecx,0x8(%ebp)
	last_tick_time += elapsed_ticks*tick_period;
 804e3be:	0f af c2             	imul   %edx,%eax
 804e3c1:	01 c7                	add    %eax,%edi
 804e3c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804e3c6:	f7 e1                	mul    %ecx
 804e3c8:	01 fa                	add    %edi,%edx
 804e3ca:	03 45 e8             	add    -0x18(%ebp),%eax
 804e3cd:	13 55 ec             	adc    -0x14(%ebp),%edx
 804e3d0:	a3 10 6a 05 08       	mov    %eax,0x8056a10
 804e3d5:	89 15 14 6a 05 08    	mov    %edx,0x8056a14
}
 804e3db:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804e3de:	5e                   	pop    %esi
 804e3df:	5f                   	pop    %edi
 804e3e0:	5d                   	pop    %ebp
	sys_clock_announce(elapsed_ticks);
 804e3e1:	e9 8d 1e 00 00       	jmp    8050273 <sys_clock_announce>

0804e3e6 <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
static int sys_clock_driver_init(const struct device *dev)
{
 804e3e6:	f3 0f 1e fb          	endbr32 
 804e3ea:	55                   	push   %ebp
 804e3eb:	89 e5                	mov    %esp,%ebp
 804e3ed:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(dev);

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
 804e3f0:	c7 05 18 6a 05 08 10 	movl   $0x2710,0x8056a18
 804e3f7:	27 00 00 
 804e3fa:	c7 05 1c 6a 05 08 00 	movl   $0x0,0x8056a1c
 804e401:	00 00 00 

	last_tick_time = hwm_get_time();
 804e404:	e8 e8 e2 ff ff       	call   804c6f1 <hwm_get_time>
 804e409:	89 15 14 6a 05 08    	mov    %edx,0x8056a14
	hwtimer_enable(tick_period);
 804e40f:	52                   	push   %edx
 804e410:	52                   	push   %edx
 804e411:	ff 35 1c 6a 05 08    	pushl  0x8056a1c
 804e417:	ff 35 18 6a 05 08    	pushl  0x8056a18
	last_tick_time = hwm_get_time();
 804e41d:	a3 10 6a 05 08       	mov    %eax,0x8056a10
	hwtimer_enable(tick_period);
 804e422:	e8 d6 e6 ff ff       	call   804cafd <hwtimer_enable>
 804e427:	83 c4 10             	add    $0x10,%esp

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
 804e42a:	6a 00                	push   $0x0
 804e42c:	68 68 e3 04 08       	push   $0x804e368
 804e431:	6a 00                	push   $0x0
 804e433:	6a 00                	push   $0x0
 804e435:	e8 90 ea ff ff       	call   804ceca <posix_isr_declare>
 804e43a:	83 c4 0c             	add    $0xc,%esp
 804e43d:	6a 00                	push   $0x0
 804e43f:	6a 01                	push   $0x1
 804e441:	6a 00                	push   $0x0
 804e443:	e8 b1 ea ff ff       	call   804cef9 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
 804e448:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804e44f:	e8 44 d8 ff ff       	call   804bc98 <arch_irq_enable>
 804e454:	83 c4 10             	add    $0x10,%esp

	return 0;
}
 804e457:	31 c0                	xor    %eax,%eax
 804e459:	c9                   	leave  
 804e45a:	c3                   	ret    

0804e45b <sys_clock_cycle_get_32>:
{
 804e45b:	f3 0f 1e fb          	endbr32 
 804e45f:	55                   	push   %ebp
 804e460:	89 e5                	mov    %esp,%ebp
 804e462:	83 ec 08             	sub    $0x8,%esp
	return hwm_get_time();
 804e465:	e8 87 e2 ff ff       	call   804c6f1 <hwm_get_time>
}
 804e46a:	c9                   	leave  
 804e46b:	c3                   	ret    

0804e46c <sys_clock_set_timeout>:
{
 804e46c:	f3 0f 1e fb          	endbr32 
 804e470:	55                   	push   %ebp
		silent_ticks = INT64_MAX;
 804e471:	83 c9 ff             	or     $0xffffffff,%ecx
{
 804e474:	89 e5                	mov    %esp,%ebp
 804e476:	53                   	push   %ebx
		silent_ticks = INT64_MAX;
 804e477:	bb ff ff ff 7f       	mov    $0x7fffffff,%ebx
{
 804e47c:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ticks == K_TICKS_FOREVER) {
 804e47f:	83 f8 ff             	cmp    $0xffffffff,%eax
 804e482:	74 10                	je     804e494 <sys_clock_set_timeout+0x28>
		silent_ticks = 0;
 804e484:	31 c9                	xor    %ecx,%ecx
 804e486:	31 db                	xor    %ebx,%ebx
	} else if (ticks > 0) {
 804e488:	85 c0                	test   %eax,%eax
 804e48a:	7e 08                	jle    804e494 <sys_clock_set_timeout+0x28>
		silent_ticks = ticks - 1;
 804e48c:	48                   	dec    %eax
 804e48d:	89 c3                	mov    %eax,%ebx
 804e48f:	89 c1                	mov    %eax,%ecx
 804e491:	c1 fb 1f             	sar    $0x1f,%ebx
	hwtimer_set_silent_ticks(silent_ticks);
 804e494:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
 804e497:	5b                   	pop    %ebx
	hwtimer_set_silent_ticks(silent_ticks);
 804e498:	89 4d 08             	mov    %ecx,0x8(%ebp)
}
 804e49b:	5d                   	pop    %ebp
	hwtimer_set_silent_ticks(silent_ticks);
 804e49c:	e9 7f e8 ff ff       	jmp    804cd20 <hwtimer_set_silent_ticks>

0804e4a1 <sys_clock_elapsed>:
{
 804e4a1:	f3 0f 1e fb          	endbr32 
 804e4a5:	55                   	push   %ebp
 804e4a6:	89 e5                	mov    %esp,%ebp
 804e4a8:	83 ec 08             	sub    $0x8,%esp
	return (hwm_get_time() - last_tick_time)/tick_period;
 804e4ab:	e8 41 e2 ff ff       	call   804c6f1 <hwm_get_time>
 804e4b0:	2b 05 10 6a 05 08    	sub    0x8056a10,%eax
 804e4b6:	1b 15 14 6a 05 08    	sbb    0x8056a14,%edx
 804e4bc:	ff 35 1c 6a 05 08    	pushl  0x8056a1c
 804e4c2:	ff 35 18 6a 05 08    	pushl  0x8056a18
 804e4c8:	52                   	push   %edx
 804e4c9:	50                   	push   %eax
 804e4ca:	e8 51 ae ff ff       	call   8049320 <__udivdi3@plt>
 804e4cf:	83 c4 10             	add    $0x10,%esp
}
 804e4d2:	c9                   	leave  
 804e4d3:	c3                   	ret    

0804e4d4 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
 804e4d4:	55                   	push   %ebp
 804e4d5:	89 e5                	mov    %esp,%ebp
 804e4d7:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
 804e4da:	8d 45 24             	lea    0x24(%ebp),%eax
		va_end(parm7.val);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, package_flags, fmt, ap);
 804e4dd:	50                   	push   %eax
 804e4de:	ff 75 20             	pushl  0x20(%ebp)
 804e4e1:	6a 00                	push   $0x0
 804e4e3:	6a 00                	push   $0x0
 804e4e5:	6a 00                	push   $0x0
 804e4e7:	6a 01                	push   $0x1
 804e4e9:	ff 75 0c             	pushl  0xc(%ebp)
 804e4ec:	6a 00                	push   $0x0
 804e4ee:	e8 18 d5 ff ff       	call   804ba0b <z_impl_z_log_msg2_runtime_vcreate>
 804e4f3:	83 c4 20             	add    $0x20,%esp
}
 804e4f6:	c9                   	leave  
 804e4f7:	c3                   	ret    

0804e4f8 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
 804e4f8:	f3 0f 1e fb          	endbr32 
 804e4fc:	55                   	push   %ebp
 804e4fd:	89 e5                	mov    %esp,%ebp
 804e4ff:	83 ec 08             	sub    $0x8,%esp
 804e502:	e8 1a ce ff ff       	call   804b321 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
 804e507:	52                   	push   %edx
 804e508:	68 c6 2c 05 08       	push   $0x8052cc6
 804e50d:	6a 00                	push   $0x0
 804e50f:	6a 00                	push   $0x0
 804e511:	6a 00                	push   $0x0
 804e513:	6a 01                	push   $0x1
 804e515:	68 d0 61 05 08       	push   $0x80561d0
 804e51a:	6a 00                	push   $0x0
 804e51c:	e8 b3 ff ff ff       	call   804e4d4 <z_log_msg2_runtime_create.constprop.0>
 804e521:	83 c4 14             	add    $0x14,%esp
	arch_system_halt(reason);
 804e524:	ff 75 08             	pushl  0x8(%ebp)
 804e527:	e8 41 d7 ff ff       	call   804bc6d <arch_system_halt>

0804e52c <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 804e52c:	f3 0f 1e fb          	endbr32 
 804e530:	55                   	push   %ebp
 804e531:	89 e5                	mov    %esp,%ebp
 804e533:	57                   	push   %edi
 804e534:	56                   	push   %esi
 804e535:	53                   	push   %ebx
 804e536:	83 ec 1c             	sub    $0x1c,%esp
 804e539:	8b 75 08             	mov    0x8(%ebp),%esi
 804e53c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
 804e53f:	e8 48 e9 ff ff       	call   804ce8c <posix_irq_lock>
 804e544:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return z_impl_z_current_get();
 804e547:	e8 0d 14 00 00       	call   804f959 <z_impl_z_current_get>
 804e54c:	89 c3                	mov    %eax,%ebx
	switch (reason) {
 804e54e:	b8 d5 2c 05 08       	mov    $0x8052cd5,%eax
 804e553:	83 fe 04             	cmp    $0x4,%esi
 804e556:	77 07                	ja     804e55f <z_fatal_error+0x33>
 804e558:	8b 04 b5 04 13 05 08 	mov    0x8051304(,%esi,4),%eax
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 804e55f:	52                   	push   %edx
 804e560:	52                   	push   %edx
 804e561:	6a 00                	push   $0x0
 804e563:	50                   	push   %eax
 804e564:	56                   	push   %esi
 804e565:	68 eb 2c 05 08       	push   $0x8052ceb
 804e56a:	6a 00                	push   $0x0
 804e56c:	6a 00                	push   $0x0
 804e56e:	6a 00                	push   $0x0
 804e570:	6a 01                	push   $0x1
 804e572:	68 d0 61 05 08       	push   $0x80561d0
 804e577:	6a 00                	push   $0x0
 804e579:	e8 56 ff ff ff       	call   804e4d4 <z_log_msg2_runtime_create.constprop.0>
 804e57e:	83 c4 30             	add    $0x30,%esp
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
 804e581:	85 db                	test   %ebx,%ebx
 804e583:	74 15                	je     804e59a <z_fatal_error+0x6e>
 804e585:	83 ec 0c             	sub    $0xc,%esp
 804e588:	53                   	push   %ebx
 804e589:	e8 a5 02 00 00       	call   804e833 <k_thread_name_get>
 804e58e:	83 c4 10             	add    $0x10,%esp
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
 804e591:	85 c0                	test   %eax,%eax
 804e593:	74 05                	je     804e59a <z_fatal_error+0x6e>
 804e595:	80 38 00             	cmpb   $0x0,(%eax)
 804e598:	75 05                	jne    804e59f <z_fatal_error+0x73>
		thread_name = "unknown";
 804e59a:	b8 e3 2c 05 08       	mov    $0x8052ce3,%eax
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
 804e59f:	83 ec 0c             	sub    $0xc,%esp
 804e5a2:	50                   	push   %eax
 804e5a3:	53                   	push   %ebx
 804e5a4:	68 13 2d 05 08       	push   $0x8052d13
 804e5a9:	6a 00                	push   $0x0
 804e5ab:	6a 00                	push   $0x0
 804e5ad:	6a 00                	push   $0x0
 804e5af:	6a 01                	push   $0x1
 804e5b1:	68 d0 61 05 08       	push   $0x80561d0
 804e5b6:	6a 00                	push   $0x0
 804e5b8:	e8 17 ff ff ff       	call   804e4d4 <z_log_msg2_runtime_create.constprop.0>
 804e5bd:	83 c4 28             	add    $0x28,%esp
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
 804e5c0:	57                   	push   %edi
 804e5c1:	56                   	push   %esi
 804e5c2:	e8 31 ff ff ff       	call   804e4f8 <k_sys_fatal_error_handler>
 804e5c7:	58                   	pop    %eax
	posix_irq_unlock(key);
 804e5c8:	ff 75 e4             	pushl  -0x1c(%ebp)
 804e5cb:	e8 d2 e8 ff ff       	call   804cea2 <posix_irq_unlock>
 804e5d0:	83 c4 10             	add    $0x10,%esp
	z_impl_k_thread_abort(thread);
 804e5d3:	89 5d 08             	mov    %ebx,0x8(%ebp)
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
 804e5d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804e5d9:	5b                   	pop    %ebx
 804e5da:	5e                   	pop    %esi
 804e5db:	5f                   	pop    %edi
 804e5dc:	5d                   	pop    %ebp
 804e5dd:	e9 bb da ff ff       	jmp    804c09d <z_impl_k_thread_abort>

0804e5e2 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
 804e5e2:	f3 0f 1e fb          	endbr32 
 804e5e6:	55                   	push   %ebp
 804e5e7:	89 e5                	mov    %esp,%ebp
 804e5e9:	83 ec 14             	sub    $0x14,%esp
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
 804e5ec:	c6 05 f2 6a 05 08 01 	movb   $0x1,0x8056af2

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
 804e5f3:	6a 02                	push   $0x2
 804e5f5:	e8 14 1f 00 00       	call   805050e <z_sys_init_run_level>
 804e5fa:	83 c4 10             	add    $0x10,%esp
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
 804e5fd:	e8 e4 1e 00 00       	call   80504e6 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
 804e602:	83 ec 0c             	sub    $0xc,%esp
 804e605:	6a 03                	push   $0x3
 804e607:	e8 02 1f 00 00       	call   805050e <z_sys_init_run_level>
 804e60c:	83 c4 10             	add    $0x10,%esp

	z_init_static_threads();
 804e60f:	e8 ee 03 00 00       	call   804ea02 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern void main(void);

	main();
 804e614:	e8 ed fc ff ff       	call   804e306 <zephyr_app_main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
 804e619:	80 25 ec 68 05 08 fe 	andb   $0xfe,0x80568ec

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 804e620:	c9                   	leave  
 804e621:	c3                   	ret    

0804e622 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
 804e622:	f3 0f 1e fb          	endbr32 
 804e626:	55                   	push   %ebp
 804e627:	89 e5                	mov    %esp,%ebp
 804e629:	57                   	push   %edi
 804e62a:	56                   	push   %esi
 804e62b:	53                   	push   %ebx
 804e62c:	83 ec 14             	sub    $0x14,%esp
 804e62f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	z_setup_new_thread(thread, stack,
 804e632:	68 75 2d 05 08       	push   $0x8052d75
	struct k_thread *thread = &z_idle_threads[i];
 804e637:	6b fb 70             	imul   $0x70,%ebx,%edi
	k_thread_stack_t *stack = z_idle_stacks[i];
 804e63a:	89 d8                	mov    %ebx,%eax
	z_setup_new_thread(thread, stack,
 804e63c:	6a 01                	push   $0x1
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 804e63e:	6b f3 18             	imul   $0x18,%ebx,%esi
	k_thread_stack_t *stack = z_idle_stacks[i];
 804e641:	c1 e0 08             	shl    $0x8,%eax
	z_setup_new_thread(thread, stack,
 804e644:	6a 0f                	push   $0xf
	k_thread_stack_t *stack = z_idle_stacks[i];
 804e646:	05 9c 5e 05 08       	add    $0x8055e9c,%eax
	z_setup_new_thread(thread, stack,
 804e64b:	6a 00                	push   $0x0
	struct k_thread *thread = &z_idle_threads[i];
 804e64d:	81 c7 60 68 05 08    	add    $0x8056860,%edi
	z_setup_new_thread(thread, stack,
 804e653:	6a 00                	push   $0x0
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 804e655:	81 c6 60 69 05 08    	add    $0x8056960,%esi
	z_setup_new_thread(thread, stack,
 804e65b:	56                   	push   %esi
 804e65c:	68 a9 eb 04 08       	push   $0x804eba9
 804e661:	68 00 01 00 00       	push   $0x100
 804e666:	50                   	push   %eax
 804e667:	57                   	push   %edi
 804e668:	e8 de 01 00 00       	call   804e84b <z_setup_new_thread>
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
 804e66d:	88 5e 14             	mov    %bl,0x14(%esi)
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 804e670:	c1 e3 0b             	shl    $0xb,%ebx
	z_setup_new_thread(thread, stack,
 804e673:	83 c4 30             	add    $0x30,%esp
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 804e676:	8d 83 9c 5e 05 08    	lea    0x8055e9c(%ebx),%eax
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
 804e67c:	80 67 0d fb          	andb   $0xfb,0xd(%edi)
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 804e680:	89 7e 0c             	mov    %edi,0xc(%esi)
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 804e683:	89 46 04             	mov    %eax,0x4(%esi)
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
 804e686:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804e689:	5b                   	pop    %ebx
 804e68a:	5e                   	pop    %esi
 804e68b:	5f                   	pop    %edi
 804e68c:	5d                   	pop    %ebp
 804e68d:	c3                   	ret    

0804e68e <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
 804e68e:	f3 0f 1e fb          	endbr32 
 804e692:	55                   	push   %ebp
 804e693:	89 e5                	mov    %esp,%ebp
 804e695:	53                   	push   %ebx
 804e696:	81 ec 84 00 00 00    	sub    $0x84,%esp
 804e69c:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804e6a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804e6a5:	31 c0                	xor    %eax,%eax
	gcov_static_init();

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
 804e6a7:	e8 8b cb ff ff       	call   804b237 <log_core_init>
	k_thread_system_pool_assign(dummy_thread);
#else
	dummy_thread->resource_pool = NULL;
#endif

	_current_cpu->current = dummy_thread;
 804e6ac:	8d 45 84             	lea    -0x7c(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
 804e6af:	66 c7 45 90 01 01    	movw   $0x101,-0x70(%ebp)
	_current_cpu->current = dummy_thread;
 804e6b5:	a3 68 69 05 08       	mov    %eax,0x8056968
	dummy_thread->resource_pool = NULL;
 804e6ba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
 804e6c1:	e8 43 1e 00 00       	call   8050509 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
 804e6c6:	83 ec 0c             	sub    $0xc,%esp
 804e6c9:	6a 00                	push   $0x0
 804e6cb:	e8 3e 1e 00 00       	call   805050e <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
 804e6d0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804e6d7:	e8 32 1e 00 00       	call   805050e <z_sys_init_run_level>
 804e6dc:	83 c4 10             	add    $0x10,%esp
	z_sched_init();
 804e6df:	e8 49 12 00 00       	call   804f92d <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
 804e6e4:	c7 05 78 69 05 08 e0 	movl   $0x80568e0,0x8056978
 804e6eb:	68 05 08 
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 804e6ee:	50                   	push   %eax
 804e6ef:	50                   	push   %eax
 804e6f0:	68 7a 2d 05 08       	push   $0x8052d7a
 804e6f5:	6a 01                	push   $0x1
 804e6f7:	6a 00                	push   $0x0
 804e6f9:	6a 00                	push   $0x0
 804e6fb:	6a 00                	push   $0x0
 804e6fd:	6a 00                	push   $0x0
 804e6ff:	68 e2 e5 04 08       	push   $0x804e5e2
 804e704:	68 00 02 00 00       	push   $0x200
 804e709:	68 9c 5f 05 08       	push   $0x8055f9c
 804e70e:	68 e0 68 05 08       	push   $0x80568e0
 804e713:	e8 33 01 00 00       	call   804e84b <z_setup_new_thread>
 804e718:	83 c4 24             	add    $0x24,%esp
 804e71b:	80 25 ed 68 05 08 fb 	andb   $0xfb,0x80568ed
	z_ready_thread(&z_main_thread);
 804e722:	68 e0 68 05 08       	push   $0x80568e0
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 804e727:	89 c3                	mov    %eax,%ebx
	z_ready_thread(&z_main_thread);
 804e729:	e8 ea 0c 00 00       	call   804f418 <z_ready_thread>
	z_init_cpu(0);
 804e72e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804e735:	e8 e8 fe ff ff       	call   804e622 <z_init_cpu>
 804e73a:	83 c4 0c             	add    $0xc,%esp
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 804e73d:	68 e2 e5 04 08       	push   $0x804e5e2
 804e742:	53                   	push   %ebx
 804e743:	68 e0 68 05 08       	push   $0x80568e0
 804e748:	e8 2f da ff ff       	call   804c17c <arch_switch_to_main_thread>
 804e74d:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 804e750:	68 69 01 00 00       	push   $0x169
 804e755:	68 7f 2d 05 08       	push   $0x8052d7f
 804e75a:	68 c9 1c 05 08       	push   $0x8051cc9
 804e75f:	e8 da eb ff ff       	call   804d33e <posix_print_error_and_exit>
 804e764:	83 c4 10             	add    $0x10,%esp

0804e767 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(const struct device *dev)
{
 804e767:	f3 0f 1e fb          	endbr32 
 804e76b:	55                   	push   %ebp
 804e76c:	89 e5                	mov    %esp,%ebp
 804e76e:	57                   	push   %edi
 804e76f:	56                   	push   %esi
 804e770:	53                   	push   %ebx
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 804e771:	bb e8 61 05 08       	mov    $0x80561e8,%ebx
{
 804e776:	83 ec 0c             	sub    $0xc,%esp
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 804e779:	81 fb e8 61 05 08    	cmp    $0x80561e8,%ebx
 804e77f:	76 33                	jbe    804e7b4 <init_mem_slab_module+0x4d>
 804e781:	6a 3d                	push   $0x3d
 804e783:	68 a3 2d 05 08       	push   $0x8052da3
 804e788:	68 c8 2d 05 08       	push   $0x8052dc8
 804e78d:	68 1c 1c 05 08       	push   $0x8051c1c
 804e792:	e8 a2 c9 ff ff       	call   804b139 <assert_print>
 804e797:	c7 04 24 e5 2d 05 08 	movl   $0x8052de5,(%esp)
 804e79e:	e8 96 c9 ff ff       	call   804b139 <assert_print>
 804e7a3:	58                   	pop    %eax
 804e7a4:	5a                   	pop    %edx
 804e7a5:	6a 3d                	push   $0x3d
 804e7a7:	68 a3 2d 05 08       	push   $0x8052da3
 804e7ac:	e8 a3 c9 ff ff       	call   804b154 <assert_post_action>
 804e7b1:	83 c4 10             	add    $0x10,%esp
 804e7b4:	81 fb e8 61 05 08    	cmp    $0x80561e8,%ebx
 804e7ba:	73 2f                	jae    804e7eb <init_mem_slab_module+0x84>
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
 804e7bc:	8b 53 14             	mov    0x14(%ebx),%edx
 804e7bf:	8b 4b 10             	mov    0x10(%ebx),%ecx
 804e7c2:	89 d0                	mov    %edx,%eax
 804e7c4:	09 c8                	or     %ecx,%eax
 804e7c6:	83 e0 03             	and    $0x3,%eax
 804e7c9:	75 24                	jne    804e7ef <init_mem_slab_module+0x88>
	slab->free_list = NULL;
 804e7cb:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
	for (j = 0U; j < slab->num_blocks; j++) {
 804e7d2:	8b 73 0c             	mov    0xc(%ebx),%esi
 804e7d5:	39 f0                	cmp    %esi,%eax
 804e7d7:	74 0d                	je     804e7e6 <init_mem_slab_module+0x7f>
		*(char **)p = slab->free_list;
 804e7d9:	8b 7b 18             	mov    0x18(%ebx),%edi
	for (j = 0U; j < slab->num_blocks; j++) {
 804e7dc:	40                   	inc    %eax
		*(char **)p = slab->free_list;
 804e7dd:	89 3a                	mov    %edi,(%edx)
		slab->free_list = p;
 804e7df:	89 53 18             	mov    %edx,0x18(%ebx)
		p += slab->block_size;
 804e7e2:	01 ca                	add    %ecx,%edx
	for (j = 0U; j < slab->num_blocks; j++) {
 804e7e4:	eb ef                	jmp    804e7d5 <init_mem_slab_module+0x6e>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 804e7e6:	83 c3 20             	add    $0x20,%ebx
 804e7e9:	eb 8e                	jmp    804e779 <init_mem_slab_module+0x12>
			goto out;
		}
		z_object_init(slab);
	}

out:
 804e7eb:	31 c0                	xor    %eax,%eax
 804e7ed:	eb 09                	jmp    804e7f8 <init_mem_slab_module+0x91>
		return -EINVAL;
 804e7ef:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	return rc;
 804e7f4:	f3 0f 1e fb          	endbr32 
}
 804e7f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804e7fb:	5b                   	pop    %ebx
 804e7fc:	5e                   	pop    %esi
 804e7fd:	5f                   	pop    %edi
 804e7fe:	5d                   	pop    %ebp
 804e7ff:	c3                   	ret    

0804e800 <z_impl_k_thread_name_set>:
	k_spin_unlock(&z_thread_monitor_lock, key);
}
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
 804e800:	f3 0f 1e fb          	endbr32 
 804e804:	55                   	push   %ebp
 804e805:	89 e5                	mov    %esp,%ebp
 804e807:	53                   	push   %ebx
 804e808:	52                   	push   %edx
 804e809:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
 804e80c:	85 db                	test   %ebx,%ebx
 804e80e:	75 06                	jne    804e816 <z_impl_k_thread_name_set+0x16>
		thread = _current;
 804e810:	8b 1d 68 69 05 08    	mov    0x8056968,%ebx

__fortify_function char *
__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));
 804e816:	50                   	push   %eax
 804e817:	8d 43 44             	lea    0x44(%ebx),%eax
 804e81a:	6a 1f                	push   $0x1f
 804e81c:	ff 75 0c             	pushl  0xc(%ebp)
 804e81f:	50                   	push   %eax
 804e820:	e8 7b ac ff ff       	call   80494a0 <strncpy@plt>
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN - 1);
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 804e825:	c6 43 63 00          	movb   $0x0,0x63(%ebx)
 804e829:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
 804e82c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804e82f:	c9                   	leave  
 804e830:	31 c0                	xor    %eax,%eax
 804e832:	c3                   	ret    

0804e833 <k_thread_name_get>:
}
#include <syscalls/k_thread_name_set_mrsh.c>
#endif /* CONFIG_USERSPACE */

const char *k_thread_name_get(struct k_thread *thread)
{
 804e833:	f3 0f 1e fb          	endbr32 
 804e837:	55                   	push   %ebp
 804e838:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_THREAD_NAME
	return (const char *)thread->name;
 804e83a:	8b 45 08             	mov    0x8(%ebp),%eax
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
 804e83d:	5d                   	pop    %ebp
	return (const char *)thread->name;
 804e83e:	83 c0 44             	add    $0x44,%eax
}
 804e841:	c3                   	ret    

0804e842 <z_impl_k_thread_start>:
	}
}
#endif /* CONFIG_STACK_SENTINEL */

void z_impl_k_thread_start(struct k_thread *thread)
{
 804e842:	f3 0f 1e fb          	endbr32 
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
 804e846:	e9 a9 0c 00 00       	jmp    804f4f4 <z_sched_start>

0804e84b <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
 804e84b:	f3 0f 1e fb          	endbr32 
 804e84f:	55                   	push   %ebp
 804e850:	89 e5                	mov    %esp,%ebp
 804e852:	57                   	push   %edi
 804e853:	56                   	push   %esi
 804e854:	53                   	push   %ebx
 804e855:	83 ec 0c             	sub    $0xc,%esp
 804e858:	8b 7d 08             	mov    0x8(%ebp),%edi
 804e85b:	8b 5d 24             	mov    0x24(%ebp),%ebx
 804e85e:	8b 75 2c             	mov    0x2c(%ebp),%esi
	char *stack_ptr;

	Z_ASSERT_VALID_PRIO(prio, entry);
 804e861:	81 7d 14 a9 eb 04 08 	cmpl   $0x804eba9,0x14(%ebp)
 804e868:	75 05                	jne    804e86f <z_setup_new_thread+0x24>
 804e86a:	83 fb 0f             	cmp    $0xf,%ebx
 804e86d:	74 47                	je     804e8b6 <z_setup_new_thread+0x6b>
 804e86f:	8d 43 10             	lea    0x10(%ebx),%eax
 804e872:	83 f8 1e             	cmp    $0x1e,%eax
 804e875:	76 3f                	jbe    804e8b6 <z_setup_new_thread+0x6b>
 804e877:	68 18 02 00 00       	push   $0x218
 804e87c:	68 04 2e 05 08       	push   $0x8052e04
 804e881:	68 27 2e 05 08       	push   $0x8052e27
 804e886:	68 1c 1c 05 08       	push   $0x8051c1c
 804e88b:	e8 a9 c8 ff ff       	call   804b139 <assert_print>
 804e890:	83 c4 10             	add    $0x10,%esp
 804e893:	6a f0                	push   $0xfffffff0
 804e895:	6a 0e                	push   $0xe
 804e897:	53                   	push   %ebx
 804e898:	68 a7 2e 05 08       	push   $0x8052ea7
 804e89d:	e8 97 c8 ff ff       	call   804b139 <assert_print>
 804e8a2:	59                   	pop    %ecx
 804e8a3:	58                   	pop    %eax
 804e8a4:	68 18 02 00 00       	push   $0x218
 804e8a9:	68 04 2e 05 08       	push   $0x8052e04
 804e8ae:	e8 a1 c8 ff ff       	call   804b154 <assert_post_action>
 804e8b3:	83 c4 10             	add    $0x10,%esp
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
 804e8b6:	8d 47 3c             	lea    0x3c(%edi),%eax
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
	thread_base->thread_state = (uint8_t)initial_state;

	thread_base->prio = priority;
 804e8b9:	88 5f 0e             	mov    %bl,0xe(%edi)
 * @param list the doubly-linked list
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
 804e8bc:	89 47 3c             	mov    %eax,0x3c(%edi)
	list->tail = (sys_dnode_t *)list;
 804e8bf:	89 47 40             	mov    %eax,0x40(%edi)
	thread_base->user_options = (uint8_t)options;
 804e8c2:	8b 45 28             	mov    0x28(%ebp),%eax
	thread_base->pended_on = NULL;
 804e8c5:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
	thread_base->user_options = (uint8_t)options;
 804e8cc:	88 47 0c             	mov    %al,0xc(%edi)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
 804e8cf:	8b 45 10             	mov    0x10(%ebp),%eax
	thread_base->thread_state = (uint8_t)initial_state;
 804e8d2:	c6 47 0d 04          	movb   $0x4,0xd(%edi)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
 804e8d6:	8d 58 03             	lea    0x3(%eax),%ebx

	thread_base->sched_locked = 0U;
 804e8d9:	c6 47 0f 00          	movb   $0x0,0xf(%edi)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
 804e8dd:	83 e3 fc             	and    $0xfffffffc,%ebx
	stack_ptr = (char *)stack + stack_obj_size;
 804e8e0:	03 5d 0c             	add    0xc(%ebp),%ebx
 * @param node the node
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
 804e8e3:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%edi)
	node->prev = NULL;
 804e8ea:	c7 47 1c 00 00 00 00 	movl   $0x0,0x1c(%edi)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 804e8f1:	52                   	push   %edx
 804e8f2:	ff 75 20             	pushl  0x20(%ebp)
 804e8f5:	ff 75 1c             	pushl  0x1c(%ebp)
 804e8f8:	ff 75 18             	pushl  0x18(%ebp)
 804e8fb:	ff 75 14             	pushl  0x14(%ebp)
 804e8fe:	53                   	push   %ebx
 804e8ff:	ff 75 0c             	pushl  0xc(%ebp)
 804e902:	57                   	push   %edi
 804e903:	e8 94 d8 ff ff       	call   804c19c <arch_new_thread>
	new_thread->init_data = NULL;
 804e908:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 804e90f:	83 c4 20             	add    $0x20,%esp
	if (name != NULL) {
 804e912:	85 f6                	test   %esi,%esi
 804e914:	74 16                	je     804e92c <z_setup_new_thread+0xe1>
 804e916:	50                   	push   %eax
 804e917:	8d 47 44             	lea    0x44(%edi),%eax
 804e91a:	6a 1f                	push   $0x1f
 804e91c:	56                   	push   %esi
 804e91d:	50                   	push   %eax
 804e91e:	e8 7d ab ff ff       	call   80494a0 <strncpy@plt>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 804e923:	c6 47 63 00          	movb   $0x0,0x63(%edi)
 804e927:	83 c4 10             	add    $0x10,%esp
 804e92a:	eb 04                	jmp    804e930 <z_setup_new_thread+0xe5>
		new_thread->name[0] = '\0';
 804e92c:	c6 47 44 00          	movb   $0x0,0x44(%edi)
	if (!_current) {
 804e930:	a1 68 69 05 08       	mov    0x8056968,%eax
 804e935:	85 c0                	test   %eax,%eax
 804e937:	74 03                	je     804e93c <z_setup_new_thread+0xf1>
	new_thread->resource_pool = _current->resource_pool;
 804e939:	8b 40 68             	mov    0x68(%eax),%eax
	return stack_ptr;
 804e93c:	89 47 68             	mov    %eax,0x68(%edi)
}
 804e93f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804e942:	89 d8                	mov    %ebx,%eax
 804e944:	5b                   	pop    %ebx
 804e945:	5e                   	pop    %esi
 804e946:	5f                   	pop    %edi
 804e947:	5d                   	pop    %ebp
 804e948:	c3                   	ret    

0804e949 <z_impl_k_thread_create>:
{
 804e949:	f3 0f 1e fb          	endbr32 
 804e94d:	55                   	push   %ebp
 804e94e:	89 e5                	mov    %esp,%ebp
 804e950:	57                   	push   %edi
 804e951:	56                   	push   %esi
 804e952:	53                   	push   %ebx
 804e953:	83 ec 0c             	sub    $0xc,%esp
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
 804e956:	83 3d 60 69 05 08 00 	cmpl   $0x0,0x8056960
{
 804e95d:	8b 75 08             	mov    0x8(%ebp),%esi
 804e960:	8b 7d 2c             	mov    0x2c(%ebp),%edi
 804e963:	8b 5d 30             	mov    0x30(%ebp),%ebx
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
 804e966:	74 39                	je     804e9a1 <z_impl_k_thread_create+0x58>
 804e968:	68 87 02 00 00       	push   $0x287
 804e96d:	68 04 2e 05 08       	push   $0x8052e04
 804e972:	68 d8 2e 05 08       	push   $0x8052ed8
 804e977:	68 1c 1c 05 08       	push   $0x8051c1c
 804e97c:	e8 b8 c7 ff ff       	call   804b139 <assert_print>
 804e981:	c7 04 24 ea 2e 05 08 	movl   $0x8052eea,(%esp)
 804e988:	e8 ac c7 ff ff       	call   804b139 <assert_print>
 804e98d:	5a                   	pop    %edx
 804e98e:	59                   	pop    %ecx
 804e98f:	68 87 02 00 00       	push   $0x287
 804e994:	68 04 2e 05 08       	push   $0x8052e04
 804e999:	e8 b6 c7 ff ff       	call   804b154 <assert_post_action>
 804e99e:	83 c4 10             	add    $0x10,%esp
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 804e9a1:	50                   	push   %eax
 804e9a2:	50                   	push   %eax
 804e9a3:	6a 00                	push   $0x0
 804e9a5:	ff 75 28             	pushl  0x28(%ebp)
 804e9a8:	ff 75 24             	pushl  0x24(%ebp)
 804e9ab:	ff 75 20             	pushl  0x20(%ebp)
 804e9ae:	ff 75 1c             	pushl  0x1c(%ebp)
 804e9b1:	ff 75 18             	pushl  0x18(%ebp)
 804e9b4:	ff 75 14             	pushl  0x14(%ebp)
 804e9b7:	ff 75 10             	pushl  0x10(%ebp)
 804e9ba:	ff 75 0c             	pushl  0xc(%ebp)
 804e9bd:	56                   	push   %esi
 804e9be:	e8 88 fe ff ff       	call   804e84b <z_setup_new_thread>
 804e9c3:	83 c4 30             	add    $0x30,%esp
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
 804e9c6:	89 fa                	mov    %edi,%edx
 804e9c8:	89 d8                	mov    %ebx,%eax
 804e9ca:	83 fb ff             	cmp    $0xffffffff,%ebx
 804e9cd:	75 05                	jne    804e9d4 <z_impl_k_thread_create+0x8b>
 804e9cf:	83 ff ff             	cmp    $0xffffffff,%edi
 804e9d2:	74 24                	je     804e9f8 <z_impl_k_thread_create+0xaf>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 804e9d4:	89 c3                	mov    %eax,%ebx
 804e9d6:	09 d3                	or     %edx,%ebx
 804e9d8:	75 0b                	jne    804e9e5 <z_impl_k_thread_create+0x9c>
	z_sched_start(thread);
 804e9da:	83 ec 0c             	sub    $0xc,%esp
 804e9dd:	56                   	push   %esi
 804e9de:	e8 11 0b 00 00       	call   804f4f4 <z_sched_start>
 804e9e3:	eb 10                	jmp    804e9f5 <z_impl_k_thread_create+0xac>

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 804e9e5:	50                   	push   %eax
 804e9e6:	8d 46 18             	lea    0x18(%esi),%eax
 804e9e9:	52                   	push   %edx
 804e9ea:	68 f4 f5 04 08       	push   $0x804f5f4
 804e9ef:	50                   	push   %eax
 804e9f0:	e8 2e 14 00 00       	call   804fe23 <z_add_timeout>
 804e9f5:	83 c4 10             	add    $0x10,%esp
}
 804e9f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804e9fb:	89 f0                	mov    %esi,%eax
 804e9fd:	5b                   	pop    %ebx
 804e9fe:	5e                   	pop    %esi
 804e9ff:	5f                   	pop    %edi
 804ea00:	5d                   	pop    %ebp
 804ea01:	c3                   	ret    

0804ea02 <z_init_static_threads>:
{
 804ea02:	f3 0f 1e fb          	endbr32 
 804ea06:	55                   	push   %ebp
 804ea07:	89 e5                	mov    %esp,%ebp
 804ea09:	56                   	push   %esi
 804ea0a:	53                   	push   %ebx
	_FOREACH_STATIC_THREAD(thread_data) {
 804ea0b:	bb e8 61 05 08       	mov    $0x80561e8,%ebx
 804ea10:	81 fb e8 61 05 08    	cmp    $0x80561e8,%ebx
 804ea16:	76 39                	jbe    804ea51 <z_init_static_threads+0x4f>
 804ea18:	68 ee 02 00 00       	push   $0x2ee
 804ea1d:	68 04 2e 05 08       	push   $0x8052e04
 804ea22:	68 0f 2f 05 08       	push   $0x8052f0f
 804ea27:	68 1c 1c 05 08       	push   $0x8051c1c
 804ea2c:	e8 08 c7 ff ff       	call   804b139 <assert_print>
 804ea31:	c7 04 24 e5 2d 05 08 	movl   $0x8052de5,(%esp)
 804ea38:	e8 fc c6 ff ff       	call   804b139 <assert_print>
 804ea3d:	59                   	pop    %ecx
 804ea3e:	5e                   	pop    %esi
 804ea3f:	68 ee 02 00 00       	push   $0x2ee
 804ea44:	68 04 2e 05 08       	push   $0x8052e04
 804ea49:	e8 06 c7 ff ff       	call   804b154 <assert_post_action>
 804ea4e:	83 c4 10             	add    $0x10,%esp
 804ea51:	81 fb e8 61 05 08    	cmp    $0x80561e8,%ebx
 804ea57:	73 31                	jae    804ea8a <z_init_static_threads+0x88>
		z_setup_new_thread(
 804ea59:	50                   	push   %eax
 804ea5a:	50                   	push   %eax
 804ea5b:	ff 73 2c             	pushl  0x2c(%ebx)
 804ea5e:	ff 73 20             	pushl  0x20(%ebx)
 804ea61:	ff 73 1c             	pushl  0x1c(%ebx)
 804ea64:	ff 73 18             	pushl  0x18(%ebx)
 804ea67:	ff 73 14             	pushl  0x14(%ebx)
 804ea6a:	ff 73 10             	pushl  0x10(%ebx)
 804ea6d:	ff 73 0c             	pushl  0xc(%ebx)
 804ea70:	ff 73 08             	pushl  0x8(%ebx)
 804ea73:	ff 73 04             	pushl  0x4(%ebx)
 804ea76:	ff 33                	pushl  (%ebx)
 804ea78:	e8 ce fd ff ff       	call   804e84b <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
 804ea7d:	8b 03                	mov    (%ebx),%eax
		z_setup_new_thread(
 804ea7f:	83 c4 30             	add    $0x30,%esp
		thread_data->init_thread->init_data = thread_data;
 804ea82:	89 58 38             	mov    %ebx,0x38(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
 804ea85:	83 c3 30             	add    $0x30,%ebx
 804ea88:	eb 86                	jmp    804ea10 <z_init_static_threads+0xe>
	k_sched_lock();
 804ea8a:	e8 f4 03 00 00       	call   804ee83 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
 804ea8f:	bb e8 61 05 08       	mov    $0x80561e8,%ebx
 804ea94:	81 fb e8 61 05 08    	cmp    $0x80561e8,%ebx
 804ea9a:	76 39                	jbe    804ead5 <z_init_static_threads+0xd3>
 804ea9c:	68 0d 03 00 00       	push   $0x30d
 804eaa1:	68 04 2e 05 08       	push   $0x8052e04
 804eaa6:	68 0f 2f 05 08       	push   $0x8052f0f
 804eaab:	68 1c 1c 05 08       	push   $0x8051c1c
 804eab0:	e8 84 c6 ff ff       	call   804b139 <assert_print>
 804eab5:	c7 04 24 e5 2d 05 08 	movl   $0x8052de5,(%esp)
 804eabc:	e8 78 c6 ff ff       	call   804b139 <assert_print>
 804eac1:	58                   	pop    %eax
 804eac2:	5a                   	pop    %edx
 804eac3:	68 0d 03 00 00       	push   $0x30d
 804eac8:	68 04 2e 05 08       	push   $0x8052e04
 804eacd:	e8 82 c6 ff ff       	call   804b154 <assert_post_action>
 804ead2:	83 c4 10             	add    $0x10,%esp
 804ead5:	81 fb e8 61 05 08    	cmp    $0x80561e8,%ebx
 804eadb:	73 58                	jae    804eb35 <z_init_static_threads+0x133>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
 804eadd:	8b 43 24             	mov    0x24(%ebx),%eax
 804eae0:	83 f8 ff             	cmp    $0xffffffff,%eax
 804eae3:	74 48                	je     804eb2d <z_init_static_threads+0x12b>
					    K_MSEC(thread_data->init_delay));
 804eae5:	85 c0                	test   %eax,%eax
 804eae7:	ba 00 00 00 00       	mov    $0x0,%edx
			schedule_new_thread(thread_data->init_thread,
 804eaec:	8b 33                	mov    (%ebx),%esi
					    K_MSEC(thread_data->init_delay));
 804eaee:	0f 48 c2             	cmovs  %edx,%eax
 804eaf1:	99                   	cltd   
		t += off;
 804eaf2:	83 c0 09             	add    $0x9,%eax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 804eaf5:	89 c1                	mov    %eax,%ecx
 804eaf7:	83 d2 00             	adc    $0x0,%edx
 804eafa:	83 f1 09             	xor    $0x9,%ecx
 804eafd:	09 d1                	or     %edx,%ecx
 804eaff:	75 0b                	jne    804eb0c <z_init_static_threads+0x10a>
	z_sched_start(thread);
 804eb01:	83 ec 0c             	sub    $0xc,%esp
 804eb04:	56                   	push   %esi
 804eb05:	e8 ea 09 00 00       	call   804f4f4 <z_sched_start>
 804eb0a:	eb 1e                	jmp    804eb2a <z_init_static_threads+0x128>
			return t / ((uint64_t)from_hz / to_hz);
 804eb0c:	6a 00                	push   $0x0
 804eb0e:	83 c6 18             	add    $0x18,%esi
 804eb11:	6a 0a                	push   $0xa
 804eb13:	52                   	push   %edx
 804eb14:	50                   	push   %eax
 804eb15:	e8 06 a8 ff ff       	call   8049320 <__udivdi3@plt>
 804eb1a:	83 c4 10             	add    $0x10,%esp
 804eb1d:	52                   	push   %edx
 804eb1e:	50                   	push   %eax
 804eb1f:	68 f4 f5 04 08       	push   $0x804f5f4
 804eb24:	56                   	push   %esi
 804eb25:	e8 f9 12 00 00       	call   804fe23 <z_add_timeout>
 804eb2a:	83 c4 10             	add    $0x10,%esp
	_FOREACH_STATIC_THREAD(thread_data) {
 804eb2d:	83 c3 30             	add    $0x30,%ebx
 804eb30:	e9 5f ff ff ff       	jmp    804ea94 <z_init_static_threads+0x92>
}
 804eb35:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804eb38:	5b                   	pop    %ebx
 804eb39:	5e                   	pop    %esi
 804eb3a:	5d                   	pop    %ebp
	k_sched_unlock();
 804eb3b:	e9 7f 0c 00 00       	jmp    804f7bf <k_sched_unlock>

0804eb40 <z_spin_lock_valid>:
/* These spinlock assertion predicates are defined here because having
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
 804eb40:	f3 0f 1e fb          	endbr32 
 804eb44:	55                   	push   %ebp
 804eb45:	b2 01                	mov    $0x1,%dl
 804eb47:	89 e5                	mov    %esp,%ebp
	uintptr_t thread_cpu = l->thread_cpu;
 804eb49:	8b 45 08             	mov    0x8(%ebp),%eax
 804eb4c:	8b 00                	mov    (%eax),%eax

	if (thread_cpu != 0U) {
 804eb4e:	85 c0                	test   %eax,%eax
 804eb50:	74 0f                	je     804eb61 <z_spin_lock_valid+0x21>
		if ((thread_cpu & 3U) == _current_cpu->id) {
 804eb52:	0f b6 15 74 69 05 08 	movzbl 0x8056974,%edx
 804eb59:	83 e0 03             	and    $0x3,%eax
 804eb5c:	39 d0                	cmp    %edx,%eax
 804eb5e:	0f 95 c2             	setne  %dl
			return false;
		}
	}
	return true;
}
 804eb61:	89 d0                	mov    %edx,%eax
 804eb63:	5d                   	pop    %ebp
 804eb64:	c3                   	ret    

0804eb65 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
 804eb65:	f3 0f 1e fb          	endbr32 
 804eb69:	55                   	push   %ebp
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
 804eb6a:	0f b6 05 74 69 05 08 	movzbl 0x8056974,%eax
 804eb71:	31 d2                	xor    %edx,%edx
 804eb73:	0b 05 68 69 05 08    	or     0x8056968,%eax
{
 804eb79:	89 e5                	mov    %esp,%ebp
 804eb7b:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
 804eb7e:	39 01                	cmp    %eax,(%ecx)
 804eb80:	75 08                	jne    804eb8a <z_spin_unlock_valid+0x25>
		return false;
	}
	l->thread_cpu = 0;
 804eb82:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	return true;
 804eb88:	b2 01                	mov    $0x1,%dl
}
 804eb8a:	89 d0                	mov    %edx,%eax
 804eb8c:	5d                   	pop    %ebp
 804eb8d:	c3                   	ret    

0804eb8e <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
 804eb8e:	f3 0f 1e fb          	endbr32 
 804eb92:	55                   	push   %ebp
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
 804eb93:	0f b6 05 74 69 05 08 	movzbl 0x8056974,%eax
 804eb9a:	0b 05 68 69 05 08    	or     0x8056968,%eax
{
 804eba0:	89 e5                	mov    %esp,%ebp
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
 804eba2:	8b 55 08             	mov    0x8(%ebp),%edx
 804eba5:	89 02                	mov    %eax,(%edx)
}
 804eba7:	5d                   	pop    %ebp
 804eba8:	c3                   	ret    

0804eba9 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
 804eba9:	f3 0f 1e fb          	endbr32 
 804ebad:	55                   	push   %ebp
 804ebae:	89 e5                	mov    %esp,%ebp
 804ebb0:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
 804ebb3:	a1 68 69 05 08       	mov    0x8056968,%eax
 804ebb8:	80 78 0e 00          	cmpb   $0x0,0xe(%eax)
 804ebbc:	79 27                	jns    804ebe5 <idle+0x3c>
 804ebbe:	6a 27                	push   $0x27
 804ebc0:	68 3c 2f 05 08       	push   $0x8052f3c
 804ebc5:	68 5d 2f 05 08       	push   $0x8052f5d
 804ebca:	68 1c 1c 05 08       	push   $0x8051c1c
 804ebcf:	e8 65 c5 ff ff       	call   804b139 <assert_print>
 804ebd4:	58                   	pop    %eax
 804ebd5:	5a                   	pop    %edx
 804ebd6:	6a 27                	push   $0x27
 804ebd8:	68 3c 2f 05 08       	push   $0x8052f3c
 804ebdd:	e8 72 c5 ff ff       	call   804b154 <assert_post_action>
 804ebe2:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 804ebe5:	e8 a2 e2 ff ff       	call   804ce8c <posix_irq_lock>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
 804ebea:	e8 64 d0 ff ff       	call   804bc53 <arch_cpu_idle>
 804ebef:	eb f4                	jmp    804ebe5 <idle+0x3c>

0804ebf1 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(struct k_thread *curr)
{
 804ebf1:	f3 0f 1e fb          	endbr32 
 804ebf5:	55                   	push   %ebp
 804ebf6:	89 e5                	mov    %esp,%ebp
 804ebf8:	53                   	push   %ebx
 804ebf9:	52                   	push   %edx
	int ret = slice_ticks;
 804ebfa:	8b 1d d8 6a 05 08    	mov    0x8056ad8,%ebx
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time(curr) != 0) {
 804ec00:	85 db                	test   %ebx,%ebx
 804ec02:	74 1f                	je     804ec23 <z_reset_time_slice+0x32>
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
 804ec04:	e8 98 f8 ff ff       	call   804e4a1 <sys_clock_elapsed>
 804ec09:	01 c3                	add    %eax,%ebx
		z_set_timeout_expiry(slice_time(curr), false);
 804ec0b:	50                   	push   %eax
 804ec0c:	50                   	push   %eax
 804ec0d:	6a 00                	push   $0x0
 804ec0f:	ff 35 d8 6a 05 08    	pushl  0x8056ad8
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
 804ec15:	89 1d 70 69 05 08    	mov    %ebx,0x8056970
		z_set_timeout_expiry(slice_time(curr), false);
 804ec1b:	e8 47 15 00 00       	call   8050167 <z_set_timeout_expiry>
 804ec20:	83 c4 10             	add    $0x10,%esp
	}
}
 804ec23:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804ec26:	c9                   	leave  
 804ec27:	c3                   	ret    

0804ec28 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
 804ec28:	f3 0f 1e fb          	endbr32 
 804ec2c:	55                   	push   %ebp
 804ec2d:	89 e5                	mov    %esp,%ebp
 804ec2f:	57                   	push   %edi
 804ec30:	56                   	push   %esi
 804ec31:	53                   	push   %ebx
 804ec32:	83 ec 0c             	sub    $0xc,%esp
 804ec35:	8b 75 08             	mov    0x8(%ebp),%esi
 804ec38:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804ec3b:	e8 4c e2 ff ff       	call   804ce8c <posix_irq_lock>
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 804ec40:	83 ec 0c             	sub    $0xc,%esp
 804ec43:	68 dc 6a 05 08       	push   $0x8056adc
 804ec48:	89 c3                	mov    %eax,%ebx
 804ec4a:	e8 f1 fe ff ff       	call   804eb40 <z_spin_lock_valid>
 804ec4f:	83 c4 10             	add    $0x10,%esp
 804ec52:	84 c0                	test   %al,%al
 804ec54:	75 3e                	jne    804ec94 <k_sched_time_slice_set+0x6c>
 804ec56:	68 8e 00 00 00       	push   $0x8e
 804ec5b:	68 85 2f 05 08       	push   $0x8052f85
 804ec60:	68 b2 2f 05 08       	push   $0x8052fb2
 804ec65:	68 1c 1c 05 08       	push   $0x8051c1c
 804ec6a:	e8 ca c4 ff ff       	call   804b139 <assert_print>
 804ec6f:	58                   	pop    %eax
 804ec70:	5a                   	pop    %edx
 804ec71:	68 dc 6a 05 08       	push   $0x8056adc
 804ec76:	68 c7 2f 05 08       	push   $0x8052fc7
 804ec7b:	e8 b9 c4 ff ff       	call   804b139 <assert_print>
 804ec80:	59                   	pop    %ecx
 804ec81:	58                   	pop    %eax
 804ec82:	68 8e 00 00 00       	push   $0x8e
 804ec87:	68 85 2f 05 08       	push   $0x8052f85
 804ec8c:	e8 c3 c4 ff ff       	call   804b154 <assert_post_action>
 804ec91:	83 c4 10             	add    $0x10,%esp
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
 804ec94:	83 ec 0c             	sub    $0xc,%esp
 804ec97:	68 dc 6a 05 08       	push   $0x8056adc
 804ec9c:	e8 ed fe ff ff       	call   804eb8e <z_spin_lock_set_owner>
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
 804eca1:	89 f0                	mov    %esi,%eax
 804eca3:	31 d2                	xor    %edx,%edx
 804eca5:	83 c4 10             	add    $0x10,%esp
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
 804eca8:	c7 05 70 69 05 08 00 	movl   $0x0,0x8056970
 804ecaf:	00 00 00 
		t += off;
 804ecb2:	83 c0 09             	add    $0x9,%eax
 804ecb5:	83 d2 00             	adc    $0x0,%edx
		if (result32 && (t < BIT64(32))) {
 804ecb8:	83 fa 00             	cmp    $0x0,%edx
 804ecbb:	77 0e                	ja     804eccb <k_sched_time_slice_set+0xa3>
			return ((uint32_t)t) / (from_hz / to_hz);
 804ecbd:	8d 46 09             	lea    0x9(%esi),%eax
 804ecc0:	b9 0a 00 00 00       	mov    $0xa,%ecx
 804ecc5:	31 d2                	xor    %edx,%edx
 804ecc7:	f7 f1                	div    %ecx
 804ecc9:	eb 0e                	jmp    804ecd9 <k_sched_time_slice_set+0xb1>
			return t / ((uint64_t)from_hz / to_hz);
 804eccb:	6a 00                	push   $0x0
 804eccd:	6a 0a                	push   $0xa
 804eccf:	52                   	push   %edx
 804ecd0:	50                   	push   %eax
 804ecd1:	e8 4a a6 ff ff       	call   8049320 <__udivdi3@plt>
 804ecd6:	83 c4 10             	add    $0x10,%esp
		slice_ticks = k_ms_to_ticks_ceil32(slice);
 804ecd9:	89 c1                	mov    %eax,%ecx
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
 804ecdb:	85 f6                	test   %esi,%esi
 804ecdd:	7f 07                	jg     804ece6 <k_sched_time_slice_set+0xbe>
		slice_ticks = k_ms_to_ticks_ceil32(slice);
 804ecdf:	a3 d8 6a 05 08       	mov    %eax,0x8056ad8
 804ece4:	eb 11                	jmp    804ecf7 <k_sched_time_slice_set+0xcf>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_ticks = MAX(2, slice_ticks);
 804ece6:	83 f8 02             	cmp    $0x2,%eax
 804ece9:	b8 02 00 00 00       	mov    $0x2,%eax
 804ecee:	0f 4c c8             	cmovl  %eax,%ecx
 804ecf1:	89 0d d8 6a 05 08    	mov    %ecx,0x8056ad8
		}
		slice_max_prio = prio;
		z_reset_time_slice(_current);
 804ecf7:	83 ec 0c             	sub    $0xc,%esp
 804ecfa:	ff 35 68 69 05 08    	pushl  0x8056968
		slice_max_prio = prio;
 804ed00:	89 3d d4 6a 05 08    	mov    %edi,0x8056ad4
		z_reset_time_slice(_current);
 804ed06:	e8 e6 fe ff ff       	call   804ebf1 <z_reset_time_slice>
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804ed0b:	c7 04 24 dc 6a 05 08 	movl   $0x8056adc,(%esp)
 804ed12:	e8 4e fe ff ff       	call   804eb65 <z_spin_unlock_valid>
 804ed17:	83 c4 10             	add    $0x10,%esp
 804ed1a:	84 c0                	test   %al,%al
 804ed1c:	75 3e                	jne    804ed5c <k_sched_time_slice_set+0x134>
 804ed1e:	68 b9 00 00 00       	push   $0xb9
 804ed23:	68 85 2f 05 08       	push   $0x8052f85
 804ed28:	68 df 2f 05 08       	push   $0x8052fdf
 804ed2d:	68 1c 1c 05 08       	push   $0x8051c1c
 804ed32:	e8 02 c4 ff ff       	call   804b139 <assert_print>
 804ed37:	58                   	pop    %eax
 804ed38:	5a                   	pop    %edx
 804ed39:	68 dc 6a 05 08       	push   $0x8056adc
 804ed3e:	68 f6 2f 05 08       	push   $0x8052ff6
 804ed43:	e8 f1 c3 ff ff       	call   804b139 <assert_print>
 804ed48:	59                   	pop    %ecx
 804ed49:	5e                   	pop    %esi
 804ed4a:	68 b9 00 00 00       	push   $0xb9
 804ed4f:	68 85 2f 05 08       	push   $0x8052f85
 804ed54:	e8 fb c3 ff ff       	call   804b154 <assert_post_action>
 804ed59:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804ed5c:	89 5d 08             	mov    %ebx,0x8(%ebp)
	}
}
 804ed5f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ed62:	5b                   	pop    %ebx
 804ed63:	5e                   	pop    %esi
 804ed64:	5f                   	pop    %edi
 804ed65:	5d                   	pop    %ebp
 804ed66:	e9 37 e1 ff ff       	jmp    804cea2 <posix_irq_unlock>

0804ed6b <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
 804ed6b:	f3 0f 1e fb          	endbr32 
 804ed6f:	55                   	push   %ebp
 804ed70:	89 e5                	mov    %esp,%ebp
 804ed72:	56                   	push   %esi
 804ed73:	8b 75 0c             	mov    0xc(%ebp),%esi
 804ed76:	53                   	push   %ebx
 804ed77:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (resched(key.key) && need_swap()) {
 804ed7a:	89 f0                	mov    %esi,%eax
 804ed7c:	0b 05 60 69 05 08    	or     0x8056960,%eax
 804ed82:	75 69                	jne    804eded <z_reschedule+0x82>
 804ed84:	a1 68 69 05 08       	mov    0x8056968,%eax
 804ed89:	39 05 78 69 05 08    	cmp    %eax,0x8056978
 804ed8f:	74 5c                	je     804eded <z_reschedule+0x82>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804ed91:	83 ec 0c             	sub    $0xc,%esp
 804ed94:	53                   	push   %ebx
 804ed95:	e8 cb fd ff ff       	call   804eb65 <z_spin_unlock_valid>
 804ed9a:	83 c4 10             	add    $0x10,%esp
 804ed9d:	84 c0                	test   %al,%al
 804ed9f:	75 3a                	jne    804eddb <z_reschedule+0x70>
 804eda1:	68 d0 00 00 00       	push   $0xd0
 804eda6:	68 85 2f 05 08       	push   $0x8052f85
 804edab:	68 df 2f 05 08       	push   $0x8052fdf
 804edb0:	68 1c 1c 05 08       	push   $0x8051c1c
 804edb5:	e8 7f c3 ff ff       	call   804b139 <assert_print>
 804edba:	5e                   	pop    %esi
 804edbb:	58                   	pop    %eax
 804edbc:	53                   	push   %ebx
 804edbd:	68 f6 2f 05 08       	push   $0x8052ff6
 804edc2:	e8 72 c3 ff ff       	call   804b139 <assert_print>
 804edc7:	58                   	pop    %eax
 804edc8:	5a                   	pop    %edx
 804edc9:	68 d0 00 00 00       	push   $0xd0
 804edce:	68 85 2f 05 08       	push   $0x8052f85
 804edd3:	e8 7c c3 ff ff       	call   804b154 <assert_post_action>
 804edd8:	83 c4 10             	add    $0x10,%esp
	ret = arch_swap(key);
 804eddb:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
 804ede2:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804ede5:	5b                   	pop    %ebx
 804ede6:	5e                   	pop    %esi
 804ede7:	5d                   	pop    %ebp
 804ede8:	e9 3b d3 ff ff       	jmp    804c128 <arch_swap>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804eded:	83 ec 0c             	sub    $0xc,%esp
 804edf0:	53                   	push   %ebx
 804edf1:	e8 6f fd ff ff       	call   804eb65 <z_spin_unlock_valid>
 804edf6:	83 c4 10             	add    $0x10,%esp
 804edf9:	84 c0                	test   %al,%al
 804edfb:	75 3a                	jne    804ee37 <z_reschedule+0xcc>
 804edfd:	68 b9 00 00 00       	push   $0xb9
 804ee02:	68 85 2f 05 08       	push   $0x8052f85
 804ee07:	68 df 2f 05 08       	push   $0x8052fdf
 804ee0c:	68 1c 1c 05 08       	push   $0x8051c1c
 804ee11:	e8 23 c3 ff ff       	call   804b139 <assert_print>
 804ee16:	58                   	pop    %eax
 804ee17:	5a                   	pop    %edx
 804ee18:	53                   	push   %ebx
 804ee19:	68 f6 2f 05 08       	push   $0x8052ff6
 804ee1e:	e8 16 c3 ff ff       	call   804b139 <assert_print>
 804ee23:	59                   	pop    %ecx
 804ee24:	5b                   	pop    %ebx
 804ee25:	68 b9 00 00 00       	push   $0xb9
 804ee2a:	68 85 2f 05 08       	push   $0x8052f85
 804ee2f:	e8 20 c3 ff ff       	call   804b154 <assert_post_action>
 804ee34:	83 c4 10             	add    $0x10,%esp
 804ee37:	89 75 08             	mov    %esi,0x8(%ebp)
 804ee3a:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804ee3d:	5b                   	pop    %ebx
 804ee3e:	5e                   	pop    %esi
 804ee3f:	5d                   	pop    %ebp
 804ee40:	e9 5d e0 ff ff       	jmp    804cea2 <posix_irq_unlock>

0804ee45 <z_reschedule_irqlock>:

void z_reschedule_irqlock(uint32_t key)
{
 804ee45:	f3 0f 1e fb          	endbr32 
 804ee49:	55                   	push   %ebp
 804ee4a:	89 e5                	mov    %esp,%ebp
	if (resched(key)) {
 804ee4c:	8b 45 08             	mov    0x8(%ebp),%eax
 804ee4f:	0b 05 60 69 05 08    	or     0x8056960,%eax
 804ee55:	75 0d                	jne    804ee64 <z_reschedule_irqlock+0x1f>
 804ee57:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
		z_swap_irqlock(key);
	} else {
		irq_unlock(key);
		signal_pending_ipi();
	}
}
 804ee5e:	5d                   	pop    %ebp
 804ee5f:	e9 c4 d2 ff ff       	jmp    804c128 <arch_swap>
 804ee64:	5d                   	pop    %ebp
 804ee65:	e9 38 e0 ff ff       	jmp    804cea2 <posix_irq_unlock>

0804ee6a <z_reschedule_unlocked>:
{
 804ee6a:	55                   	push   %ebp
 804ee6b:	89 e5                	mov    %esp,%ebp
 804ee6d:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
 804ee70:	e8 17 e0 ff ff       	call   804ce8c <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
 804ee75:	83 ec 0c             	sub    $0xc,%esp
 804ee78:	50                   	push   %eax
 804ee79:	e8 c7 ff ff ff       	call   804ee45 <z_reschedule_irqlock>
 804ee7e:	83 c4 10             	add    $0x10,%esp
}
 804ee81:	c9                   	leave  
 804ee82:	c3                   	ret    

0804ee83 <k_sched_lock>:

void k_sched_lock(void)
{
 804ee83:	f3 0f 1e fb          	endbr32 
 804ee87:	55                   	push   %ebp
 804ee88:	89 e5                	mov    %esp,%ebp
 804ee8a:	53                   	push   %ebx
 804ee8b:	50                   	push   %eax
 804ee8c:	e8 fb df ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 804ee91:	83 ec 0c             	sub    $0xc,%esp
 804ee94:	68 dc 6a 05 08       	push   $0x8056adc
 804ee99:	89 c3                	mov    %eax,%ebx
 804ee9b:	e8 a0 fc ff ff       	call   804eb40 <z_spin_lock_valid>
 804eea0:	83 c4 10             	add    $0x10,%esp
 804eea3:	84 c0                	test   %al,%al
 804eea5:	75 3e                	jne    804eee5 <k_sched_lock+0x62>
 804eea7:	68 8e 00 00 00       	push   $0x8e
 804eeac:	68 85 2f 05 08       	push   $0x8052f85
 804eeb1:	68 b2 2f 05 08       	push   $0x8052fb2
 804eeb6:	68 1c 1c 05 08       	push   $0x8051c1c
 804eebb:	e8 79 c2 ff ff       	call   804b139 <assert_print>
 804eec0:	58                   	pop    %eax
 804eec1:	5a                   	pop    %edx
 804eec2:	68 dc 6a 05 08       	push   $0x8056adc
 804eec7:	68 c7 2f 05 08       	push   $0x8052fc7
 804eecc:	e8 68 c2 ff ff       	call   804b139 <assert_print>
 804eed1:	59                   	pop    %ecx
 804eed2:	58                   	pop    %eax
 804eed3:	68 8e 00 00 00       	push   $0x8e
 804eed8:	68 85 2f 05 08       	push   $0x8052f85
 804eedd:	e8 72 c2 ff ff       	call   804b154 <assert_post_action>
 804eee2:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 804eee5:	83 ec 0c             	sub    $0xc,%esp
 804eee8:	68 dc 6a 05 08       	push   $0x8056adc
 804eeed:	e8 9c fc ff ff       	call   804eb8e <z_spin_lock_set_owner>
 804eef2:	83 c4 10             	add    $0x10,%esp
	}
}

static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
 804eef5:	83 3d 60 69 05 08 00 	cmpl   $0x0,0x8056960
 804eefc:	74 39                	je     804ef37 <k_sched_lock+0xb4>
 804eefe:	68 fd 00 00 00       	push   $0xfd
 804ef03:	68 0b 30 05 08       	push   $0x805300b
 804ef08:	68 d8 2e 05 08       	push   $0x8052ed8
 804ef0d:	68 1c 1c 05 08       	push   $0x8051c1c
 804ef12:	e8 22 c2 ff ff       	call   804b139 <assert_print>
 804ef17:	c7 04 24 36 30 05 08 	movl   $0x8053036,(%esp)
 804ef1e:	e8 16 c2 ff ff       	call   804b139 <assert_print>
 804ef23:	59                   	pop    %ecx
 804ef24:	58                   	pop    %eax
 804ef25:	68 fd 00 00 00       	push   $0xfd
 804ef2a:	68 0b 30 05 08       	push   $0x805300b
 804ef2f:	e8 20 c2 ff ff       	call   804b154 <assert_post_action>
 804ef34:	83 c4 10             	add    $0x10,%esp
	__ASSERT(_current->base.sched_locked != 1U, "");
 804ef37:	a1 68 69 05 08       	mov    0x8056968,%eax
 804ef3c:	80 78 0f 01          	cmpb   $0x1,0xf(%eax)
 804ef40:	75 39                	jne    804ef7b <k_sched_lock+0xf8>
 804ef42:	68 fe 00 00 00       	push   $0xfe
 804ef47:	68 0b 30 05 08       	push   $0x805300b
 804ef4c:	68 39 30 05 08       	push   $0x8053039
 804ef51:	68 1c 1c 05 08       	push   $0x8051c1c
 804ef56:	e8 de c1 ff ff       	call   804b139 <assert_print>
 804ef5b:	c7 04 24 36 30 05 08 	movl   $0x8053036,(%esp)
 804ef62:	e8 d2 c1 ff ff       	call   804b139 <assert_print>
 804ef67:	58                   	pop    %eax
 804ef68:	5a                   	pop    %edx
 804ef69:	68 fe 00 00 00       	push   $0xfe
 804ef6e:	68 0b 30 05 08       	push   $0x805300b
 804ef73:	e8 dc c1 ff ff       	call   804b154 <assert_post_action>
 804ef78:	83 c4 10             	add    $0x10,%esp

	--_current->base.sched_locked;
 804ef7b:	a1 68 69 05 08       	mov    0x8056968,%eax
 804ef80:	fe 48 0f             	decb   0xf(%eax)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804ef83:	83 ec 0c             	sub    $0xc,%esp
 804ef86:	68 dc 6a 05 08       	push   $0x8056adc
 804ef8b:	e8 d5 fb ff ff       	call   804eb65 <z_spin_unlock_valid>
 804ef90:	83 c4 10             	add    $0x10,%esp
 804ef93:	84 c0                	test   %al,%al
 804ef95:	75 3e                	jne    804efd5 <k_sched_lock+0x152>
 804ef97:	68 b9 00 00 00       	push   $0xb9
 804ef9c:	68 85 2f 05 08       	push   $0x8052f85
 804efa1:	68 df 2f 05 08       	push   $0x8052fdf
 804efa6:	68 1c 1c 05 08       	push   $0x8051c1c
 804efab:	e8 89 c1 ff ff       	call   804b139 <assert_print>
 804efb0:	58                   	pop    %eax
 804efb1:	5a                   	pop    %edx
 804efb2:	68 dc 6a 05 08       	push   $0x8056adc
 804efb7:	68 f6 2f 05 08       	push   $0x8052ff6
 804efbc:	e8 78 c1 ff ff       	call   804b139 <assert_print>
 804efc1:	59                   	pop    %ecx
 804efc2:	58                   	pop    %eax
 804efc3:	68 b9 00 00 00       	push   $0xb9
 804efc8:	68 85 2f 05 08       	push   $0x8052f85
 804efcd:	e8 82 c1 ff ff       	call   804b154 <assert_post_action>
 804efd2:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804efd5:	83 ec 0c             	sub    $0xc,%esp
 804efd8:	53                   	push   %ebx
 804efd9:	e8 c4 de ff ff       	call   804cea2 <posix_irq_unlock>
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
 804efde:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804efe1:	83 c4 10             	add    $0x10,%esp
 804efe4:	c9                   	leave  
 804efe5:	c3                   	ret    

0804efe6 <z_priq_dumb_remove>:
#endif
}
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
 804efe6:	f3 0f 1e fb          	endbr32 
 804efea:	55                   	push   %ebp
 804efeb:	89 e5                	mov    %esp,%ebp
 804efed:	53                   	push   %ebx
 804efee:	51                   	push   %ecx
 804efef:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 804eff2:	81 fb 60 68 05 08    	cmp    $0x8056860,%ebx
 804eff8:	75 2d                	jne    804f027 <z_priq_dumb_remove+0x41>
 804effa:	68 62 04 00 00       	push   $0x462
 804efff:	68 6a 30 05 08       	push   $0x805306a
 804f004:	68 8c 30 05 08       	push   $0x805308c
 804f009:	68 1c 1c 05 08       	push   $0x8051c1c
 804f00e:	e8 26 c1 ff ff       	call   804b139 <assert_print>
 804f013:	58                   	pop    %eax
 804f014:	5a                   	pop    %edx
 804f015:	68 62 04 00 00       	push   $0x462
 804f01a:	68 6a 30 05 08       	push   $0x805306a
 804f01f:	e8 30 c1 ff ff       	call   804b154 <assert_post_action>
 804f024:	83 c4 10             	add    $0x10,%esp
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
 804f027:	8b 53 04             	mov    0x4(%ebx),%edx
	sys_dnode_t *const next = node->next;
 804f02a:	8b 03                	mov    (%ebx),%eax

	prev->next = next;
 804f02c:	89 02                	mov    %eax,(%edx)
	next->prev = prev;
 804f02e:	89 50 04             	mov    %edx,0x4(%eax)
	node->next = NULL;
 804f031:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	node->prev = NULL;
 804f037:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)

	sys_dlist_remove(&thread->base.qnode_dlist);
}
 804f03e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804f041:	c9                   	leave  
 804f042:	c3                   	ret    

0804f043 <unpend_thread_no_timeout>:
{
 804f043:	55                   	push   %ebp
 804f044:	89 e5                	mov    %esp,%ebp
 804f046:	53                   	push   %ebx
 804f047:	53                   	push   %ebx
	__ASSERT_NO_MSG(thread->base.pended_on);
 804f048:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
{
 804f04c:	89 c3                	mov    %eax,%ebx
	__ASSERT_NO_MSG(thread->base.pended_on);
 804f04e:	75 2d                	jne    804f07d <unpend_thread_no_timeout+0x3a>
 804f050:	68 d4 02 00 00       	push   $0x2d4
 804f055:	68 6a 30 05 08       	push   $0x805306a
 804f05a:	68 ad 30 05 08       	push   $0x80530ad
 804f05f:	68 1c 1c 05 08       	push   $0x8051c1c
 804f064:	e8 d0 c0 ff ff       	call   804b139 <assert_print>
 804f069:	5a                   	pop    %edx
 804f06a:	59                   	pop    %ecx
 804f06b:	68 d4 02 00 00       	push   $0x2d4
 804f070:	68 6a 30 05 08       	push   $0x805306a
 804f075:	e8 da c0 ff ff       	call   804b154 <assert_post_action>
 804f07a:	83 c4 10             	add    $0x10,%esp
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
 804f07d:	50                   	push   %eax
 804f07e:	50                   	push   %eax
 804f07f:	53                   	push   %ebx
 804f080:	ff 73 08             	pushl  0x8(%ebx)
 804f083:	e8 5e ff ff ff       	call   804efe6 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 804f088:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
 804f08c:	83 c4 10             	add    $0x10,%esp
	thread->base.pended_on = NULL;
 804f08f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
}
 804f096:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804f099:	c9                   	leave  
 804f09a:	c3                   	ret    

0804f09b <z_priq_dumb_best>:

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
 804f09b:	f3 0f 1e fb          	endbr32 
 804f09f:	55                   	push   %ebp
 804f0a0:	89 e5                	mov    %esp,%ebp
 804f0a2:	8b 55 08             	mov    0x8(%ebp),%edx
	return list->head == list;
 804f0a5:	8b 02                	mov    (%edx),%eax
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
 804f0a7:	85 c0                	test   %eax,%eax
 804f0a9:	74 04                	je     804f0af <z_priq_dumb_best+0x14>
 804f0ab:	39 c2                	cmp    %eax,%edx
 804f0ad:	75 02                	jne    804f0b1 <z_priq_dumb_best+0x16>
	struct k_thread *thread = NULL;
 804f0af:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
 804f0b1:	5d                   	pop    %ebp
 804f0b2:	c3                   	ret    

0804f0b3 <update_cache>:
{
 804f0b3:	55                   	push   %ebp
 804f0b4:	89 c1                	mov    %eax,%ecx
 804f0b6:	89 e5                	mov    %esp,%ebp
 804f0b8:	53                   	push   %ebx
 804f0b9:	83 ec 10             	sub    $0x10,%esp
	return _priq_run_best(curr_cpu_runq());
 804f0bc:	68 7c 69 05 08       	push   $0x805697c
 804f0c1:	e8 d5 ff ff ff       	call   804f09b <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 804f0c6:	8b 1d 6c 69 05 08    	mov    0x805696c,%ebx
	return _priq_run_best(curr_cpu_runq());
 804f0cc:	83 c4 10             	add    $0x10,%esp
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 804f0cf:	85 c0                	test   %eax,%eax
 804f0d1:	74 02                	je     804f0d5 <update_cache+0x22>
 804f0d3:	89 c3                	mov    %eax,%ebx
	if (preempt_ok != 0) {
 804f0d5:	85 c9                	test   %ecx,%ecx
 804f0d7:	75 5b                	jne    804f134 <update_cache+0x81>
	__ASSERT(_current != NULL, "");
 804f0d9:	83 3d 68 69 05 08 00 	cmpl   $0x0,0x8056968
 804f0e0:	75 39                	jne    804f11b <update_cache+0x68>
 804f0e2:	68 89 00 00 00       	push   $0x89
 804f0e7:	68 6a 30 05 08       	push   $0x805306a
 804f0ec:	68 c4 30 05 08       	push   $0x80530c4
 804f0f1:	68 1c 1c 05 08       	push   $0x8051c1c
 804f0f6:	e8 3e c0 ff ff       	call   804b139 <assert_print>
 804f0fb:	c7 04 24 36 30 05 08 	movl   $0x8053036,(%esp)
 804f102:	e8 32 c0 ff ff       	call   804b139 <assert_print>
 804f107:	58                   	pop    %eax
 804f108:	5a                   	pop    %edx
 804f109:	68 89 00 00 00       	push   $0x89
 804f10e:	68 6a 30 05 08       	push   $0x805306a
 804f113:	e8 3c c0 ff ff       	call   804b154 <assert_post_action>
 804f118:	83 c4 10             	add    $0x10,%esp
	if (z_is_thread_prevented_from_running(_current)) {
 804f11b:	a1 68 69 05 08       	mov    0x8056968,%eax
 804f120:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
 804f124:	75 0e                	jne    804f134 <update_cache+0x81>
	if (is_preempt(_current) || is_metairq(thread)) {
 804f126:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
 804f12b:	76 07                	jbe    804f134 <update_cache+0x81>
		_kernel.ready_q.cache = _current;
 804f12d:	a3 78 69 05 08       	mov    %eax,0x8056978
 804f132:	eb 1a                	jmp    804f14e <update_cache+0x9b>
		if (thread != _current) {
 804f134:	39 1d 68 69 05 08    	cmp    %ebx,0x8056968
 804f13a:	74 0c                	je     804f148 <update_cache+0x95>
			z_reset_time_slice(thread);
 804f13c:	83 ec 0c             	sub    $0xc,%esp
 804f13f:	53                   	push   %ebx
 804f140:	e8 ac fa ff ff       	call   804ebf1 <z_reset_time_slice>
 804f145:	83 c4 10             	add    $0x10,%esp
		_kernel.ready_q.cache = thread;
 804f148:	89 1d 78 69 05 08    	mov    %ebx,0x8056978
}
 804f14e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804f151:	c9                   	leave  
 804f152:	c3                   	ret    

0804f153 <move_thread_to_end_of_prio_q>:
{
 804f153:	55                   	push   %ebp
 804f154:	89 e5                	mov    %esp,%ebp
 804f156:	56                   	push   %esi
 804f157:	53                   	push   %ebx
 804f158:	89 c3                	mov    %eax,%ebx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 804f15a:	8a 40 0d             	mov    0xd(%eax),%al
	if (z_is_thread_queued(thread)) {
 804f15d:	84 c0                	test   %al,%al
 804f15f:	79 16                	jns    804f177 <move_thread_to_end_of_prio_q+0x24>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804f161:	83 e0 7f             	and    $0x7f,%eax
	_priq_run_remove(thread_runq(thread), thread);
 804f164:	51                   	push   %ecx
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804f165:	88 43 0d             	mov    %al,0xd(%ebx)
	_priq_run_remove(thread_runq(thread), thread);
 804f168:	51                   	push   %ecx
 804f169:	53                   	push   %ebx
 804f16a:	68 7c 69 05 08       	push   $0x805697c
 804f16f:	e8 72 fe ff ff       	call   804efe6 <z_priq_dumb_remove>
 804f174:	83 c4 10             	add    $0x10,%esp
	thread->base.thread_state |= _THREAD_QUEUED;
 804f177:	80 4b 0d 80          	orb    $0x80,0xd(%ebx)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 804f17b:	81 fb 60 68 05 08    	cmp    $0x8056860,%ebx
 804f181:	75 2d                	jne    804f1b0 <move_thread_to_end_of_prio_q+0x5d>
 804f183:	68 ba 00 00 00       	push   $0xba
 804f188:	68 6a 30 05 08       	push   $0x805306a
 804f18d:	68 8c 30 05 08       	push   $0x805308c
 804f192:	68 1c 1c 05 08       	push   $0x8051c1c
 804f197:	e8 9d bf ff ff       	call   804b139 <assert_print>
 804f19c:	58                   	pop    %eax
 804f19d:	5a                   	pop    %edx
 804f19e:	68 ba 00 00 00       	push   $0xba
 804f1a3:	68 6a 30 05 08       	push   $0x805306a
 804f1a8:	e8 a7 bf ff ff       	call   804b154 <assert_post_action>
 804f1ad:	83 c4 10             	add    $0x10,%esp
 804f1b0:	a1 7c 69 05 08       	mov    0x805697c,%eax
 804f1b5:	8b 0d 80 69 05 08    	mov    0x8056980,%ecx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804f1bb:	85 c0                	test   %eax,%eax
 804f1bd:	74 32                	je     804f1f1 <move_thread_to_end_of_prio_q+0x9e>
 804f1bf:	3d 7c 69 05 08       	cmp    $0x805697c,%eax
 804f1c4:	74 2b                	je     804f1f1 <move_thread_to_end_of_prio_q+0x9e>
	int32_t b1 = thread_1->base.prio;
 804f1c6:	0f be 73 0e          	movsbl 0xe(%ebx),%esi
	int32_t b2 = thread_2->base.prio;
 804f1ca:	0f be 50 0e          	movsbl 0xe(%eax),%edx
	if (b1 != b2) {
 804f1ce:	39 d6                	cmp    %edx,%esi
 804f1d0:	74 15                	je     804f1e7 <move_thread_to_end_of_prio_q+0x94>
		return b2 - b1;
 804f1d2:	29 f2                	sub    %esi,%edx
		if (z_sched_prio_cmp(thread, t) > 0) {
 804f1d4:	85 d2                	test   %edx,%edx
 804f1d6:	7e 0f                	jle    804f1e7 <move_thread_to_end_of_prio_q+0x94>
	sys_dnode_t *const prev = successor->prev;
 804f1d8:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
 804f1db:	89 03                	mov    %eax,(%ebx)
	node->prev = prev;
 804f1dd:	89 53 04             	mov    %edx,0x4(%ebx)
	prev->next = node;
 804f1e0:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
 804f1e2:	89 58 04             	mov    %ebx,0x4(%eax)
}
 804f1e5:	eb 1b                	jmp    804f202 <move_thread_to_end_of_prio_q+0xaf>
	return (node == list->tail) ? NULL : node->next;
 804f1e7:	39 c8                	cmp    %ecx,%eax
 804f1e9:	74 06                	je     804f1f1 <move_thread_to_end_of_prio_q+0x9e>
 804f1eb:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804f1ed:	85 c0                	test   %eax,%eax
 804f1ef:	75 d9                	jne    804f1ca <move_thread_to_end_of_prio_q+0x77>
	node->next = list;
 804f1f1:	c7 03 7c 69 05 08    	movl   $0x805697c,(%ebx)
	node->prev = tail;
 804f1f7:	89 4b 04             	mov    %ecx,0x4(%ebx)
	tail->next = node;
 804f1fa:	89 19                	mov    %ebx,(%ecx)
	list->tail = node;
 804f1fc:	89 1d 80 69 05 08    	mov    %ebx,0x8056980
	update_cache(thread == _current);
 804f202:	31 c0                	xor    %eax,%eax
 804f204:	39 1d 68 69 05 08    	cmp    %ebx,0x8056968
 804f20a:	0f 94 c0             	sete   %al
}
 804f20d:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804f210:	5b                   	pop    %ebx
 804f211:	5e                   	pop    %esi
 804f212:	5d                   	pop    %ebp
	update_cache(thread == _current);
 804f213:	e9 9b fe ff ff       	jmp    804f0b3 <update_cache>

0804f218 <z_time_slice>:
{
 804f218:	f3 0f 1e fb          	endbr32 
 804f21c:	55                   	push   %ebp
 804f21d:	89 e5                	mov    %esp,%ebp
 804f21f:	57                   	push   %edi
 804f220:	56                   	push   %esi
 804f221:	53                   	push   %ebx
 804f222:	83 ec 0c             	sub    $0xc,%esp
 804f225:	8b 7d 08             	mov    0x8(%ebp),%edi
	return posix_irq_lock();
 804f228:	e8 5f dc ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 804f22d:	83 ec 0c             	sub    $0xc,%esp
 804f230:	68 dc 6a 05 08       	push   $0x8056adc
 804f235:	89 c6                	mov    %eax,%esi
 804f237:	e8 04 f9 ff ff       	call   804eb40 <z_spin_lock_valid>
 804f23c:	83 c4 10             	add    $0x10,%esp
 804f23f:	84 c0                	test   %al,%al
 804f241:	75 3e                	jne    804f281 <z_time_slice+0x69>
 804f243:	68 8e 00 00 00       	push   $0x8e
 804f248:	68 85 2f 05 08       	push   $0x8052f85
 804f24d:	68 b2 2f 05 08       	push   $0x8052fb2
 804f252:	68 1c 1c 05 08       	push   $0x8051c1c
 804f257:	e8 dd be ff ff       	call   804b139 <assert_print>
 804f25c:	58                   	pop    %eax
 804f25d:	5a                   	pop    %edx
 804f25e:	68 dc 6a 05 08       	push   $0x8056adc
 804f263:	68 c7 2f 05 08       	push   $0x8052fc7
 804f268:	e8 cc be ff ff       	call   804b139 <assert_print>
 804f26d:	59                   	pop    %ecx
 804f26e:	5b                   	pop    %ebx
 804f26f:	68 8e 00 00 00       	push   $0x8e
 804f274:	68 85 2f 05 08       	push   $0x8052f85
 804f279:	e8 d6 be ff ff       	call   804b154 <assert_post_action>
 804f27e:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 804f281:	83 ec 0c             	sub    $0xc,%esp
 804f284:	68 dc 6a 05 08       	push   $0x8056adc
 804f289:	e8 00 f9 ff ff       	call   804eb8e <z_spin_lock_set_owner>
 804f28e:	83 c4 10             	add    $0x10,%esp
	if (slice_time(_current) && sliceable(_current)) {
 804f291:	83 3d d8 6a 05 08 00 	cmpl   $0x0,0x8056ad8
 804f298:	74 4e                	je     804f2e8 <z_time_slice+0xd0>
 804f29a:	8b 1d 68 69 05 08    	mov    0x8056968,%ebx
		&& !z_is_idle_thread_object(thread);
 804f2a0:	66 83 7b 0e 7f       	cmpw   $0x7f,0xe(%ebx)
 804f2a5:	77 41                	ja     804f2e8 <z_time_slice+0xd0>
		&& !z_is_thread_prevented_from_running(thread)
 804f2a7:	f6 43 0d 1f          	testb  $0x1f,0xd(%ebx)
 804f2ab:	75 3b                	jne    804f2e8 <z_time_slice+0xd0>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 804f2ad:	0f be 43 0e          	movsbl 0xe(%ebx),%eax
	if (slice_time(_current) && sliceable(_current)) {
 804f2b1:	39 05 d4 6a 05 08    	cmp    %eax,0x8056ad4
 804f2b7:	7f 2f                	jg     804f2e8 <z_time_slice+0xd0>
 804f2b9:	81 fb 60 68 05 08    	cmp    $0x8056860,%ebx
 804f2bf:	74 27                	je     804f2e8 <z_time_slice+0xd0>
		if (ticks >= _current_cpu->slice_ticks) {
 804f2c1:	a1 70 69 05 08       	mov    0x8056970,%eax
 804f2c6:	39 f8                	cmp    %edi,%eax
 804f2c8:	7f 15                	jg     804f2df <z_time_slice+0xc7>
		move_thread_to_end_of_prio_q(curr);
 804f2ca:	89 d8                	mov    %ebx,%eax
 804f2cc:	e8 82 fe ff ff       	call   804f153 <move_thread_to_end_of_prio_q>
	z_reset_time_slice(curr);
 804f2d1:	83 ec 0c             	sub    $0xc,%esp
 804f2d4:	53                   	push   %ebx
 804f2d5:	e8 17 f9 ff ff       	call   804ebf1 <z_reset_time_slice>
 804f2da:	83 c4 10             	add    $0x10,%esp
	return sched_lock_key;
 804f2dd:	eb 13                	jmp    804f2f2 <z_time_slice+0xda>
			_current_cpu->slice_ticks -= ticks;
 804f2df:	29 f8                	sub    %edi,%eax
 804f2e1:	a3 70 69 05 08       	mov    %eax,0x8056970
 804f2e6:	eb 0a                	jmp    804f2f2 <z_time_slice+0xda>
		_current_cpu->slice_ticks = 0;
 804f2e8:	c7 05 70 69 05 08 00 	movl   $0x0,0x8056970
 804f2ef:	00 00 00 
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804f2f2:	83 ec 0c             	sub    $0xc,%esp
 804f2f5:	68 dc 6a 05 08       	push   $0x8056adc
 804f2fa:	e8 66 f8 ff ff       	call   804eb65 <z_spin_unlock_valid>
 804f2ff:	83 c4 10             	add    $0x10,%esp
 804f302:	84 c0                	test   %al,%al
 804f304:	75 3e                	jne    804f344 <z_time_slice+0x12c>
 804f306:	68 b9 00 00 00       	push   $0xb9
 804f30b:	68 85 2f 05 08       	push   $0x8052f85
 804f310:	68 df 2f 05 08       	push   $0x8052fdf
 804f315:	68 1c 1c 05 08       	push   $0x8051c1c
 804f31a:	e8 1a be ff ff       	call   804b139 <assert_print>
 804f31f:	58                   	pop    %eax
 804f320:	5a                   	pop    %edx
 804f321:	68 dc 6a 05 08       	push   $0x8056adc
 804f326:	68 f6 2f 05 08       	push   $0x8052ff6
 804f32b:	e8 09 be ff ff       	call   804b139 <assert_print>
 804f330:	59                   	pop    %ecx
 804f331:	5b                   	pop    %ebx
 804f332:	68 b9 00 00 00       	push   $0xb9
 804f337:	68 85 2f 05 08       	push   $0x8052f85
 804f33c:	e8 13 be ff ff       	call   804b154 <assert_post_action>
 804f341:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804f344:	89 75 08             	mov    %esi,0x8(%ebp)
}
 804f347:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804f34a:	5b                   	pop    %ebx
 804f34b:	5e                   	pop    %esi
 804f34c:	5f                   	pop    %edi
 804f34d:	5d                   	pop    %ebp
 804f34e:	e9 4f db ff ff       	jmp    804cea2 <posix_irq_unlock>

0804f353 <ready_thread>:
{
 804f353:	55                   	push   %ebp
 804f354:	89 e5                	mov    %esp,%ebp
 804f356:	56                   	push   %esi
 804f357:	53                   	push   %ebx
 804f358:	89 c3                	mov    %eax,%ebx
 804f35a:	8a 40 0d             	mov    0xd(%eax),%al
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 804f35d:	84 c0                	test   %al,%al
 804f35f:	0f 88 ac 00 00 00    	js     804f411 <ready_thread+0xbe>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 804f365:	a8 1f                	test   $0x1f,%al
 804f367:	0f 85 a4 00 00 00    	jne    804f411 <ready_thread+0xbe>
 804f36d:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
 804f371:	0f 85 9a 00 00 00    	jne    804f411 <ready_thread+0xbe>
	thread->base.thread_state |= _THREAD_QUEUED;
 804f377:	83 c8 80             	or     $0xffffff80,%eax
 804f37a:	88 43 0d             	mov    %al,0xd(%ebx)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 804f37d:	81 fb 60 68 05 08    	cmp    $0x8056860,%ebx
 804f383:	75 2d                	jne    804f3b2 <ready_thread+0x5f>
 804f385:	68 ba 00 00 00       	push   $0xba
 804f38a:	68 6a 30 05 08       	push   $0x805306a
 804f38f:	68 8c 30 05 08       	push   $0x805308c
 804f394:	68 1c 1c 05 08       	push   $0x8051c1c
 804f399:	e8 9b bd ff ff       	call   804b139 <assert_print>
 804f39e:	58                   	pop    %eax
 804f39f:	5a                   	pop    %edx
 804f3a0:	68 ba 00 00 00       	push   $0xba
 804f3a5:	68 6a 30 05 08       	push   $0x805306a
 804f3aa:	e8 a5 bd ff ff       	call   804b154 <assert_post_action>
 804f3af:	83 c4 10             	add    $0x10,%esp
	return list->head == list;
 804f3b2:	a1 7c 69 05 08       	mov    0x805697c,%eax
 804f3b7:	8b 0d 80 69 05 08    	mov    0x8056980,%ecx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804f3bd:	85 c0                	test   %eax,%eax
 804f3bf:	74 32                	je     804f3f3 <ready_thread+0xa0>
 804f3c1:	3d 7c 69 05 08       	cmp    $0x805697c,%eax
 804f3c6:	74 2b                	je     804f3f3 <ready_thread+0xa0>
	int32_t b1 = thread_1->base.prio;
 804f3c8:	0f be 73 0e          	movsbl 0xe(%ebx),%esi
	int32_t b2 = thread_2->base.prio;
 804f3cc:	0f be 50 0e          	movsbl 0xe(%eax),%edx
	if (b1 != b2) {
 804f3d0:	39 d6                	cmp    %edx,%esi
 804f3d2:	74 15                	je     804f3e9 <ready_thread+0x96>
		return b2 - b1;
 804f3d4:	29 f2                	sub    %esi,%edx
		if (z_sched_prio_cmp(thread, t) > 0) {
 804f3d6:	85 d2                	test   %edx,%edx
 804f3d8:	7e 0f                	jle    804f3e9 <ready_thread+0x96>
	sys_dnode_t *const prev = successor->prev;
 804f3da:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
 804f3dd:	89 03                	mov    %eax,(%ebx)
	node->prev = prev;
 804f3df:	89 53 04             	mov    %edx,0x4(%ebx)
	prev->next = node;
 804f3e2:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
 804f3e4:	89 58 04             	mov    %ebx,0x4(%eax)
}
 804f3e7:	eb 1b                	jmp    804f404 <ready_thread+0xb1>
	return (node == list->tail) ? NULL : node->next;
 804f3e9:	39 c8                	cmp    %ecx,%eax
 804f3eb:	74 06                	je     804f3f3 <ready_thread+0xa0>
 804f3ed:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804f3ef:	85 c0                	test   %eax,%eax
 804f3f1:	75 d9                	jne    804f3cc <ready_thread+0x79>
	node->next = list;
 804f3f3:	c7 03 7c 69 05 08    	movl   $0x805697c,(%ebx)
	node->prev = tail;
 804f3f9:	89 4b 04             	mov    %ecx,0x4(%ebx)
	tail->next = node;
 804f3fc:	89 19                	mov    %ebx,(%ecx)
	list->tail = node;
 804f3fe:	89 1d 80 69 05 08    	mov    %ebx,0x8056980
}
 804f404:	8d 65 f8             	lea    -0x8(%ebp),%esp
		update_cache(0);
 804f407:	31 c0                	xor    %eax,%eax
}
 804f409:	5b                   	pop    %ebx
 804f40a:	5e                   	pop    %esi
 804f40b:	5d                   	pop    %ebp
		update_cache(0);
 804f40c:	e9 a2 fc ff ff       	jmp    804f0b3 <update_cache>
}
 804f411:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804f414:	5b                   	pop    %ebx
 804f415:	5e                   	pop    %esi
 804f416:	5d                   	pop    %ebp
 804f417:	c3                   	ret    

0804f418 <z_ready_thread>:
{
 804f418:	f3 0f 1e fb          	endbr32 
 804f41c:	55                   	push   %ebp
 804f41d:	89 e5                	mov    %esp,%ebp
 804f41f:	56                   	push   %esi
 804f420:	53                   	push   %ebx
 804f421:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
 804f424:	e8 63 da ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 804f429:	83 ec 0c             	sub    $0xc,%esp
 804f42c:	68 dc 6a 05 08       	push   $0x8056adc
 804f431:	89 c3                	mov    %eax,%ebx
 804f433:	e8 08 f7 ff ff       	call   804eb40 <z_spin_lock_valid>
 804f438:	83 c4 10             	add    $0x10,%esp
 804f43b:	84 c0                	test   %al,%al
 804f43d:	75 3e                	jne    804f47d <z_ready_thread+0x65>
 804f43f:	68 8e 00 00 00       	push   $0x8e
 804f444:	68 85 2f 05 08       	push   $0x8052f85
 804f449:	68 b2 2f 05 08       	push   $0x8052fb2
 804f44e:	68 1c 1c 05 08       	push   $0x8051c1c
 804f453:	e8 e1 bc ff ff       	call   804b139 <assert_print>
 804f458:	58                   	pop    %eax
 804f459:	5a                   	pop    %edx
 804f45a:	68 dc 6a 05 08       	push   $0x8056adc
 804f45f:	68 c7 2f 05 08       	push   $0x8052fc7
 804f464:	e8 d0 bc ff ff       	call   804b139 <assert_print>
 804f469:	59                   	pop    %ecx
 804f46a:	58                   	pop    %eax
 804f46b:	68 8e 00 00 00       	push   $0x8e
 804f470:	68 85 2f 05 08       	push   $0x8052f85
 804f475:	e8 da bc ff ff       	call   804b154 <assert_post_action>
 804f47a:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 804f47d:	83 ec 0c             	sub    $0xc,%esp
 804f480:	68 dc 6a 05 08       	push   $0x8056adc
 804f485:	e8 04 f7 ff ff       	call   804eb8e <z_spin_lock_set_owner>
 804f48a:	83 c4 10             	add    $0x10,%esp
			ready_thread(thread);
 804f48d:	89 f0                	mov    %esi,%eax
 804f48f:	e8 bf fe ff ff       	call   804f353 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804f494:	83 ec 0c             	sub    $0xc,%esp
 804f497:	68 dc 6a 05 08       	push   $0x8056adc
 804f49c:	e8 c4 f6 ff ff       	call   804eb65 <z_spin_unlock_valid>
 804f4a1:	83 c4 10             	add    $0x10,%esp
 804f4a4:	84 c0                	test   %al,%al
 804f4a6:	75 3e                	jne    804f4e6 <z_ready_thread+0xce>
 804f4a8:	68 b9 00 00 00       	push   $0xb9
 804f4ad:	68 85 2f 05 08       	push   $0x8052f85
 804f4b2:	68 df 2f 05 08       	push   $0x8052fdf
 804f4b7:	68 1c 1c 05 08       	push   $0x8051c1c
 804f4bc:	e8 78 bc ff ff       	call   804b139 <assert_print>
 804f4c1:	58                   	pop    %eax
 804f4c2:	5a                   	pop    %edx
 804f4c3:	68 dc 6a 05 08       	push   $0x8056adc
 804f4c8:	68 f6 2f 05 08       	push   $0x8052ff6
 804f4cd:	e8 67 bc ff ff       	call   804b139 <assert_print>
 804f4d2:	59                   	pop    %ecx
 804f4d3:	5e                   	pop    %esi
 804f4d4:	68 b9 00 00 00       	push   $0xb9
 804f4d9:	68 85 2f 05 08       	push   $0x8052f85
 804f4de:	e8 71 bc ff ff       	call   804b154 <assert_post_action>
 804f4e3:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804f4e6:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 804f4e9:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804f4ec:	5b                   	pop    %ebx
 804f4ed:	5e                   	pop    %esi
 804f4ee:	5d                   	pop    %ebp
 804f4ef:	e9 ae d9 ff ff       	jmp    804cea2 <posix_irq_unlock>

0804f4f4 <z_sched_start>:
{
 804f4f4:	f3 0f 1e fb          	endbr32 
 804f4f8:	55                   	push   %ebp
 804f4f9:	89 e5                	mov    %esp,%ebp
 804f4fb:	56                   	push   %esi
 804f4fc:	53                   	push   %ebx
 804f4fd:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
 804f500:	e8 87 d9 ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 804f505:	83 ec 0c             	sub    $0xc,%esp
 804f508:	68 dc 6a 05 08       	push   $0x8056adc
 804f50d:	89 c3                	mov    %eax,%ebx
 804f50f:	e8 2c f6 ff ff       	call   804eb40 <z_spin_lock_valid>
 804f514:	83 c4 10             	add    $0x10,%esp
 804f517:	84 c0                	test   %al,%al
 804f519:	75 3e                	jne    804f559 <z_sched_start+0x65>
 804f51b:	68 8e 00 00 00       	push   $0x8e
 804f520:	68 85 2f 05 08       	push   $0x8052f85
 804f525:	68 b2 2f 05 08       	push   $0x8052fb2
 804f52a:	68 1c 1c 05 08       	push   $0x8051c1c
 804f52f:	e8 05 bc ff ff       	call   804b139 <assert_print>
 804f534:	58                   	pop    %eax
 804f535:	5a                   	pop    %edx
 804f536:	68 dc 6a 05 08       	push   $0x8056adc
 804f53b:	68 c7 2f 05 08       	push   $0x8052fc7
 804f540:	e8 f4 bb ff ff       	call   804b139 <assert_print>
 804f545:	59                   	pop    %ecx
 804f546:	58                   	pop    %eax
 804f547:	68 8e 00 00 00       	push   $0x8e
 804f54c:	68 85 2f 05 08       	push   $0x8052f85
 804f551:	e8 fe bb ff ff       	call   804b154 <assert_post_action>
 804f556:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 804f559:	83 ec 0c             	sub    $0xc,%esp
 804f55c:	68 dc 6a 05 08       	push   $0x8056adc
 804f561:	e8 28 f6 ff ff       	call   804eb8e <z_spin_lock_set_owner>
	if (z_has_thread_started(thread)) {
 804f566:	8a 46 0d             	mov    0xd(%esi),%al
 804f569:	83 c4 10             	add    $0x10,%esp
 804f56c:	a8 04                	test   $0x4,%al
 804f56e:	75 60                	jne    804f5d0 <z_sched_start+0xdc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804f570:	83 ec 0c             	sub    $0xc,%esp
 804f573:	68 dc 6a 05 08       	push   $0x8056adc
 804f578:	e8 e8 f5 ff ff       	call   804eb65 <z_spin_unlock_valid>
 804f57d:	83 c4 10             	add    $0x10,%esp
 804f580:	84 c0                	test   %al,%al
 804f582:	75 3e                	jne    804f5c2 <z_sched_start+0xce>
 804f584:	68 b9 00 00 00       	push   $0xb9
 804f589:	68 85 2f 05 08       	push   $0x8052f85
 804f58e:	68 df 2f 05 08       	push   $0x8052fdf
 804f593:	68 1c 1c 05 08       	push   $0x8051c1c
 804f598:	e8 9c bb ff ff       	call   804b139 <assert_print>
 804f59d:	5a                   	pop    %edx
 804f59e:	59                   	pop    %ecx
 804f59f:	68 dc 6a 05 08       	push   $0x8056adc
 804f5a4:	68 f6 2f 05 08       	push   $0x8052ff6
 804f5a9:	e8 8b bb ff ff       	call   804b139 <assert_print>
 804f5ae:	5e                   	pop    %esi
 804f5af:	58                   	pop    %eax
 804f5b0:	68 b9 00 00 00       	push   $0xb9
 804f5b5:	68 85 2f 05 08       	push   $0x8052f85
 804f5ba:	e8 95 bb ff ff       	call   804b154 <assert_post_action>
 804f5bf:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804f5c2:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 804f5c5:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804f5c8:	5b                   	pop    %ebx
 804f5c9:	5e                   	pop    %esi
 804f5ca:	5d                   	pop    %ebp
 804f5cb:	e9 d2 d8 ff ff       	jmp    804cea2 <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
 804f5d0:	83 e0 fb             	and    $0xfffffffb,%eax
 804f5d3:	88 46 0d             	mov    %al,0xd(%esi)
	ready_thread(thread);
 804f5d6:	89 f0                	mov    %esi,%eax
 804f5d8:	e8 76 fd ff ff       	call   804f353 <ready_thread>
	z_reschedule(&sched_spinlock, key);
 804f5dd:	50                   	push   %eax
 804f5de:	50                   	push   %eax
 804f5df:	53                   	push   %ebx
 804f5e0:	68 dc 6a 05 08       	push   $0x8056adc
 804f5e5:	e8 81 f7 ff ff       	call   804ed6b <z_reschedule>
 804f5ea:	83 c4 10             	add    $0x10,%esp
}
 804f5ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804f5f0:	5b                   	pop    %ebx
 804f5f1:	5e                   	pop    %esi
 804f5f2:	5d                   	pop    %ebp
 804f5f3:	c3                   	ret    

0804f5f4 <z_thread_timeout>:
{
 804f5f4:	f3 0f 1e fb          	endbr32 
 804f5f8:	55                   	push   %ebp
 804f5f9:	89 e5                	mov    %esp,%ebp
 804f5fb:	56                   	push   %esi
 804f5fc:	53                   	push   %ebx
 804f5fd:	83 ec 10             	sub    $0x10,%esp
 804f600:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
 804f603:	e8 84 d8 ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 804f608:	83 ec 0c             	sub    $0xc,%esp
 804f60b:	68 dc 6a 05 08       	push   $0x8056adc
 804f610:	89 c6                	mov    %eax,%esi
 804f612:	e8 29 f5 ff ff       	call   804eb40 <z_spin_lock_valid>
 804f617:	83 c4 10             	add    $0x10,%esp
 804f61a:	84 c0                	test   %al,%al
 804f61c:	75 3e                	jne    804f65c <z_thread_timeout+0x68>
 804f61e:	68 8e 00 00 00       	push   $0x8e
 804f623:	68 85 2f 05 08       	push   $0x8052f85
 804f628:	68 b2 2f 05 08       	push   $0x8052fb2
 804f62d:	68 1c 1c 05 08       	push   $0x8051c1c
 804f632:	e8 02 bb ff ff       	call   804b139 <assert_print>
 804f637:	58                   	pop    %eax
 804f638:	5a                   	pop    %edx
 804f639:	68 dc 6a 05 08       	push   $0x8056adc
 804f63e:	68 c7 2f 05 08       	push   $0x8052fc7
 804f643:	e8 f1 ba ff ff       	call   804b139 <assert_print>
 804f648:	59                   	pop    %ecx
 804f649:	58                   	pop    %eax
 804f64a:	68 8e 00 00 00       	push   $0x8e
 804f64f:	68 85 2f 05 08       	push   $0x8052f85
 804f654:	e8 fb ba ff ff       	call   804b154 <assert_post_action>
 804f659:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 804f65c:	83 ec 0c             	sub    $0xc,%esp
 804f65f:	68 dc 6a 05 08       	push   $0x8056adc
 804f664:	e8 25 f5 ff ff       	call   804eb8e <z_spin_lock_set_owner>
 804f669:	83 c4 10             	add    $0x10,%esp
		if (!killed) {
 804f66c:	f6 43 f5 28          	testb  $0x28,-0xb(%ebx)
 804f670:	75 1d                	jne    804f68f <z_thread_timeout+0x9b>
			if (thread->base.pended_on != NULL) {
 804f672:	83 7b f0 00          	cmpl   $0x0,-0x10(%ebx)
	struct k_thread *thread = CONTAINER_OF(timeout,
 804f676:	8d 43 e8             	lea    -0x18(%ebx),%eax
			if (thread->base.pended_on != NULL) {
 804f679:	74 0b                	je     804f686 <z_thread_timeout+0x92>
				unpend_thread_no_timeout(thread);
 804f67b:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804f67e:	e8 c0 f9 ff ff       	call   804f043 <unpend_thread_no_timeout>
 804f683:	8b 45 f4             	mov    -0xc(%ebp),%eax
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 804f686:	80 63 f5 eb          	andb   $0xeb,-0xb(%ebx)
			ready_thread(thread);
 804f68a:	e8 c4 fc ff ff       	call   804f353 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804f68f:	83 ec 0c             	sub    $0xc,%esp
 804f692:	68 dc 6a 05 08       	push   $0x8056adc
 804f697:	e8 c9 f4 ff ff       	call   804eb65 <z_spin_unlock_valid>
 804f69c:	83 c4 10             	add    $0x10,%esp
 804f69f:	84 c0                	test   %al,%al
 804f6a1:	75 3e                	jne    804f6e1 <z_thread_timeout+0xed>
 804f6a3:	68 b9 00 00 00       	push   $0xb9
 804f6a8:	68 85 2f 05 08       	push   $0x8052f85
 804f6ad:	68 df 2f 05 08       	push   $0x8052fdf
 804f6b2:	68 1c 1c 05 08       	push   $0x8051c1c
 804f6b7:	e8 7d ba ff ff       	call   804b139 <assert_print>
 804f6bc:	58                   	pop    %eax
 804f6bd:	5a                   	pop    %edx
 804f6be:	68 dc 6a 05 08       	push   $0x8056adc
 804f6c3:	68 f6 2f 05 08       	push   $0x8052ff6
 804f6c8:	e8 6c ba ff ff       	call   804b139 <assert_print>
 804f6cd:	59                   	pop    %ecx
 804f6ce:	5b                   	pop    %ebx
 804f6cf:	68 b9 00 00 00       	push   $0xb9
 804f6d4:	68 85 2f 05 08       	push   $0x8052f85
 804f6d9:	e8 76 ba ff ff       	call   804b154 <assert_post_action>
 804f6de:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804f6e1:	89 75 08             	mov    %esi,0x8(%ebp)
}
 804f6e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804f6e7:	5b                   	pop    %ebx
 804f6e8:	5e                   	pop    %esi
 804f6e9:	5d                   	pop    %ebp
 804f6ea:	e9 b3 d7 ff ff       	jmp    804cea2 <posix_irq_unlock>

0804f6ef <unready_thread>:
{
 804f6ef:	55                   	push   %ebp
 804f6f0:	89 e5                	mov    %esp,%ebp
 804f6f2:	53                   	push   %ebx
 804f6f3:	89 c3                	mov    %eax,%ebx
 804f6f5:	52                   	push   %edx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 804f6f6:	8a 40 0d             	mov    0xd(%eax),%al
	if (z_is_thread_queued(thread)) {
 804f6f9:	84 c0                	test   %al,%al
 804f6fb:	79 16                	jns    804f713 <unready_thread+0x24>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804f6fd:	83 e0 7f             	and    $0x7f,%eax
 804f700:	88 43 0d             	mov    %al,0xd(%ebx)
	_priq_run_remove(thread_runq(thread), thread);
 804f703:	50                   	push   %eax
 804f704:	50                   	push   %eax
 804f705:	53                   	push   %ebx
 804f706:	68 7c 69 05 08       	push   $0x805697c
 804f70b:	e8 d6 f8 ff ff       	call   804efe6 <z_priq_dumb_remove>
 804f710:	83 c4 10             	add    $0x10,%esp
	update_cache(thread == _current);
 804f713:	31 c0                	xor    %eax,%eax
 804f715:	39 1d 68 69 05 08    	cmp    %ebx,0x8056968
}
 804f71b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804f71e:	c9                   	leave  
	update_cache(thread == _current);
 804f71f:	0f 94 c0             	sete   %al
 804f722:	e9 8c f9 ff ff       	jmp    804f0b3 <update_cache>

0804f727 <add_to_waitq_locked>:
{
 804f727:	55                   	push   %ebp
 804f728:	89 e5                	mov    %esp,%ebp
 804f72a:	56                   	push   %esi
 804f72b:	89 d6                	mov    %edx,%esi
 804f72d:	53                   	push   %ebx
 804f72e:	89 c3                	mov    %eax,%ebx
	unready_thread(thread);
 804f730:	e8 ba ff ff ff       	call   804f6ef <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
 804f735:	80 4b 0d 02          	orb    $0x2,0xd(%ebx)
	if (wait_q != NULL) {
 804f739:	85 f6                	test   %esi,%esi
 804f73b:	74 7b                	je     804f7b8 <add_to_waitq_locked+0x91>
		thread->base.pended_on = wait_q;
 804f73d:	89 73 08             	mov    %esi,0x8(%ebx)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
 804f740:	81 fb 60 68 05 08    	cmp    $0x8056860,%ebx
 804f746:	75 2d                	jne    804f775 <add_to_waitq_locked+0x4e>
 804f748:	68 ba 00 00 00       	push   $0xba
 804f74d:	68 6a 30 05 08       	push   $0x805306a
 804f752:	68 8c 30 05 08       	push   $0x805308c
 804f757:	68 1c 1c 05 08       	push   $0x8051c1c
 804f75c:	e8 d8 b9 ff ff       	call   804b139 <assert_print>
 804f761:	58                   	pop    %eax
 804f762:	5a                   	pop    %edx
 804f763:	68 ba 00 00 00       	push   $0xba
 804f768:	68 6a 30 05 08       	push   $0x805306a
 804f76d:	e8 e2 b9 ff ff       	call   804b154 <assert_post_action>
 804f772:	83 c4 10             	add    $0x10,%esp
	return list->head == list;
 804f775:	8b 06                	mov    (%esi),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804f777:	85 c0                	test   %eax,%eax
 804f779:	74 30                	je     804f7ab <add_to_waitq_locked+0x84>
 804f77b:	39 c6                	cmp    %eax,%esi
 804f77d:	74 2c                	je     804f7ab <add_to_waitq_locked+0x84>
	int32_t b1 = thread_1->base.prio;
 804f77f:	0f be 4b 0e          	movsbl 0xe(%ebx),%ecx
	int32_t b2 = thread_2->base.prio;
 804f783:	0f be 50 0e          	movsbl 0xe(%eax),%edx
	if (b1 != b2) {
 804f787:	39 d1                	cmp    %edx,%ecx
 804f789:	74 15                	je     804f7a0 <add_to_waitq_locked+0x79>
		return b2 - b1;
 804f78b:	29 ca                	sub    %ecx,%edx
		if (z_sched_prio_cmp(thread, t) > 0) {
 804f78d:	85 d2                	test   %edx,%edx
 804f78f:	7e 0f                	jle    804f7a0 <add_to_waitq_locked+0x79>
	sys_dnode_t *const prev = successor->prev;
 804f791:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
 804f794:	89 03                	mov    %eax,(%ebx)
	node->prev = prev;
 804f796:	89 53 04             	mov    %edx,0x4(%ebx)
	prev->next = node;
 804f799:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
 804f79b:	89 58 04             	mov    %ebx,0x4(%eax)
}
 804f79e:	eb 18                	jmp    804f7b8 <add_to_waitq_locked+0x91>
	return (node == list->tail) ? NULL : node->next;
 804f7a0:	3b 46 04             	cmp    0x4(%esi),%eax
 804f7a3:	74 06                	je     804f7ab <add_to_waitq_locked+0x84>
 804f7a5:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804f7a7:	85 c0                	test   %eax,%eax
 804f7a9:	75 d8                	jne    804f783 <add_to_waitq_locked+0x5c>
	sys_dnode_t *const tail = list->tail;
 804f7ab:	8b 46 04             	mov    0x4(%esi),%eax
	node->next = list;
 804f7ae:	89 33                	mov    %esi,(%ebx)
	node->prev = tail;
 804f7b0:	89 43 04             	mov    %eax,0x4(%ebx)
	tail->next = node;
 804f7b3:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
 804f7b5:	89 5e 04             	mov    %ebx,0x4(%esi)
}
 804f7b8:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804f7bb:	5b                   	pop    %ebx
 804f7bc:	5e                   	pop    %esi
 804f7bd:	5d                   	pop    %ebp
 804f7be:	c3                   	ret    

0804f7bf <k_sched_unlock>:
{
 804f7bf:	f3 0f 1e fb          	endbr32 
 804f7c3:	55                   	push   %ebp
 804f7c4:	89 e5                	mov    %esp,%ebp
 804f7c6:	53                   	push   %ebx
 804f7c7:	50                   	push   %eax
	return posix_irq_lock();
 804f7c8:	e8 bf d6 ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 804f7cd:	83 ec 0c             	sub    $0xc,%esp
 804f7d0:	68 dc 6a 05 08       	push   $0x8056adc
 804f7d5:	89 c3                	mov    %eax,%ebx
 804f7d7:	e8 64 f3 ff ff       	call   804eb40 <z_spin_lock_valid>
 804f7dc:	83 c4 10             	add    $0x10,%esp
 804f7df:	84 c0                	test   %al,%al
 804f7e1:	75 3e                	jne    804f821 <k_sched_unlock+0x62>
 804f7e3:	68 8e 00 00 00       	push   $0x8e
 804f7e8:	68 85 2f 05 08       	push   $0x8052f85
 804f7ed:	68 b2 2f 05 08       	push   $0x8052fb2
 804f7f2:	68 1c 1c 05 08       	push   $0x8051c1c
 804f7f7:	e8 3d b9 ff ff       	call   804b139 <assert_print>
 804f7fc:	58                   	pop    %eax
 804f7fd:	5a                   	pop    %edx
 804f7fe:	68 dc 6a 05 08       	push   $0x8056adc
 804f803:	68 c7 2f 05 08       	push   $0x8052fc7
 804f808:	e8 2c b9 ff ff       	call   804b139 <assert_print>
 804f80d:	59                   	pop    %ecx
 804f80e:	58                   	pop    %eax
 804f80f:	68 8e 00 00 00       	push   $0x8e
 804f814:	68 85 2f 05 08       	push   $0x8052f85
 804f819:	e8 36 b9 ff ff       	call   804b154 <assert_post_action>
 804f81e:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 804f821:	83 ec 0c             	sub    $0xc,%esp
 804f824:	68 dc 6a 05 08       	push   $0x8056adc
 804f829:	e8 60 f3 ff ff       	call   804eb8e <z_spin_lock_set_owner>
		__ASSERT(_current->base.sched_locked != 0U, "");
 804f82e:	a1 68 69 05 08       	mov    0x8056968,%eax
 804f833:	83 c4 10             	add    $0x10,%esp
 804f836:	80 78 0f 00          	cmpb   $0x0,0xf(%eax)
 804f83a:	75 39                	jne    804f875 <k_sched_unlock+0xb6>
 804f83c:	68 d6 03 00 00       	push   $0x3d6
 804f841:	68 6a 30 05 08       	push   $0x805306a
 804f846:	68 eb 30 05 08       	push   $0x80530eb
 804f84b:	68 1c 1c 05 08       	push   $0x8051c1c
 804f850:	e8 e4 b8 ff ff       	call   804b139 <assert_print>
 804f855:	c7 04 24 36 30 05 08 	movl   $0x8053036,(%esp)
 804f85c:	e8 d8 b8 ff ff       	call   804b139 <assert_print>
 804f861:	59                   	pop    %ecx
 804f862:	58                   	pop    %eax
 804f863:	68 d6 03 00 00       	push   $0x3d6
 804f868:	68 6a 30 05 08       	push   $0x805306a
 804f86d:	e8 e2 b8 ff ff       	call   804b154 <assert_post_action>
 804f872:	83 c4 10             	add    $0x10,%esp
		__ASSERT(!arch_is_in_isr(), "");
 804f875:	83 3d 60 69 05 08 00 	cmpl   $0x0,0x8056960
 804f87c:	74 39                	je     804f8b7 <k_sched_unlock+0xf8>
 804f87e:	68 d7 03 00 00       	push   $0x3d7
 804f883:	68 6a 30 05 08       	push   $0x805306a
 804f888:	68 d8 2e 05 08       	push   $0x8052ed8
 804f88d:	68 1c 1c 05 08       	push   $0x8051c1c
 804f892:	e8 a2 b8 ff ff       	call   804b139 <assert_print>
 804f897:	c7 04 24 36 30 05 08 	movl   $0x8053036,(%esp)
 804f89e:	e8 96 b8 ff ff       	call   804b139 <assert_print>
 804f8a3:	58                   	pop    %eax
 804f8a4:	5a                   	pop    %edx
 804f8a5:	68 d7 03 00 00       	push   $0x3d7
 804f8aa:	68 6a 30 05 08       	push   $0x805306a
 804f8af:	e8 a0 b8 ff ff       	call   804b154 <assert_post_action>
 804f8b4:	83 c4 10             	add    $0x10,%esp
		++_current->base.sched_locked;
 804f8b7:	a1 68 69 05 08       	mov    0x8056968,%eax
 804f8bc:	fe 40 0f             	incb   0xf(%eax)
		update_cache(0);
 804f8bf:	31 c0                	xor    %eax,%eax
 804f8c1:	e8 ed f7 ff ff       	call   804f0b3 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804f8c6:	83 ec 0c             	sub    $0xc,%esp
 804f8c9:	68 dc 6a 05 08       	push   $0x8056adc
 804f8ce:	e8 92 f2 ff ff       	call   804eb65 <z_spin_unlock_valid>
 804f8d3:	83 c4 10             	add    $0x10,%esp
 804f8d6:	84 c0                	test   %al,%al
 804f8d8:	75 3e                	jne    804f918 <k_sched_unlock+0x159>
 804f8da:	68 b9 00 00 00       	push   $0xb9
 804f8df:	68 85 2f 05 08       	push   $0x8052f85
 804f8e4:	68 df 2f 05 08       	push   $0x8052fdf
 804f8e9:	68 1c 1c 05 08       	push   $0x8051c1c
 804f8ee:	e8 46 b8 ff ff       	call   804b139 <assert_print>
 804f8f3:	58                   	pop    %eax
 804f8f4:	5a                   	pop    %edx
 804f8f5:	68 dc 6a 05 08       	push   $0x8056adc
 804f8fa:	68 f6 2f 05 08       	push   $0x8052ff6
 804f8ff:	e8 35 b8 ff ff       	call   804b139 <assert_print>
 804f904:	59                   	pop    %ecx
 804f905:	58                   	pop    %eax
 804f906:	68 b9 00 00 00       	push   $0xb9
 804f90b:	68 85 2f 05 08       	push   $0x8052f85
 804f910:	e8 3f b8 ff ff       	call   804b154 <assert_post_action>
 804f915:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804f918:	83 ec 0c             	sub    $0xc,%esp
 804f91b:	53                   	push   %ebx
 804f91c:	e8 81 d5 ff ff       	call   804cea2 <posix_irq_unlock>
}
 804f921:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804f924:	83 c4 10             	add    $0x10,%esp
 804f927:	c9                   	leave  
	z_reschedule_unlocked();
 804f928:	e9 3d f5 ff ff       	jmp    804ee6a <z_reschedule_unlocked>

0804f92d <z_sched_init>:
	sys_dlist_init(&rq->runq);
#endif
}

void z_sched_init(void)
{
 804f92d:	f3 0f 1e fb          	endbr32 
 804f931:	55                   	push   %ebp
 804f932:	89 e5                	mov    %esp,%ebp
 804f934:	83 ec 10             	sub    $0x10,%esp
	list->head = (sys_dnode_t *)list;
 804f937:	c7 05 7c 69 05 08 7c 	movl   $0x805697c,0x805697c
 804f93e:	69 05 08 
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
 804f941:	6a 00                	push   $0x0
 804f943:	6a 00                	push   $0x0
	list->tail = (sys_dnode_t *)list;
 804f945:	c7 05 80 69 05 08 7c 	movl   $0x805697c,0x8056980
 804f94c:	69 05 08 
 804f94f:	e8 d4 f2 ff ff       	call   804ec28 <k_sched_time_slice_set>
 804f954:	83 c4 10             	add    $0x10,%esp
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
 804f957:	c9                   	leave  
 804f958:	c3                   	ret    

0804f959 <z_impl_z_current_get>:
}
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_z_current_get(void)
{
 804f959:	f3 0f 1e fb          	endbr32 

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
 804f95d:	a1 68 69 05 08       	mov    0x8056968,%eax
 804f962:	c3                   	ret    

0804f963 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
 804f963:	f3 0f 1e fb          	endbr32 
 804f967:	55                   	push   %ebp
 804f968:	89 e5                	mov    %esp,%ebp
 804f96a:	57                   	push   %edi
 804f96b:	56                   	push   %esi
 804f96c:	53                   	push   %ebx
 804f96d:	83 ec 0c             	sub    $0xc,%esp
 804f970:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
 804f973:	e8 14 d5 ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 804f978:	83 ec 0c             	sub    $0xc,%esp
 804f97b:	68 dc 6a 05 08       	push   $0x8056adc
 804f980:	89 c6                	mov    %eax,%esi
 804f982:	e8 b9 f1 ff ff       	call   804eb40 <z_spin_lock_valid>
 804f987:	83 c4 10             	add    $0x10,%esp
 804f98a:	84 c0                	test   %al,%al
 804f98c:	75 3e                	jne    804f9cc <z_thread_abort+0x69>
 804f98e:	68 8e 00 00 00       	push   $0x8e
 804f993:	68 85 2f 05 08       	push   $0x8052f85
 804f998:	68 b2 2f 05 08       	push   $0x8052fb2
 804f99d:	68 1c 1c 05 08       	push   $0x8051c1c
 804f9a2:	e8 92 b7 ff ff       	call   804b139 <assert_print>
 804f9a7:	58                   	pop    %eax
 804f9a8:	5a                   	pop    %edx
 804f9a9:	68 dc 6a 05 08       	push   $0x8056adc
 804f9ae:	68 c7 2f 05 08       	push   $0x8052fc7
 804f9b3:	e8 81 b7 ff ff       	call   804b139 <assert_print>
 804f9b8:	59                   	pop    %ecx
 804f9b9:	5f                   	pop    %edi
 804f9ba:	68 8e 00 00 00       	push   $0x8e
 804f9bf:	68 85 2f 05 08       	push   $0x8052f85
 804f9c4:	e8 8b b7 ff ff       	call   804b154 <assert_post_action>
 804f9c9:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 804f9cc:	83 ec 0c             	sub    $0xc,%esp
 804f9cf:	68 dc 6a 05 08       	push   $0x8056adc
 804f9d4:	e8 b5 f1 ff ff       	call   804eb8e <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 804f9d9:	8a 43 0d             	mov    0xd(%ebx),%al
 804f9dc:	83 c4 10             	add    $0x10,%esp
 804f9df:	a8 08                	test   $0x8,%al
 804f9e1:	0f 85 32 01 00 00    	jne    804fb19 <z_thread_abort+0x1b6>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 804f9e7:	89 c2                	mov    %eax,%edx
 804f9e9:	83 e2 df             	and    $0xffffffdf,%edx
		if (z_is_thread_queued(thread)) {
 804f9ec:	80 ca 08             	or     $0x8,%dl
 804f9ef:	78 05                	js     804f9f6 <z_thread_abort+0x93>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 804f9f1:	88 53 0d             	mov    %dl,0xd(%ebx)
 804f9f4:	eb 19                	jmp    804fa0f <z_thread_abort+0xac>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804f9f6:	83 e0 5f             	and    $0x5f,%eax
 804f9f9:	83 c8 08             	or     $0x8,%eax
 804f9fc:	88 43 0d             	mov    %al,0xd(%ebx)
	_priq_run_remove(thread_runq(thread), thread);
 804f9ff:	57                   	push   %edi
 804fa00:	57                   	push   %edi
 804fa01:	53                   	push   %ebx
 804fa02:	68 7c 69 05 08       	push   $0x805697c
 804fa07:	e8 da f5 ff ff       	call   804efe6 <z_priq_dumb_remove>
 804fa0c:	83 c4 10             	add    $0x10,%esp
		if (thread->base.pended_on != NULL) {
 804fa0f:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
 804fa13:	74 07                	je     804fa1c <z_thread_abort+0xb9>
			unpend_thread_no_timeout(thread);
 804fa15:	89 d8                	mov    %ebx,%eax
 804fa17:	e8 27 f6 ff ff       	call   804f043 <unpend_thread_no_timeout>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
 804fa1c:	83 ec 0c             	sub    $0xc,%esp
 804fa1f:	8d 43 18             	lea    0x18(%ebx),%eax
 804fa22:	50                   	push   %eax
 804fa23:	e8 52 06 00 00       	call   805007a <z_abort_timeout>
 804fa28:	83 c4 10             	add    $0x10,%esp
	return list->head == list;
 804fa2b:	8b 7b 3c             	mov    0x3c(%ebx),%edi
	while ((thread = z_waitq_head(wait_q)) != NULL) {
 804fa2e:	85 ff                	test   %edi,%edi
 804fa30:	74 2d                	je     804fa5f <z_thread_abort+0xfc>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 804fa32:	8d 43 3c             	lea    0x3c(%ebx),%eax
 804fa35:	39 c7                	cmp    %eax,%edi
 804fa37:	74 26                	je     804fa5f <z_thread_abort+0xfc>
		unpend_thread_no_timeout(thread);
 804fa39:	89 f8                	mov    %edi,%eax
 804fa3b:	e8 03 f6 ff ff       	call   804f043 <unpend_thread_no_timeout>
 804fa40:	83 ec 0c             	sub    $0xc,%esp
 804fa43:	8d 47 18             	lea    0x18(%edi),%eax
 804fa46:	50                   	push   %eax
 804fa47:	e8 2e 06 00 00       	call   805007a <z_abort_timeout>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->callee_saved.retval = value;
 804fa4c:	c7 47 30 00 00 00 00 	movl   $0x0,0x30(%edi)
 804fa53:	83 c4 10             	add    $0x10,%esp
		ready_thread(thread);
 804fa56:	89 f8                	mov    %edi,%eax
 804fa58:	e8 f6 f8 ff ff       	call   804f353 <ready_thread>
 804fa5d:	eb cc                	jmp    804fa2b <z_thread_abort+0xc8>
		update_cache(1);
 804fa5f:	b8 01 00 00 00       	mov    $0x1,%eax
 804fa64:	e8 4a f6 ff ff       	call   804f0b3 <update_cache>
		}
		return; /* lock has been released */
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
 804fa69:	39 1d 68 69 05 08    	cmp    %ebx,0x8056968
 804fa6f:	0f 85 a4 00 00 00    	jne    804fb19 <z_thread_abort+0x1b6>
 804fa75:	83 3d 60 69 05 08 00 	cmpl   $0x0,0x8056960
 804fa7c:	0f 85 97 00 00 00    	jne    804fb19 <z_thread_abort+0x1b6>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804fa82:	83 ec 0c             	sub    $0xc,%esp
 804fa85:	68 dc 6a 05 08       	push   $0x8056adc
 804fa8a:	e8 d6 f0 ff ff       	call   804eb65 <z_spin_unlock_valid>
 804fa8f:	83 c4 10             	add    $0x10,%esp
 804fa92:	84 c0                	test   %al,%al
 804fa94:	75 3e                	jne    804fad4 <z_thread_abort+0x171>
 804fa96:	68 d0 00 00 00       	push   $0xd0
 804fa9b:	68 85 2f 05 08       	push   $0x8052f85
 804faa0:	68 df 2f 05 08       	push   $0x8052fdf
 804faa5:	68 1c 1c 05 08       	push   $0x8051c1c
 804faaa:	e8 8a b6 ff ff       	call   804b139 <assert_print>
 804faaf:	58                   	pop    %eax
 804fab0:	5a                   	pop    %edx
 804fab1:	68 dc 6a 05 08       	push   $0x8056adc
 804fab6:	68 f6 2f 05 08       	push   $0x8052ff6
 804fabb:	e8 79 b6 ff ff       	call   804b139 <assert_print>
 804fac0:	59                   	pop    %ecx
 804fac1:	5b                   	pop    %ebx
 804fac2:	68 d0 00 00 00       	push   $0xd0
 804fac7:	68 85 2f 05 08       	push   $0x8052f85
 804facc:	e8 83 b6 ff ff       	call   804b154 <assert_post_action>
 804fad1:	83 c4 10             	add    $0x10,%esp
 804fad4:	83 ec 0c             	sub    $0xc,%esp
 804fad7:	56                   	push   %esi
 804fad8:	e8 4b c6 ff ff       	call   804c128 <arch_swap>
 804fadd:	83 c4 10             	add    $0x10,%esp
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
 804fae0:	68 dd 06 00 00       	push   $0x6dd
 804fae5:	68 6a 30 05 08       	push   $0x805306a
 804faea:	68 2e 18 05 08       	push   $0x805182e
 804faef:	68 1c 1c 05 08       	push   $0x8051c1c
 804faf4:	e8 40 b6 ff ff       	call   804b139 <assert_print>
 804faf9:	c7 04 24 1c 31 05 08 	movl   $0x805311c,(%esp)
 804fb00:	e8 34 b6 ff ff       	call   804b139 <assert_print>
 804fb05:	5f                   	pop    %edi
 804fb06:	58                   	pop    %eax
 804fb07:	68 dd 06 00 00       	push   $0x6dd
 804fb0c:	68 6a 30 05 08       	push   $0x805306a
 804fb11:	e8 3e b6 ff ff       	call   804b154 <assert_post_action>
 804fb16:	83 c4 10             	add    $0x10,%esp
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804fb19:	83 ec 0c             	sub    $0xc,%esp
 804fb1c:	68 dc 6a 05 08       	push   $0x8056adc
 804fb21:	e8 3f f0 ff ff       	call   804eb65 <z_spin_unlock_valid>
 804fb26:	83 c4 10             	add    $0x10,%esp
 804fb29:	84 c0                	test   %al,%al
 804fb2b:	75 3e                	jne    804fb6b <z_thread_abort+0x208>
 804fb2d:	68 b9 00 00 00       	push   $0xb9
 804fb32:	68 85 2f 05 08       	push   $0x8052f85
 804fb37:	68 df 2f 05 08       	push   $0x8052fdf
 804fb3c:	68 1c 1c 05 08       	push   $0x8051c1c
 804fb41:	e8 f3 b5 ff ff       	call   804b139 <assert_print>
 804fb46:	58                   	pop    %eax
 804fb47:	5a                   	pop    %edx
 804fb48:	68 dc 6a 05 08       	push   $0x8056adc
 804fb4d:	68 f6 2f 05 08       	push   $0x8052ff6
 804fb52:	e8 e2 b5 ff ff       	call   804b139 <assert_print>
 804fb57:	59                   	pop    %ecx
 804fb58:	5b                   	pop    %ebx
 804fb59:	68 b9 00 00 00       	push   $0xb9
 804fb5e:	68 85 2f 05 08       	push   $0x8052f85
 804fb63:	e8 ec b5 ff ff       	call   804b154 <assert_post_action>
 804fb68:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804fb6b:	89 75 08             	mov    %esi,0x8(%ebp)
	}
	k_spin_unlock(&sched_spinlock, key);
}
 804fb6e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804fb71:	5b                   	pop    %ebx
 804fb72:	5e                   	pop    %esi
 804fb73:	5f                   	pop    %edi
 804fb74:	5d                   	pop    %ebp
 804fb75:	e9 28 d3 ff ff       	jmp    804cea2 <posix_irq_unlock>

0804fb7a <z_impl_k_thread_join>:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, abort, thread);
}
#endif

int z_impl_k_thread_join(struct k_thread *thread, k_timeout_t timeout)
{
 804fb7a:	f3 0f 1e fb          	endbr32 
 804fb7e:	55                   	push   %ebp
 804fb7f:	89 e5                	mov    %esp,%ebp
 804fb81:	57                   	push   %edi
 804fb82:	56                   	push   %esi
 804fb83:	53                   	push   %ebx
 804fb84:	83 ec 1c             	sub    $0x1c,%esp
 804fb87:	8b 45 10             	mov    0x10(%ebp),%eax
 804fb8a:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804fb8d:	8b 75 0c             	mov    0xc(%ebp),%esi
 804fb90:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return posix_irq_lock();
 804fb93:	e8 f4 d2 ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 804fb98:	83 ec 0c             	sub    $0xc,%esp
 804fb9b:	68 dc 6a 05 08       	push   $0x8056adc
 804fba0:	89 c7                	mov    %eax,%edi
 804fba2:	e8 99 ef ff ff       	call   804eb40 <z_spin_lock_valid>
 804fba7:	83 c4 10             	add    $0x10,%esp
 804fbaa:	84 c0                	test   %al,%al
 804fbac:	75 3e                	jne    804fbec <z_impl_k_thread_join+0x72>
 804fbae:	68 8e 00 00 00       	push   $0x8e
 804fbb3:	68 85 2f 05 08       	push   $0x8052f85
 804fbb8:	68 b2 2f 05 08       	push   $0x8052fb2
 804fbbd:	68 1c 1c 05 08       	push   $0x8051c1c
 804fbc2:	e8 72 b5 ff ff       	call   804b139 <assert_print>
 804fbc7:	59                   	pop    %ecx
 804fbc8:	58                   	pop    %eax
 804fbc9:	68 dc 6a 05 08       	push   $0x8056adc
 804fbce:	68 c7 2f 05 08       	push   $0x8052fc7
 804fbd3:	e8 61 b5 ff ff       	call   804b139 <assert_print>
 804fbd8:	58                   	pop    %eax
 804fbd9:	5a                   	pop    %edx
 804fbda:	68 8e 00 00 00       	push   $0x8e
 804fbdf:	68 85 2f 05 08       	push   $0x8052f85
 804fbe4:	e8 6b b5 ff ff       	call   804b154 <assert_post_action>
 804fbe9:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 804fbec:	83 ec 0c             	sub    $0xc,%esp
 804fbef:	68 dc 6a 05 08       	push   $0x8056adc
 804fbf4:	e8 95 ef ff ff       	call   804eb8e <z_spin_lock_set_owner>
 804fbf9:	83 c4 10             	add    $0x10,%esp
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);
	int ret = 0;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, join, thread, timeout);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 804fbfc:	f6 43 0d 08          	testb  $0x8,0xd(%ebx)
 804fc00:	0f 85 fa 00 00 00    	jne    804fd00 <z_impl_k_thread_join+0x186>
		ret = 0;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 804fc06:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804fc09:	09 f0                	or     %esi,%eax
 804fc0b:	0f 84 f3 00 00 00    	je     804fd04 <z_impl_k_thread_join+0x18a>
		ret = -EBUSY;
	} else if ((thread == _current) ||
 804fc11:	a1 68 69 05 08       	mov    0x8056968,%eax
 804fc16:	39 d8                	cmp    %ebx,%eax
 804fc18:	0f 84 ed 00 00 00    	je     804fd0b <z_impl_k_thread_join+0x191>
		   (thread->base.pended_on == &_current->join_queue)) {
 804fc1e:	83 c0 3c             	add    $0x3c,%eax
	} else if ((thread == _current) ||
 804fc21:	39 43 08             	cmp    %eax,0x8(%ebx)
 804fc24:	0f 84 e1 00 00 00    	je     804fd0b <z_impl_k_thread_join+0x191>
		ret = -EDEADLK;
	} else {
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
 804fc2a:	83 3d 60 69 05 08 00 	cmpl   $0x0,0x8056960
 804fc31:	74 39                	je     804fc6c <z_impl_k_thread_join+0xf2>
 804fc33:	68 fc 06 00 00       	push   $0x6fc
 804fc38:	68 6a 30 05 08       	push   $0x805306a
 804fc3d:	68 d8 2e 05 08       	push   $0x8052ed8
 804fc42:	68 1c 1c 05 08       	push   $0x8051c1c
 804fc47:	e8 ed b4 ff ff       	call   804b139 <assert_print>
 804fc4c:	c7 04 24 3e 31 05 08 	movl   $0x805313e,(%esp)
 804fc53:	e8 e1 b4 ff ff       	call   804b139 <assert_print>
 804fc58:	58                   	pop    %eax
 804fc59:	5a                   	pop    %edx
 804fc5a:	68 fc 06 00 00       	push   $0x6fc
 804fc5f:	68 6a 30 05 08       	push   $0x805306a
 804fc64:	e8 eb b4 ff ff       	call   804b154 <assert_post_action>
 804fc69:	83 c4 10             	add    $0x10,%esp
		add_to_waitq_locked(_current, &thread->join_queue);
 804fc6c:	a1 68 69 05 08       	mov    0x8056968,%eax
 804fc71:	8d 53 3c             	lea    0x3c(%ebx),%edx
 804fc74:	e8 ae fa ff ff       	call   804f727 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804fc79:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
 804fc7d:	75 05                	jne    804fc84 <z_impl_k_thread_join+0x10a>
 804fc7f:	83 fe ff             	cmp    $0xffffffff,%esi
 804fc82:	74 1b                	je     804fc9f <z_impl_k_thread_join+0x125>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 804fc84:	a1 68 69 05 08       	mov    0x8056968,%eax
 804fc89:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804fc8c:	83 c0 18             	add    $0x18,%eax
 804fc8f:	52                   	push   %edx
 804fc90:	56                   	push   %esi
 804fc91:	68 f4 f5 04 08       	push   $0x804f5f4
 804fc96:	50                   	push   %eax
 804fc97:	e8 87 01 00 00       	call   804fe23 <z_add_timeout>
 804fc9c:	83 c4 10             	add    $0x10,%esp
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804fc9f:	83 ec 0c             	sub    $0xc,%esp
 804fca2:	68 dc 6a 05 08       	push   $0x8056adc
 804fca7:	e8 b9 ee ff ff       	call   804eb65 <z_spin_unlock_valid>
 804fcac:	83 c4 10             	add    $0x10,%esp
 804fcaf:	84 c0                	test   %al,%al
 804fcb1:	75 3e                	jne    804fcf1 <z_impl_k_thread_join+0x177>
 804fcb3:	68 d0 00 00 00       	push   $0xd0
 804fcb8:	68 85 2f 05 08       	push   $0x8052f85
 804fcbd:	68 df 2f 05 08       	push   $0x8052fdf
 804fcc2:	68 1c 1c 05 08       	push   $0x8051c1c
 804fcc7:	e8 6d b4 ff ff       	call   804b139 <assert_print>
 804fccc:	58                   	pop    %eax
 804fccd:	5a                   	pop    %edx
 804fcce:	68 dc 6a 05 08       	push   $0x8056adc
 804fcd3:	68 f6 2f 05 08       	push   $0x8052ff6
 804fcd8:	e8 5c b4 ff ff       	call   804b139 <assert_print>
 804fcdd:	59                   	pop    %ecx
 804fcde:	5b                   	pop    %ebx
 804fcdf:	68 d0 00 00 00       	push   $0xd0
 804fce4:	68 85 2f 05 08       	push   $0x8052f85
 804fce9:	e8 66 b4 ff ff       	call   804b154 <assert_post_action>
 804fcee:	83 c4 10             	add    $0x10,%esp
 804fcf1:	89 7d 08             	mov    %edi,0x8(%ebp)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

	k_spin_unlock(&sched_spinlock, key);
	return ret;
}
 804fcf4:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804fcf7:	5b                   	pop    %ebx
 804fcf8:	5e                   	pop    %esi
 804fcf9:	5f                   	pop    %edi
 804fcfa:	5d                   	pop    %ebp
 804fcfb:	e9 28 c4 ff ff       	jmp    804c128 <arch_swap>
		ret = 0;
 804fd00:	31 db                	xor    %ebx,%ebx
 804fd02:	eb 0c                	jmp    804fd10 <z_impl_k_thread_join+0x196>
		ret = -EBUSY;
 804fd04:	bb f0 ff ff ff       	mov    $0xfffffff0,%ebx
 804fd09:	eb 05                	jmp    804fd10 <z_impl_k_thread_join+0x196>
		ret = -EDEADLK;
 804fd0b:	bb dd ff ff ff       	mov    $0xffffffdd,%ebx
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 804fd10:	83 ec 0c             	sub    $0xc,%esp
 804fd13:	68 dc 6a 05 08       	push   $0x8056adc
 804fd18:	e8 48 ee ff ff       	call   804eb65 <z_spin_unlock_valid>
 804fd1d:	83 c4 10             	add    $0x10,%esp
 804fd20:	84 c0                	test   %al,%al
 804fd22:	75 3e                	jne    804fd62 <z_impl_k_thread_join+0x1e8>
 804fd24:	68 b9 00 00 00       	push   $0xb9
 804fd29:	68 85 2f 05 08       	push   $0x8052f85
 804fd2e:	68 df 2f 05 08       	push   $0x8052fdf
 804fd33:	68 1c 1c 05 08       	push   $0x8051c1c
 804fd38:	e8 fc b3 ff ff       	call   804b139 <assert_print>
 804fd3d:	58                   	pop    %eax
 804fd3e:	5a                   	pop    %edx
 804fd3f:	68 dc 6a 05 08       	push   $0x8056adc
 804fd44:	68 f6 2f 05 08       	push   $0x8052ff6
 804fd49:	e8 eb b3 ff ff       	call   804b139 <assert_print>
 804fd4e:	59                   	pop    %ecx
 804fd4f:	5e                   	pop    %esi
 804fd50:	68 b9 00 00 00       	push   $0xb9
 804fd55:	68 85 2f 05 08       	push   $0x8052f85
 804fd5a:	e8 f5 b3 ff ff       	call   804b154 <assert_post_action>
 804fd5f:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804fd62:	83 ec 0c             	sub    $0xc,%esp
 804fd65:	57                   	push   %edi
 804fd66:	e8 37 d1 ff ff       	call   804cea2 <posix_irq_unlock>
 804fd6b:	83 c4 10             	add    $0x10,%esp
}
 804fd6e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804fd71:	89 d8                	mov    %ebx,%eax
 804fd73:	5b                   	pop    %ebx
 804fd74:	5e                   	pop    %esi
 804fd75:	5f                   	pop    %edi
 804fd76:	5d                   	pop    %ebp
 804fd77:	c3                   	ret    

0804fd78 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 804fd78:	83 3d e0 6a 05 08 00 	cmpl   $0x0,0x8056ae0
 804fd7f:	75 05                	jne    804fd86 <elapsed+0xe>
 804fd81:	e9 1b e7 ff ff       	jmp    804e4a1 <sys_clock_elapsed>
}
 804fd86:	31 c0                	xor    %eax,%eax
 804fd88:	c3                   	ret    

0804fd89 <remove_timeout>:
{
 804fd89:	55                   	push   %ebp
 804fd8a:	8b 10                	mov    (%eax),%edx
 804fd8c:	89 e5                	mov    %esp,%ebp
 804fd8e:	53                   	push   %ebx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 804fd8f:	85 c0                	test   %eax,%eax
 804fd91:	74 18                	je     804fdab <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
 804fd93:	3b 05 94 52 05 08    	cmp    0x8055294,%eax
 804fd99:	74 10                	je     804fdab <remove_timeout+0x22>
	if (next(t) != NULL) {
 804fd9b:	85 d2                	test   %edx,%edx
 804fd9d:	74 0c                	je     804fdab <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
 804fd9f:	8b 48 0c             	mov    0xc(%eax),%ecx
 804fda2:	8b 58 10             	mov    0x10(%eax),%ebx
 804fda5:	01 4a 0c             	add    %ecx,0xc(%edx)
 804fda8:	11 5a 10             	adc    %ebx,0x10(%edx)
	sys_dnode_t *const prev = node->prev;
 804fdab:	8b 48 04             	mov    0x4(%eax),%ecx
	prev->next = next;
 804fdae:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
 804fdb0:	89 4a 04             	mov    %ecx,0x4(%edx)
}
 804fdb3:	5b                   	pop    %ebx
	node->next = NULL;
 804fdb4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 804fdba:	5d                   	pop    %ebp
	node->prev = NULL;
 804fdbb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 804fdc2:	c3                   	ret    

0804fdc3 <next_timeout>:

static int32_t next_timeout(void)
{
 804fdc3:	55                   	push   %ebp
 804fdc4:	89 e5                	mov    %esp,%ebp
 804fdc6:	53                   	push   %ebx
 804fdc7:	51                   	push   %ecx
	return list->head == list;
 804fdc8:	8b 1d 90 52 05 08    	mov    0x8055290,%ebx
	return sys_dlist_is_empty(list) ? NULL : list->head;
 804fdce:	81 fb 90 52 05 08    	cmp    $0x8055290,%ebx
 804fdd4:	75 02                	jne    804fdd8 <next_timeout+0x15>
 804fdd6:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
 804fdd8:	e8 9b ff ff ff       	call   804fd78 <elapsed>
 804fddd:	89 c2                	mov    %eax,%edx
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
 804fddf:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	if ((to == NULL) ||
 804fde4:	85 db                	test   %ebx,%ebx
 804fde6:	74 28                	je     804fe10 <next_timeout+0x4d>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 804fde8:	8b 4b 0c             	mov    0xc(%ebx),%ecx
 804fdeb:	89 d0                	mov    %edx,%eax
 804fded:	8b 5b 10             	mov    0x10(%ebx),%ebx
 804fdf0:	99                   	cltd   
 804fdf1:	29 c1                	sub    %eax,%ecx
	if ((to == NULL) ||
 804fdf3:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 804fdf8:	19 d3                	sbb    %edx,%ebx
	if ((to == NULL) ||
 804fdfa:	31 d2                	xor    %edx,%edx
 804fdfc:	39 c8                	cmp    %ecx,%eax
 804fdfe:	89 d0                	mov    %edx,%eax
 804fe00:	19 d8                	sbb    %ebx,%eax
		ret = MAX_WAIT;
 804fe02:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	if ((to == NULL) ||
 804fe07:	7c 07                	jl     804fe10 <next_timeout+0x4d>
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
 804fe09:	89 c8                	mov    %ecx,%eax
 804fe0b:	85 db                	test   %ebx,%ebx
 804fe0d:	0f 48 c2             	cmovs  %edx,%eax
	}

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
 804fe10:	8b 15 70 69 05 08    	mov    0x8056970,%edx
 804fe16:	85 d2                	test   %edx,%edx
 804fe18:	74 05                	je     804fe1f <next_timeout+0x5c>
 804fe1a:	39 d0                	cmp    %edx,%eax
 804fe1c:	0f 4f c2             	cmovg  %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
 804fe1f:	5a                   	pop    %edx
 804fe20:	5b                   	pop    %ebx
 804fe21:	5d                   	pop    %ebp
 804fe22:	c3                   	ret    

0804fe23 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
 804fe23:	f3 0f 1e fb          	endbr32 
 804fe27:	55                   	push   %ebp
 804fe28:	89 e5                	mov    %esp,%ebp
 804fe2a:	57                   	push   %edi
 804fe2b:	56                   	push   %esi
 804fe2c:	53                   	push   %ebx
 804fe2d:	83 ec 1c             	sub    $0x1c,%esp
 804fe30:	8b 55 14             	mov    0x14(%ebp),%edx
 804fe33:	8b 45 10             	mov    0x10(%ebp),%eax
 804fe36:	8b 75 08             	mov    0x8(%ebp),%esi
 804fe39:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 804fe3c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804fe3f:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
{
 804fe43:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804fe46:	75 0a                	jne    804fe52 <z_add_timeout+0x2f>
 804fe48:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
 804fe4c:	0f 84 20 02 00 00    	je     8050072 <z_add_timeout+0x24f>

#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
 804fe52:	83 3e 00             	cmpl   $0x0,(%esi)
 804fe55:	74 33                	je     804fe8a <z_add_timeout+0x67>
 804fe57:	6a 63                	push   $0x63
 804fe59:	68 53 31 05 08       	push   $0x8053153
 804fe5e:	68 77 31 05 08       	push   $0x8053177
 804fe63:	68 1c 1c 05 08       	push   $0x8051c1c
 804fe68:	e8 cc b2 ff ff       	call   804b139 <assert_print>
 804fe6d:	c7 04 24 36 30 05 08 	movl   $0x8053036,(%esp)
 804fe74:	e8 c0 b2 ff ff       	call   804b139 <assert_print>
 804fe79:	5f                   	pop    %edi
 804fe7a:	58                   	pop    %eax
 804fe7b:	6a 63                	push   $0x63
 804fe7d:	68 53 31 05 08       	push   $0x8053153
 804fe82:	e8 cd b2 ff ff       	call   804b154 <assert_post_action>
 804fe87:	83 c4 10             	add    $0x10,%esp
	to->fn = fn;
 804fe8a:	89 5e 08             	mov    %ebx,0x8(%esi)
	return posix_irq_lock();
 804fe8d:	e8 fa cf ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 804fe92:	83 ec 0c             	sub    $0xc,%esp
 804fe95:	68 e4 6a 05 08       	push   $0x8056ae4
 804fe9a:	89 c7                	mov    %eax,%edi
 804fe9c:	e8 9f ec ff ff       	call   804eb40 <z_spin_lock_valid>
 804fea1:	83 c4 10             	add    $0x10,%esp
 804fea4:	84 c0                	test   %al,%al
 804fea6:	75 3e                	jne    804fee6 <z_add_timeout+0xc3>
 804fea8:	68 8e 00 00 00       	push   $0x8e
 804fead:	68 85 2f 05 08       	push   $0x8052f85
 804feb2:	68 b2 2f 05 08       	push   $0x8052fb2
 804feb7:	68 1c 1c 05 08       	push   $0x8051c1c
 804febc:	e8 78 b2 ff ff       	call   804b139 <assert_print>
 804fec1:	58                   	pop    %eax
 804fec2:	5a                   	pop    %edx
 804fec3:	68 e4 6a 05 08       	push   $0x8056ae4
 804fec8:	68 c7 2f 05 08       	push   $0x8052fc7
 804fecd:	e8 67 b2 ff ff       	call   804b139 <assert_print>
 804fed2:	59                   	pop    %ecx
 804fed3:	5b                   	pop    %ebx
 804fed4:	68 8e 00 00 00       	push   $0x8e
 804fed9:	68 85 2f 05 08       	push   $0x8052f85
 804fede:	e8 71 b2 ff ff       	call   804b154 <assert_post_action>
 804fee3:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 804fee6:	83 ec 0c             	sub    $0xc,%esp
 804fee9:	68 e4 6a 05 08       	push   $0x8056ae4
 804feee:	e8 9b ec ff ff       	call   804eb8e <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
 804fef3:	83 ca ff             	or     $0xffffffff,%edx
 804fef6:	83 c4 10             	add    $0x10,%esp
 804fef9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 804fefe:	89 d3                	mov    %edx,%ebx
 804ff00:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804ff03:	1b 5d e4             	sbb    -0x1c(%ebp),%ebx
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 804ff06:	85 db                	test   %ebx,%ebx
 804ff08:	78 2d                	js     804ff37 <z_add_timeout+0x114>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 804ff0a:	2b 05 20 6a 05 08    	sub    0x8056a20,%eax
 804ff10:	1b 15 24 6a 05 08    	sbb    0x8056a24,%edx
 804ff16:	2b 45 e0             	sub    -0x20(%ebp),%eax
 804ff19:	1b 55 e4             	sbb    -0x1c(%ebp),%edx

			to->dticks = MAX(1, ticks);
 804ff1c:	31 c9                	xor    %ecx,%ecx
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 804ff1e:	89 56 10             	mov    %edx,0x10(%esi)
			to->dticks = MAX(1, ticks);
 804ff21:	8b 56 10             	mov    0x10(%esi),%edx
 804ff24:	39 c1                	cmp    %eax,%ecx
 804ff26:	89 cb                	mov    %ecx,%ebx
 804ff28:	19 d3                	sbb    %edx,%ebx
 804ff2a:	bb 01 00 00 00       	mov    $0x1,%ebx
 804ff2f:	0f 4d c3             	cmovge %ebx,%eax
 804ff32:	0f 4d d1             	cmovge %ecx,%edx
 804ff35:	eb 1c                	jmp    804ff53 <z_add_timeout+0x130>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
 804ff37:	e8 3c fe ff ff       	call   804fd78 <elapsed>
 804ff3c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ff3f:	89 c1                	mov    %eax,%ecx
 804ff41:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804ff44:	89 cb                	mov    %ecx,%ebx
 804ff46:	83 c0 01             	add    $0x1,%eax
 804ff49:	83 d2 00             	adc    $0x0,%edx
 804ff4c:	c1 fb 1f             	sar    $0x1f,%ebx
 804ff4f:	01 c8                	add    %ecx,%eax
 804ff51:	11 da                	adc    %ebx,%edx
 804ff53:	89 46 0c             	mov    %eax,0xc(%esi)
	return list->head == list;
 804ff56:	a1 90 52 05 08       	mov    0x8055290,%eax
 804ff5b:	89 56 10             	mov    %edx,0x10(%esi)
 804ff5e:	8b 15 94 52 05 08    	mov    0x8055294,%edx
 804ff64:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
 804ff67:	3d 90 52 05 08       	cmp    $0x8055290,%eax
 804ff6c:	74 64                	je     804ffd2 <z_add_timeout+0x1af>
		}

		for (t = first(); t != NULL; t = next(t)) {
 804ff6e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 804ff72:	74 5e                	je     804ffd2 <z_add_timeout+0x1af>
			if (t->dticks > to->dticks) {
 804ff74:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804ff77:	8b 58 10             	mov    0x10(%eax),%ebx
 804ff7a:	8b 48 0c             	mov    0xc(%eax),%ecx
 804ff7d:	89 5d dc             	mov    %ebx,-0x24(%ebp)
 804ff80:	8b 5e 10             	mov    0x10(%esi),%ebx
 804ff83:	89 4d d8             	mov    %ecx,-0x28(%ebp)
 804ff86:	8b 4e 0c             	mov    0xc(%esi),%ecx
 804ff89:	89 d8                	mov    %ebx,%eax
 804ff8b:	3b 4d d8             	cmp    -0x28(%ebp),%ecx
 804ff8e:	1b 45 dc             	sbb    -0x24(%ebp),%eax
 804ff91:	7d 24                	jge    804ffb7 <z_add_timeout+0x194>
				t->dticks -= to->dticks;
 804ff93:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804ff96:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804ff99:	29 c8                	sub    %ecx,%eax
 804ff9b:	89 c1                	mov    %eax,%ecx
 804ff9d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804ffa0:	19 da                	sbb    %ebx,%edx
 804ffa2:	89 50 10             	mov    %edx,0x10(%eax)
	sys_dnode_t *const prev = successor->prev;
 804ffa5:	8b 50 04             	mov    0x4(%eax),%edx
 804ffa8:	89 48 0c             	mov    %ecx,0xc(%eax)
	node->prev = prev;
 804ffab:	89 56 04             	mov    %edx,0x4(%esi)
	node->next = successor;
 804ffae:	89 06                	mov    %eax,(%esi)
	prev->next = node;
 804ffb0:	89 32                	mov    %esi,(%edx)
	successor->prev = node;
 804ffb2:	89 70 04             	mov    %esi,0x4(%eax)
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
 804ffb5:	eb 2c                	jmp    804ffe3 <z_add_timeout+0x1c0>
			to->dticks -= t->dticks;
 804ffb7:	2b 4d d8             	sub    -0x28(%ebp),%ecx
 804ffba:	1b 5d dc             	sbb    -0x24(%ebp),%ebx
 804ffbd:	89 4e 0c             	mov    %ecx,0xc(%esi)
 804ffc0:	89 5e 10             	mov    %ebx,0x10(%esi)
	return (node == list->tail) ? NULL : node->next;
 804ffc3:	39 55 e0             	cmp    %edx,-0x20(%ebp)
 804ffc6:	74 0a                	je     804ffd2 <z_add_timeout+0x1af>
 804ffc8:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804ffcb:	8b 00                	mov    (%eax),%eax
 804ffcd:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804ffd0:	eb 9c                	jmp    804ff6e <z_add_timeout+0x14b>
	node->next = list;
 804ffd2:	c7 06 90 52 05 08    	movl   $0x8055290,(%esi)
	node->prev = tail;
 804ffd8:	89 56 04             	mov    %edx,0x4(%esi)
	tail->next = node;
 804ffdb:	89 32                	mov    %esi,(%edx)
	list->tail = node;
 804ffdd:	89 35 94 52 05 08    	mov    %esi,0x8055294
	return list->head == list;
 804ffe3:	a1 90 52 05 08       	mov    0x8055290,%eax
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
 804ffe8:	39 c6                	cmp    %eax,%esi
 804ffea:	75 25                	jne    8050011 <z_add_timeout+0x1ee>
 804ffec:	3d 90 52 05 08       	cmp    $0x8055290,%eax
 804fff1:	74 1e                	je     8050011 <z_add_timeout+0x1ee>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
 804fff3:	e8 cb fd ff ff       	call   804fdc3 <next_timeout>

			if (next_time == 0 ||
 804fff8:	85 c0                	test   %eax,%eax
 804fffa:	74 08                	je     8050004 <z_add_timeout+0x1e1>
 804fffc:	39 05 70 69 05 08    	cmp    %eax,0x8056970
 8050002:	74 0d                	je     8050011 <z_add_timeout+0x1ee>
			    _current_cpu->slice_ticks != next_time) {
				sys_clock_set_timeout(next_time, false);
 8050004:	56                   	push   %esi
 8050005:	56                   	push   %esi
 8050006:	6a 00                	push   $0x0
 8050008:	50                   	push   %eax
 8050009:	e8 5e e4 ff ff       	call   804e46c <sys_clock_set_timeout>
 805000e:	83 c4 10             	add    $0x10,%esp
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 8050011:	83 ec 0c             	sub    $0xc,%esp
 8050014:	68 e4 6a 05 08       	push   $0x8056ae4
 8050019:	e8 47 eb ff ff       	call   804eb65 <z_spin_unlock_valid>
 805001e:	83 c4 10             	add    $0x10,%esp
 8050021:	84 c0                	test   %al,%al
 8050023:	75 3e                	jne    8050063 <z_add_timeout+0x240>
 8050025:	68 b9 00 00 00       	push   $0xb9
 805002a:	68 85 2f 05 08       	push   $0x8052f85
 805002f:	68 df 2f 05 08       	push   $0x8052fdf
 8050034:	68 1c 1c 05 08       	push   $0x8051c1c
 8050039:	e8 fb b0 ff ff       	call   804b139 <assert_print>
 805003e:	58                   	pop    %eax
 805003f:	5a                   	pop    %edx
 8050040:	68 e4 6a 05 08       	push   $0x8056ae4
 8050045:	68 f6 2f 05 08       	push   $0x8052ff6
 805004a:	e8 ea b0 ff ff       	call   804b139 <assert_print>
 805004f:	59                   	pop    %ecx
 8050050:	5b                   	pop    %ebx
 8050051:	68 b9 00 00 00       	push   $0xb9
 8050056:	68 85 2f 05 08       	push   $0x8052f85
 805005b:	e8 f4 b0 ff ff       	call   804b154 <assert_post_action>
 8050060:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 8050063:	89 7d 08             	mov    %edi,0x8(%ebp)
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
 8050066:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8050069:	5b                   	pop    %ebx
 805006a:	5e                   	pop    %esi
 805006b:	5f                   	pop    %edi
 805006c:	5d                   	pop    %ebp
 805006d:	e9 30 ce ff ff       	jmp    804cea2 <posix_irq_unlock>
 8050072:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8050075:	5b                   	pop    %ebx
 8050076:	5e                   	pop    %esi
 8050077:	5f                   	pop    %edi
 8050078:	5d                   	pop    %ebp
 8050079:	c3                   	ret    

0805007a <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
 805007a:	f3 0f 1e fb          	endbr32 
 805007e:	55                   	push   %ebp
 805007f:	89 e5                	mov    %esp,%ebp
 8050081:	56                   	push   %esi
 8050082:	53                   	push   %ebx
	return posix_irq_lock();
 8050083:	e8 04 ce ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 8050088:	83 ec 0c             	sub    $0xc,%esp
 805008b:	68 e4 6a 05 08       	push   $0x8056ae4
 8050090:	89 c3                	mov    %eax,%ebx
 8050092:	e8 a9 ea ff ff       	call   804eb40 <z_spin_lock_valid>
 8050097:	83 c4 10             	add    $0x10,%esp
 805009a:	84 c0                	test   %al,%al
 805009c:	75 3e                	jne    80500dc <z_abort_timeout+0x62>
 805009e:	68 8e 00 00 00       	push   $0x8e
 80500a3:	68 85 2f 05 08       	push   $0x8052f85
 80500a8:	68 b2 2f 05 08       	push   $0x8052fb2
 80500ad:	68 1c 1c 05 08       	push   $0x8051c1c
 80500b2:	e8 82 b0 ff ff       	call   804b139 <assert_print>
 80500b7:	58                   	pop    %eax
 80500b8:	5a                   	pop    %edx
 80500b9:	68 e4 6a 05 08       	push   $0x8056ae4
 80500be:	68 c7 2f 05 08       	push   $0x8052fc7
 80500c3:	e8 71 b0 ff ff       	call   804b139 <assert_print>
 80500c8:	59                   	pop    %ecx
 80500c9:	5e                   	pop    %esi
 80500ca:	68 8e 00 00 00       	push   $0x8e
 80500cf:	68 85 2f 05 08       	push   $0x8052f85
 80500d4:	e8 7b b0 ff ff       	call   804b154 <assert_post_action>
 80500d9:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 80500dc:	83 ec 0c             	sub    $0xc,%esp
	int ret = -EINVAL;
 80500df:	be ea ff ff ff       	mov    $0xffffffea,%esi
 80500e4:	68 e4 6a 05 08       	push   $0x8056ae4
 80500e9:	e8 a0 ea ff ff       	call   804eb8e <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
 80500ee:	8b 45 08             	mov    0x8(%ebp),%eax
 80500f1:	83 c4 10             	add    $0x10,%esp
 80500f4:	83 38 00             	cmpl   $0x0,(%eax)
 80500f7:	74 07                	je     8050100 <z_abort_timeout+0x86>
			remove_timeout(to);
 80500f9:	e8 8b fc ff ff       	call   804fd89 <remove_timeout>
			ret = 0;
 80500fe:	31 f6                	xor    %esi,%esi
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 8050100:	83 ec 0c             	sub    $0xc,%esp
 8050103:	68 e4 6a 05 08       	push   $0x8056ae4
 8050108:	e8 58 ea ff ff       	call   804eb65 <z_spin_unlock_valid>
 805010d:	83 c4 10             	add    $0x10,%esp
 8050110:	84 c0                	test   %al,%al
 8050112:	75 3e                	jne    8050152 <z_abort_timeout+0xd8>
 8050114:	68 b9 00 00 00       	push   $0xb9
 8050119:	68 85 2f 05 08       	push   $0x8052f85
 805011e:	68 df 2f 05 08       	push   $0x8052fdf
 8050123:	68 1c 1c 05 08       	push   $0x8051c1c
 8050128:	e8 0c b0 ff ff       	call   804b139 <assert_print>
 805012d:	58                   	pop    %eax
 805012e:	5a                   	pop    %edx
 805012f:	68 e4 6a 05 08       	push   $0x8056ae4
 8050134:	68 f6 2f 05 08       	push   $0x8052ff6
 8050139:	e8 fb af ff ff       	call   804b139 <assert_print>
 805013e:	59                   	pop    %ecx
 805013f:	58                   	pop    %eax
 8050140:	68 b9 00 00 00       	push   $0xb9
 8050145:	68 85 2f 05 08       	push   $0x8052f85
 805014a:	e8 05 b0 ff ff       	call   804b154 <assert_post_action>
 805014f:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 8050152:	83 ec 0c             	sub    $0xc,%esp
 8050155:	53                   	push   %ebx
 8050156:	e8 47 cd ff ff       	call   804cea2 <posix_irq_unlock>
 805015b:	83 c4 10             	add    $0x10,%esp
		}
	}

	return ret;
}
 805015e:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8050161:	89 f0                	mov    %esi,%eax
 8050163:	5b                   	pop    %ebx
 8050164:	5e                   	pop    %esi
 8050165:	5d                   	pop    %ebp
 8050166:	c3                   	ret    

08050167 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
 8050167:	f3 0f 1e fb          	endbr32 
 805016b:	55                   	push   %ebp
 805016c:	89 e5                	mov    %esp,%ebp
 805016e:	57                   	push   %edi
 805016f:	56                   	push   %esi
 8050170:	53                   	push   %ebx
 8050171:	83 ec 0c             	sub    $0xc,%esp
 8050174:	8b 75 08             	mov    0x8(%ebp),%esi
 8050177:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
 805017a:	e8 0d cd ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 805017f:	83 ec 0c             	sub    $0xc,%esp
 8050182:	68 e4 6a 05 08       	push   $0x8056ae4
 8050187:	89 c3                	mov    %eax,%ebx
 8050189:	e8 b2 e9 ff ff       	call   804eb40 <z_spin_lock_valid>
 805018e:	83 c4 10             	add    $0x10,%esp
 8050191:	84 c0                	test   %al,%al
 8050193:	75 3e                	jne    80501d3 <z_set_timeout_expiry+0x6c>
 8050195:	68 8e 00 00 00       	push   $0x8e
 805019a:	68 85 2f 05 08       	push   $0x8052f85
 805019f:	68 b2 2f 05 08       	push   $0x8052fb2
 80501a4:	68 1c 1c 05 08       	push   $0x8051c1c
 80501a9:	e8 8b af ff ff       	call   804b139 <assert_print>
 80501ae:	59                   	pop    %ecx
 80501af:	58                   	pop    %eax
 80501b0:	68 e4 6a 05 08       	push   $0x8056ae4
 80501b5:	68 c7 2f 05 08       	push   $0x8052fc7
 80501ba:	e8 7a af ff ff       	call   804b139 <assert_print>
 80501bf:	58                   	pop    %eax
 80501c0:	5a                   	pop    %edx
 80501c1:	68 8e 00 00 00       	push   $0x8e
 80501c6:	68 85 2f 05 08       	push   $0x8052f85
 80501cb:	e8 84 af ff ff       	call   804b154 <assert_post_action>
 80501d0:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 80501d3:	83 ec 0c             	sub    $0xc,%esp
 80501d6:	68 e4 6a 05 08       	push   $0x8056ae4
 80501db:	e8 ae e9 ff ff       	call   804eb8e <z_spin_lock_set_owner>
 80501e0:	83 c4 10             	add    $0x10,%esp
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
 80501e3:	e8 db fb ff ff       	call   804fdc3 <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
 80501e8:	83 f8 ff             	cmp    $0xffffffff,%eax
 80501eb:	0f 94 c1             	sete   %cl
			      || (ticks <= next_to);
 80501ee:	39 f0                	cmp    %esi,%eax
 80501f0:	0f 9d c2             	setge  %dl
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
 80501f3:	08 d1                	or     %dl,%cl
 80501f5:	74 1b                	je     8050212 <z_set_timeout_expiry+0xab>
 80501f7:	83 f8 01             	cmp    $0x1,%eax
 80501fa:	7e 16                	jle    8050212 <z_set_timeout_expiry+0xab>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
 80501fc:	39 f0                	cmp    %esi,%eax
 80501fe:	52                   	push   %edx
 80501ff:	0f 4f c6             	cmovg  %esi,%eax
 8050202:	52                   	push   %edx
 8050203:	89 fa                	mov    %edi,%edx
 8050205:	0f b6 fa             	movzbl %dl,%edi
 8050208:	57                   	push   %edi
 8050209:	50                   	push   %eax
 805020a:	e8 5d e2 ff ff       	call   804e46c <sys_clock_set_timeout>
 805020f:	83 c4 10             	add    $0x10,%esp
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 8050212:	83 ec 0c             	sub    $0xc,%esp
 8050215:	68 e4 6a 05 08       	push   $0x8056ae4
 805021a:	e8 46 e9 ff ff       	call   804eb65 <z_spin_unlock_valid>
 805021f:	83 c4 10             	add    $0x10,%esp
 8050222:	84 c0                	test   %al,%al
 8050224:	75 3e                	jne    8050264 <z_set_timeout_expiry+0xfd>
 8050226:	68 b9 00 00 00       	push   $0xb9
 805022b:	68 85 2f 05 08       	push   $0x8052f85
 8050230:	68 df 2f 05 08       	push   $0x8052fdf
 8050235:	68 1c 1c 05 08       	push   $0x8051c1c
 805023a:	e8 fa ae ff ff       	call   804b139 <assert_print>
 805023f:	58                   	pop    %eax
 8050240:	5a                   	pop    %edx
 8050241:	68 e4 6a 05 08       	push   $0x8056ae4
 8050246:	68 f6 2f 05 08       	push   $0x8052ff6
 805024b:	e8 e9 ae ff ff       	call   804b139 <assert_print>
 8050250:	59                   	pop    %ecx
 8050251:	5e                   	pop    %esi
 8050252:	68 b9 00 00 00       	push   $0xb9
 8050257:	68 85 2f 05 08       	push   $0x8052f85
 805025c:	e8 f3 ae ff ff       	call   804b154 <assert_post_action>
 8050261:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 8050264:	89 5d 08             	mov    %ebx,0x8(%ebp)
		}
	}
}
 8050267:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805026a:	5b                   	pop    %ebx
 805026b:	5e                   	pop    %esi
 805026c:	5f                   	pop    %edi
 805026d:	5d                   	pop    %ebp
 805026e:	e9 2f cc ff ff       	jmp    804cea2 <posix_irq_unlock>

08050273 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
 8050273:	f3 0f 1e fb          	endbr32 
 8050277:	55                   	push   %ebp
 8050278:	89 e5                	mov    %esp,%ebp
 805027a:	57                   	push   %edi
 805027b:	56                   	push   %esi
 805027c:	53                   	push   %ebx
 805027d:	83 ec 28             	sub    $0x28,%esp
 8050280:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
 8050283:	53                   	push   %ebx
 8050284:	e8 8f ef ff ff       	call   804f218 <z_time_slice>
 8050289:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 805028c:	e8 fb cb ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 8050291:	83 ec 0c             	sub    $0xc,%esp
 8050294:	68 e4 6a 05 08       	push   $0x8056ae4
 8050299:	89 c7                	mov    %eax,%edi
 805029b:	e8 a0 e8 ff ff       	call   804eb40 <z_spin_lock_valid>
 80502a0:	83 c4 10             	add    $0x10,%esp
 80502a3:	84 c0                	test   %al,%al
 80502a5:	75 3e                	jne    80502e5 <sys_clock_announce+0x72>
 80502a7:	68 8e 00 00 00       	push   $0x8e
 80502ac:	68 85 2f 05 08       	push   $0x8052f85
 80502b1:	68 b2 2f 05 08       	push   $0x8052fb2
 80502b6:	68 1c 1c 05 08       	push   $0x8051c1c
 80502bb:	e8 79 ae ff ff       	call   804b139 <assert_print>
 80502c0:	59                   	pop    %ecx
 80502c1:	5e                   	pop    %esi
 80502c2:	68 e4 6a 05 08       	push   $0x8056ae4
 80502c7:	68 c7 2f 05 08       	push   $0x8052fc7
 80502cc:	e8 68 ae ff ff       	call   804b139 <assert_print>
 80502d1:	58                   	pop    %eax
 80502d2:	5a                   	pop    %edx
 80502d3:	68 8e 00 00 00       	push   $0x8e
 80502d8:	68 85 2f 05 08       	push   $0x8052f85
 80502dd:	e8 72 ae ff ff       	call   804b154 <assert_post_action>
 80502e2:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 80502e5:	83 ec 0c             	sub    $0xc,%esp
 80502e8:	68 e4 6a 05 08       	push   $0x8056ae4
 80502ed:	e8 9c e8 ff ff       	call   804eb8e <z_spin_lock_set_owner>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
 80502f2:	89 1d e0 6a 05 08    	mov    %ebx,0x8056ae0
 80502f8:	83 c4 10             	add    $0x10,%esp
 80502fb:	a1 20 6a 05 08       	mov    0x8056a20,%eax
 8050300:	8b 15 24 6a 05 08    	mov    0x8056a24,%edx
 8050306:	8b 1d 90 52 05 08    	mov    0x8055290,%ebx
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
 805030c:	8b 35 e0 6a 05 08    	mov    0x8056ae0,%esi
 8050312:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8050315:	89 55 dc             	mov    %edx,-0x24(%ebp)

	while (first() != NULL && first()->dticks <= announce_remaining) {
 8050318:	85 db                	test   %ebx,%ebx
 805031a:	0f 84 39 01 00 00    	je     8050459 <sys_clock_announce+0x1e6>
 8050320:	81 fb 90 52 05 08    	cmp    $0x8055290,%ebx
 8050326:	0f 84 2d 01 00 00    	je     8050459 <sys_clock_announce+0x1e6>
 805032c:	89 f1                	mov    %esi,%ecx
 805032e:	8b 43 0c             	mov    0xc(%ebx),%eax
 8050331:	8b 53 10             	mov    0x10(%ebx),%edx
 8050334:	89 75 e0             	mov    %esi,-0x20(%ebp)
 8050337:	c1 f9 1f             	sar    $0x1f,%ecx
 805033a:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
 805033d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 8050340:	39 c6                	cmp    %eax,%esi
 8050342:	19 d1                	sbb    %edx,%ecx
 8050344:	0f 8c 03 01 00 00    	jl     805044d <sys_clock_announce+0x1da>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
		announce_remaining -= dt;
		t->dticks = 0;
 805034a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		int dt = t->dticks;
 8050351:	89 c1                	mov    %eax,%ecx
		curr_tick += dt;
 8050353:	99                   	cltd   
 8050354:	03 45 d8             	add    -0x28(%ebp),%eax
		t->dticks = 0;
 8050357:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		curr_tick += dt;
 805035e:	13 55 dc             	adc    -0x24(%ebp),%edx
		announce_remaining -= dt;
 8050361:	29 ce                	sub    %ecx,%esi
		curr_tick += dt;
 8050363:	a3 20 6a 05 08       	mov    %eax,0x8056a20
		remove_timeout(t);
 8050368:	89 d8                	mov    %ebx,%eax
		curr_tick += dt;
 805036a:	89 15 24 6a 05 08    	mov    %edx,0x8056a24
		announce_remaining -= dt;
 8050370:	89 35 e0 6a 05 08    	mov    %esi,0x8056ae0
		remove_timeout(t);
 8050376:	e8 0e fa ff ff       	call   804fd89 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 805037b:	83 ec 0c             	sub    $0xc,%esp
 805037e:	68 e4 6a 05 08       	push   $0x8056ae4
 8050383:	e8 dd e7 ff ff       	call   804eb65 <z_spin_unlock_valid>
 8050388:	83 c4 10             	add    $0x10,%esp
 805038b:	84 c0                	test   %al,%al
 805038d:	75 3e                	jne    80503cd <sys_clock_announce+0x15a>
 805038f:	68 b9 00 00 00       	push   $0xb9
 8050394:	68 85 2f 05 08       	push   $0x8052f85
 8050399:	68 df 2f 05 08       	push   $0x8052fdf
 805039e:	68 1c 1c 05 08       	push   $0x8051c1c
 80503a3:	e8 91 ad ff ff       	call   804b139 <assert_print>
 80503a8:	5e                   	pop    %esi
 80503a9:	58                   	pop    %eax
 80503aa:	68 e4 6a 05 08       	push   $0x8056ae4
 80503af:	68 f6 2f 05 08       	push   $0x8052ff6
 80503b4:	e8 80 ad ff ff       	call   804b139 <assert_print>
 80503b9:	58                   	pop    %eax
 80503ba:	5a                   	pop    %edx
 80503bb:	68 b9 00 00 00       	push   $0xb9
 80503c0:	68 85 2f 05 08       	push   $0x8052f85
 80503c5:	e8 8a ad ff ff       	call   804b154 <assert_post_action>
 80503ca:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 80503cd:	83 ec 0c             	sub    $0xc,%esp
 80503d0:	57                   	push   %edi
 80503d1:	e8 cc ca ff ff       	call   804cea2 <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
 80503d6:	89 1c 24             	mov    %ebx,(%esp)
 80503d9:	ff 53 08             	call   *0x8(%ebx)
 80503dc:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 80503df:	e8 a8 ca ff ff       	call   804ce8c <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
 80503e4:	83 ec 0c             	sub    $0xc,%esp
 80503e7:	68 e4 6a 05 08       	push   $0x8056ae4
 80503ec:	89 c7                	mov    %eax,%edi
 80503ee:	e8 4d e7 ff ff       	call   804eb40 <z_spin_lock_valid>
 80503f3:	83 c4 10             	add    $0x10,%esp
 80503f6:	84 c0                	test   %al,%al
 80503f8:	75 3e                	jne    8050438 <sys_clock_announce+0x1c5>
 80503fa:	68 8e 00 00 00       	push   $0x8e
 80503ff:	68 85 2f 05 08       	push   $0x8052f85
 8050404:	68 b2 2f 05 08       	push   $0x8052fb2
 8050409:	68 1c 1c 05 08       	push   $0x8051c1c
 805040e:	e8 26 ad ff ff       	call   804b139 <assert_print>
 8050413:	58                   	pop    %eax
 8050414:	5a                   	pop    %edx
 8050415:	68 e4 6a 05 08       	push   $0x8056ae4
 805041a:	68 c7 2f 05 08       	push   $0x8052fc7
 805041f:	e8 15 ad ff ff       	call   804b139 <assert_print>
 8050424:	59                   	pop    %ecx
 8050425:	5b                   	pop    %ebx
 8050426:	68 8e 00 00 00       	push   $0x8e
 805042b:	68 85 2f 05 08       	push   $0x8052f85
 8050430:	e8 1f ad ff ff       	call   804b154 <assert_post_action>
 8050435:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
 8050438:	83 ec 0c             	sub    $0xc,%esp
 805043b:	68 e4 6a 05 08       	push   $0x8056ae4
 8050440:	e8 49 e7 ff ff       	call   804eb8e <z_spin_lock_set_owner>
 8050445:	83 c4 10             	add    $0x10,%esp
	return k;
 8050448:	e9 ae fe ff ff       	jmp    80502fb <sys_clock_announce+0x88>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
 805044d:	2b 45 e0             	sub    -0x20(%ebp),%eax
 8050450:	1b 55 e4             	sbb    -0x1c(%ebp),%edx
 8050453:	89 43 0c             	mov    %eax,0xc(%ebx)
 8050456:	89 53 10             	mov    %edx,0x10(%ebx)
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
 8050459:	c7 05 e0 6a 05 08 00 	movl   $0x0,0x8056ae0
 8050460:	00 00 00 
	curr_tick += announce_remaining;
 8050463:	89 f0                	mov    %esi,%eax
 8050465:	99                   	cltd   
 8050466:	03 45 d8             	add    -0x28(%ebp),%eax
 8050469:	13 55 dc             	adc    -0x24(%ebp),%edx
 805046c:	89 15 24 6a 05 08    	mov    %edx,0x8056a24
 8050472:	a3 20 6a 05 08       	mov    %eax,0x8056a20

	sys_clock_set_timeout(next_timeout(), false);
 8050477:	e8 47 f9 ff ff       	call   804fdc3 <next_timeout>
 805047c:	56                   	push   %esi
 805047d:	56                   	push   %esi
 805047e:	6a 00                	push   $0x0
 8050480:	50                   	push   %eax
 8050481:	e8 e6 df ff ff       	call   804e46c <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
 8050486:	c7 04 24 e4 6a 05 08 	movl   $0x8056ae4,(%esp)
 805048d:	e8 d3 e6 ff ff       	call   804eb65 <z_spin_unlock_valid>
 8050492:	83 c4 10             	add    $0x10,%esp
 8050495:	84 c0                	test   %al,%al
 8050497:	75 3e                	jne    80504d7 <sys_clock_announce+0x264>
 8050499:	68 b9 00 00 00       	push   $0xb9
 805049e:	68 85 2f 05 08       	push   $0x8052f85
 80504a3:	68 df 2f 05 08       	push   $0x8052fdf
 80504a8:	68 1c 1c 05 08       	push   $0x8051c1c
 80504ad:	e8 87 ac ff ff       	call   804b139 <assert_print>
 80504b2:	58                   	pop    %eax
 80504b3:	5a                   	pop    %edx
 80504b4:	68 e4 6a 05 08       	push   $0x8056ae4
 80504b9:	68 f6 2f 05 08       	push   $0x8052ff6
 80504be:	e8 76 ac ff ff       	call   804b139 <assert_print>
 80504c3:	59                   	pop    %ecx
 80504c4:	5b                   	pop    %ebx
 80504c5:	68 b9 00 00 00       	push   $0xb9
 80504ca:	68 85 2f 05 08       	push   $0x8052f85
 80504cf:	e8 80 ac ff ff       	call   804b154 <assert_post_action>
 80504d4:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 80504d7:	89 7d 08             	mov    %edi,0x8(%ebp)

	k_spin_unlock(&timeout_lock, key);
}
 80504da:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80504dd:	5b                   	pop    %ebx
 80504de:	5e                   	pop    %esi
 80504df:	5f                   	pop    %edi
 80504e0:	5d                   	pop    %ebp
 80504e1:	e9 bc c9 ff ff       	jmp    804cea2 <posix_irq_unlock>

080504e6 <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
 80504e6:	f3 0f 1e fb          	endbr32 
 80504ea:	55                   	push   %ebp
 80504eb:	89 e5                	mov    %esp,%ebp
 80504ed:	83 ec 0c             	sub    $0xc,%esp
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
 80504f0:	68 38 30 05 08       	push   $0x8053038
 80504f5:	68 97 31 05 08       	push   $0x8053197
 80504fa:	68 b8 31 05 08       	push   $0x80531b8
 80504ff:	e8 97 a2 ff ff       	call   804a79b <printk>
 8050504:	83 c4 10             	add    $0x10,%esp
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
 8050507:	c9                   	leave  
 8050508:	c3                   	ret    

08050509 <z_device_state_init>:
 *
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
 8050509:	f3 0f 1e fb          	endbr32 

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
 805050d:	c3                   	ret    

0805050e <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
 805050e:	f3 0f 1e fb          	endbr32 
 8050512:	55                   	push   %ebp
 8050513:	89 e5                	mov    %esp,%ebp
 8050515:	57                   	push   %edi
 8050516:	56                   	push   %esi
 8050517:	53                   	push   %ebx
 8050518:	83 ec 0c             	sub    $0xc,%esp
 805051b:	8b 5d 08             	mov    0x8(%ebp),%ebx
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 805051e:	8b 34 9d 18 13 05 08 	mov    0x8051318(,%ebx,4),%esi
 8050525:	39 34 9d 1c 13 05 08 	cmp    %esi,0x805131c(,%ebx,4)
 805052c:	76 38                	jbe    8050566 <z_sys_init_run_level+0x58>
		const struct device *dev = entry->dev;
 805052e:	8b 7e 04             	mov    0x4(%esi),%edi
		int rc = entry->init(dev);
 8050531:	83 ec 0c             	sub    $0xc,%esp
 8050534:	57                   	push   %edi
 8050535:	ff 16                	call   *(%esi)
 8050537:	83 c4 10             	add    $0x10,%esp

		if (dev != NULL) {
 805053a:	85 ff                	test   %edi,%edi
 805053c:	74 23                	je     8050561 <z_sys_init_run_level+0x53>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
 805053e:	8b 57 0c             	mov    0xc(%edi),%edx
 8050541:	85 c0                	test   %eax,%eax
 8050543:	74 18                	je     805055d <z_sys_init_run_level+0x4f>
				if (rc < 0) {
 8050545:	89 c1                	mov    %eax,%ecx
 8050547:	c1 f9 1f             	sar    $0x1f,%ecx
 805054a:	31 c8                	xor    %ecx,%eax
 805054c:	29 c8                	sub    %ecx,%eax
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
 805054e:	b9 ff 00 00 00       	mov    $0xff,%ecx
 8050553:	3d ff 00 00 00       	cmp    $0xff,%eax
 8050558:	0f 4f c1             	cmovg  %ecx,%eax
 805055b:	88 02                	mov    %al,(%edx)
			}
			dev->state->initialized = true;
 805055d:	80 4a 01 01          	orb    $0x1,0x1(%edx)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 8050561:	83 c6 08             	add    $0x8,%esi
 8050564:	eb bf                	jmp    8050525 <z_sys_init_run_level+0x17>
		}
	}
}
 8050566:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8050569:	5b                   	pop    %ebx
 805056a:	5e                   	pop    %esi
 805056b:	5f                   	pop    %edi
 805056c:	5d                   	pop    %ebp
 805056d:	c3                   	ret    

0805056e <__x86.get_pc_thunk.bp>:
 805056e:	8b 2c 24             	mov    (%esp),%ebp
 8050571:	c3                   	ret    

Disassembly of section .fini:

08050574 <_fini>:
 8050574:	f3 0f 1e fb          	endbr32 
 8050578:	53                   	push   %ebx
 8050579:	83 ec 08             	sub    $0x8,%esp
 805057c:	e8 8f 90 ff ff       	call   8049610 <__x86.get_pc_thunk.bx>
 8050581:	81 c3 7f 4a 00 00    	add    $0x4a7f,%ebx
 8050587:	83 c4 08             	add    $0x8,%esp
 805058a:	5b                   	pop    %ebx
 805058b:	c3                   	ret    
